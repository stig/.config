#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t h:4
#+PROPERTY: header-args:emacs-lisp    :tangle yes
#+PROPERTY: header-args:sh            :tangle yes
#+PROPERTY: header-args            :results silent
#+STARTUP: content
* Introduction

  This is my Emacs configuration. Because I'm prone to forget what does what,
  my configuration is in the form of a [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document: prose,
  interspaced with code.

  After over a decade with BBEdit I started looking at Emacs again
  when I started learning Clojure. I started with the "better
  defaults" package and added things one-by-one as I found them,
  rather than stealing someone else's mammoth =.emacs= file that I
  didn't understand any of. Initially I drew a lot of inspiration from
  [[https://github.com/magnars/.emacs.d][magnars' .emacs.d]], but after rewriting it using [[https://github.com/jwiegley/use-package][use-package]] (which
  is great) and later using Org mode, it now feels like my own work.

  When I say this document uses literate programming, I mean that the
  configuration snippets here are not copied-and-pasted from my
  config, they /are/ my config. I edit everything in =init.org= and /tangle/
  the code into [[file:init.el][init.el]] by hitting =C-c C-v C-t=.

  However, this document doesn't just contain =emacs-lisp= snippets. It
  also contains some shell snippets to install Emacs itself, and some
  helper programs. By invoking =C-c C-v C-t= on this document an =init.sh=
  file is produced, that contains shell commands that will install all
  the helper programs via /brew/.

** Check out this repo into =~/.emacs.d/=

   I create a symlink from =~/.emacs.d= to the directory containing this file.

** Install Emacs

   I currently get my thrills from using the development version of Emacs.

   #+BEGIN_SRC sh
   brew install emacs --with-cocoa --with-gnutls --with-dbus --with-mailutils --with-librsvg --HEAD
   #+END_SRC

* Meta configuration

** Add Package Archives & priorities

   Before we can install packages, we need to add the URLs of the
   package archives we want to use. I like the ability to use
   Melpa-stable for select packages. I don't use Marmelade as it seems
   to overlap with Melpa.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
   #+END_SRC

** Install =use-package=

   Most of my config use the excellent [[https://github.com/jwiegley/use-package][use-package]] for installing &
   configuring packages. Because it is /itself/ installed via Melpa,
   there's a minor bootstrapping problem: we have to make sure it is
   installed before we can use it to install the rest of the packages.

   #+BEGIN_SRC emacs-lisp
     ;; Bootstrap `use-package' and `dash'
     (unless (and (package-installed-p 'use-package)
		  (package-installed-p 'dash))
       (package-refresh-contents)
       (package-install 'use-package)
       (package-install 'bind-key)
       (package-install 'dash))
   #+END_SRC

   Configure =use-package= to pre-compile the configuration for faster loading.

   #+BEGIN_SRC emacs-lisp
     (eval-when-compile
       (require 'use-package))
     (require 'bind-key)
     (require 'dash)
   #+END_SRC

* Configuration
** Who Am I

   #+BEGIN_SRC emacs-lisp
   (setq user-full-name "Stig Brautaset")
   (setq user-mail-address "stig@brautaset.org")
   #+END_SRC
** Completion

   In the past I've been using Helm, but I did a recent experiment with
   Ivy because I'm a perpetual tinkerer. It doesn't do everything that
   Helm does, and it was annoying in some respects (notably not
   allowing me to create new files in the minibuffer, not allowing
   /closing buffers/ in the minibuffer, and not allowing editable results
   in ag buffer) but I'm a bit confused by helm in some situations and
   checking to see if Ivy suits those better.

*** Helm

    I use [[https://github.com/emacs-helm/helm][Helm]] for interactive completion and finding things,
    particularly files.

    #+BEGIN_SRC emacs-lisp
      (use-package helm
	:ensure t
	:init

	;; Ag buffer names are insanely long...
	(setq helm-buffer-max-length 35)

	:bind (("M-x" . helm-M-x)
	       ("M-y" . helm-show-kill-ring)
	       ("C-x b" . helm-mini)
	       ("C-x C-b" . helm-buffers-list)
	       ("C-x 4 b" . helm-mini)
	       ("C-x C-f" . helm-find-files))

	:config
	(require 'helm-buffers)
	;; Magit creates many buffers, most of which are not interesting.
	(add-to-list 'helm-boring-buffer-regexp-list "\\*magit")

	;; TAGS files are rarely interesting.
	(add-to-list 'helm-boring-buffer-regexp-list "TAGS"))
    #+END_SRC

*** Swiper

    Invoke swiper (find in current buffer).

    #+BEGIN_SRC emacs-lisp
      (use-package swiper
	:ensure t
	:bind (("C-x /" . swiper)))
    #+END_SRC
** Email

   I'm trying to see if I can become happy reading and writing mail in
   Emacs. I tried Gnus for a while, but am now using [[http://www.djcbsoftware.nl/code/mu/][mu/mu4e]]. I use
   [[http://msmtp.sourceforge.net/][msmtp]] for sending email. I use mbsync (part of isync) for syncing
   IMAP messages between my local machine and upstream servers.

*** Installation

    I install everything via brew. The mu4e part requires installing
    emacs via brew too, because Apple's version of Emacs is too old.
    (And I didn't figure out how to make the build process use the Emacs
    version installed by =brew cask install emacs=.)

    #+BEGIN_SRC sh
      brew install mu --with-emacs
      brew install msmtp
      brew install isync
      brew install coreutils
    #+END_SRC

*** Tell Emacs where to find mu & mu4e

    First we add mu4e to our load path and load the package, and tell it where
    our =mu= binary is.

    #+BEGIN_SRC emacs-lisp
      (use-package mu4e
  ;;      :load-path (lambda () (expand-file-name "~/play/mu/mu4e/"))
	:load-path "/usr/local/share/emacs/site-lisp/mu/mu4e/"
	:init
	(setq mu4e-mu-binary "/usr/local/bin/mu"))
    #+END_SRC

*** Where mu4e should save attachments

    When saving attachments, do so to my ~/Downloads folder. Apparently
    this value can also be a function, but I've not needed that yet.

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-attachment-dir "~/Downloads")
    #+END_SRC

*** Show images inline in mu4e

    Try to show images inline if possible, and use imagemagick if our Emacs
    supports that.

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-view-show-images t)

      ;; use imagemagick, if available
      (when (fboundp 'imagemagick-register-types)
	(imagemagick-register-types))
    #+END_SRC

*** Show addresses of senders (not just their names)

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-view-show-addresses t)
    #+END_SRC

*** Ignore my company's domain alias

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-compose-complete-ignore-address-regexp
            "no-?reply")
    #+END_SRC

*** For threads, only show the subject once (like mutt)

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-headers-fields '((:human-date . 10)
                                  (:flags . 4)
                                  (:maildir . 16)
                                  (:mailing-list . 8)
                                  (:from . 22)
                                  (:thread-subject . nil)))
    #+END_SRC

*** Viewing HTML messages

    For the default shr rendering of HTML mail, bind TAB (& SHIFT+TAB)to
    finding next/previous links.

    #+BEGIN_SRC emacs-lisp
      (require 'mu4e-contrib)

      (add-hook 'mu4e-view-mode-hook
		(lambda()
                  ;; try to emulate some of the eww key-bindings
                  (local-set-key (kbd "<tab>") 'shr-next-link)
                  (local-set-key (kbd "<backtab>") 'shr-previous-link)))

    #+END_SRC

    Add ability to open any HTML messages in a browser.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'mu4e-headers-actions
                    '("in browser" . mu4e-action-view-in-browser) t)
      (add-to-list 'mu4e-view-actions
                    '("in browser" . mu4e-action-view-in-browser) t)
    #+END_SRC

    Turn off colours, as often background colours makes text illegible.

    #+BEGIN_SRC emacs-lisp
      (setq shr-use-colors nil)
    #+END_SRC

*** Bookmarks

    I used to switch bookmarks based on context, but I've come to the
    conclusion it is more hassle than it's worth. It means more
    keystrokes to switch views, for one. And it means an almighty amount
    of duplication in the contexts.

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-bookmarks
	    (list
	     (make-mu4e-bookmark
	      :name "Inbox Messages"
	      :query "maildir:/Private/INBOX OR maildir:/Work/INBOX"
	      :key ?i)
	     (make-mu4e-bookmark
	      :name "Flagged Messages"
	      :query "flag:flagged"
	      :key ?f)
	     (make-mu4e-bookmark
	      :name "Unread Messages (Private)"
	      :query "flag:unread AND maildir:/Private/* AND NOT maildir:/Private/spam"
	      :key ?u)
	     (make-mu4e-bookmark
	      :name "Unread Messages (Work)"
	      :query "flag:unread AND maildir:/Work/INBOX"
	      :key ?w)
	     (make-mu4e-bookmark
	      :name "Today's messages"
	      :query "date:today..now"
	      :key ?t)
	     (make-mu4e-bookmark
	      :name "Last 7 days"
	      :query "date:7d..now"
	      :key ?7)))
    #+END_SRC

*** Signatures

    I use different signatures for different purposes. Work signature is
    read from a file, while some mailinglists get dynamic signatures
    with relevant Emacs / Org / Mu4e version information.

    #+BEGIN_SRC emacs-lisp
      (defun get-string-from-file (filePath)
	"Return filePath's file content."
	(with-temp-buffer
          (insert-file-contents filePath)
          (buffer-string)))

      (defun my-emacs-org-sig ()
	(concat "; " (car (split-string (emacs-version) " ("))
		", " (car (split-string (org-version nil t) " ("))))

      (defun my-emacs-mu4e-sig ()
	(concat "; " (car (split-string (emacs-version) " ("))
		", Mu4e " (car (split-string mu4e-mu-version))))
    #+END_SRC

*** Maildir Shortcuts

    Allow convenient jumping or moving directly to some maildirs.

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-maildir-shortcuts '(("/Private/INBOX" . ?i)
                                     ("/Private/spam" . ?s)
                                     ("/Private/Archive" . ?a)
                                     ("/Work/INBOX" . ?I)
                                     ("/Work/spam" . ?S)
                                     ("/Work/archive" . ?A)))
    #+END_SRC

*** Dynamic folders

    Define sent, drafts, trash and refile folders based on the account
    we find the mail in.

    #+BEGIN_SRC emacs-lisp
      ;; Messages sent via GMail gets added to sent mail on the server side
      (setq mu4e-sent-folder "/Private/sent")

      ;; I don't want to sync drafts
      (setq mu4e-drafts-folder "/drafts")

      (setq mu4e-trash-folder
            (lambda (msg)
              (if (string-prefix-p "/Work/" (mu4e-msg-field msg :maildir))
                  "/Work/trash" "/Private/trash")))

      (setq mu4e-refile-folder
            (lambda (msg)
              (if (string-prefix-p "/Work/" (mu4e-msg-field msg :maildir))
                  "/Work/archive" "/Private/Archive")))
    #+END_SRC

*** Switch between multiple contexts

    Set up different contexts based on which folder / mailbox I'm in. This is
    much more obvious than Gnus' approach, IMO. I like it.

    #+BEGIN_SRC emacs-lisp
      (defun sb/maildir-match (needle)
	`(lambda (msg)
	   (when msg
	     (s-contains-p ,needle
			   (mu4e-message-field msg :maildir)))))

      (defun sb/to-match (needle)
	`(lambda (msg)
	   (when msg
	     (-some (lambda (entry)
		      (s-contains-p ,needle (cdr entry)))
		    (mu4e-message-field msg :to)))))

      (setq mu4e-contexts
	    (list
	     (make-mu4e-context
	      :name "Org"
	      :match-func (sb/to-match "emacs-orgmode")
	      :vars '((user-mail-address . "stig@brautaset.org")
		      (mu4e-compose-signature . (my-emacs-org-sig))))

	     (make-mu4e-context
	      :name "Mu"
	      :match-func (sb/to-match "mu-discuss")
	      :vars '((user-mail-address . "stig@brautaset.org")
		      (mu4e-compose-signature . (my-emacs-mu4e-sig))))

	     (make-mu4e-context
	      :name "Private"
	      :match-func (sb/maildir-match "/Private/")
	      :vars '((user-mail-address . "stig@brautaset.org")
		      (mu4e-compose-signature . nil)))

	     (make-mu4e-context
	      :name "GitHub"
	      :match-func (sb/to-match "@reply.github.com")
	      :vars '((user-mail-address . "sbrautaset@laterpay.net")
		      (mu4e-compose-signature . nil)))

	     (make-mu4e-context
	      :name "JIRA"
	      :match-func (sb/to-match "@laterpay.atlassian.net")
	      :vars '((user-mail-address . "sbrautaset@laterpay.net")
		      (mu4e-compose-signature . nil)))

	     (make-mu4e-context
	      :name "Work"
	      :match-func (sb/maildir-match "/Work/")
	      :vars '((user-mail-address . "sbrautaset@laterpay.net")
		      (mu4e-compose-signature . (get-string-from-file "~/Dropbox/Config/LaterPay.signature"))))))
    #+END_SRC

*** Context defaults

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-context-policy nil)
      (setq mu4e-compose-context-policy 'ask)
    #+END_SRC

*** A list of my addresses

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-user-mail-address-list
            '("stig@brautaset.org"
              "stig.brautaset@icloud.com"
              "sbrautaset@laterpay.net"))
    #+END_SRC

*** Tell mu4e that I don't want to email myself, normally

    #+BEGIN_SRC emacs-lisp
    (setq mu4e-compose-dont-reply-to-self t)
    #+END_SRC

*** Gmail hacks
**** Don't store sent messages

     Google automatically stores messages sent through their SMTP
     servers to sent messages, so we should not duplicate that.

     #+BEGIN_SRC emacs-lisp
       (setq mu4e-sent-messages-behavior
             (lambda ()
               (if (string= (message-sendmail-envelope-from) "sbrautaset@laterpay.net")
                   'delete 'sent)))
     #+END_SRC

**** Skip duplicate emails

     Because of the weird interaction between Gmail labels and IMAP, often
     messages show up in =archive= /and/ INBOX. This setting should help in that
     case:

     #+BEGIN_SRC emacs-lisp
     (setq mu4e-headers-skip-duplicates t)
     #+END_SRC

*** Support queueing outgoing mail

    Configure mu4e to support queueing mail for sending later, for cases when I
    don't have network connection.

    #+BEGIN_SRC emacs-lisp
	(setq smtpmail-queue-mail nil
            smtpmail-queue-dir   "~/Maildir/queue/cur")
    #+END_SRC

    This requires creating the queue directory, which you can do with =mu=. We
    also tell mu not to index the queue:

    #+BEGIN_SRC sh
    mu mkdir ~/Maildir/queue
    touch ~/Maildir/queue/.noindex
    #+END_SRC

*** Downloading email over IMAP

    I used to use OfflineIMAP for this, but mbsync (from the isync suite) seems
    faster and doesn't have this annoying db outside of the Maildir to keep in
    sync. Config looks like this:

    #+BEGIN_SRC conf :tangle ~/.mbsyncrc
      IMAPAccount icloud
      Host imap.mail.me.com
      User stig.brautaset@icloud.com
      # UseIMAPS yes
      AuthMechs LOGIN
      SSLType IMAPS
      SSLVersions TLSv1
      PassCmd "security find-generic-password -s mbsync-icloud-password -w"

      IMAPStore icloud-remote
      Account icloud

      MaildirStore icloud-local
      Path ~/Maildir/Private/
      Inbox ~/Maildir/Private/INBOX

      Channel icloud-inbox
      Master :icloud-remote:
      Slave :icloud-local:
      Create Both
      Expunge Both
      SyncState *

      Channel icloud-archive
      Master :icloud-remote:
      Slave :icloud-local:
      Patterns "Archive"
      Create Both
      Expunge Both
      SyncState *

      Channel icloud-trash
      Master :icloud-remote:"Deleted Messages"
      Slave :icloud-local:trash
      Create Both
      Expunge Both
      SyncState *

      Channel icloud-spam
      Master :icloud-remote:"Junk"
      Slave :icloud-local:spam
      Create Both
      Expunge Both
      SyncState *

      Channel icloud-sent
      Master :icloud-remote:"Sent Messages"
      Slave :icloud-local:sent
      Create Both
      Expunge Both
      SyncState *


      # ACCOUNT INFORMATION
      IMAPAccount gmail
      Host imap.gmail.com
      User sbrautaset@laterpay.net
      PassCmd "security find-generic-password -s mbsync-gmail-password -w"
      # UseIMAPS yes
      # AuthMechs LOGIN
      AuthMechs PLAIN
      SSLType IMAPS
      # SSLVersions SSLv3
      CertificateFile /usr/local/etc/openssl/cert.pem

      # THEN WE SPECIFY THE LOCAL AND REMOTE STORAGE
      # - THE REMOTE STORAGE IS WHERE WE GET THE MAIL FROM (E.G., THE
      #   SPECIFICATION OF AN IMAP ACCOUNT)
      # - THE LOCAL STORAGE IS WHERE WE STORE THE EMAIL ON OUR COMPUTER

      # REMOTE STORAGE (USE THE IMAP ACCOUNT SPECIFIED ABOVE)
      IMAPStore gmail-remote
      Account gmail

      # LOCAL STORAGE (CREATE DIRECTORIES with mkdir -p Maildir/gmail)
      MaildirStore gmail-local
      Path ~/Maildir/Work/
      Inbox ~/Maildir/Work/INBOX

      # CONNECTIONS SPECIFY LINKS BETWEEN REMOTE AND LOCAL FOLDERS
      #
      # CONNECTIONS ARE SPECIFIED USING PATTERNS, WHICH MATCH REMOTE MAIL
      # FOLDERS. SOME COMMONLY USED PATTERS INCLUDE:
      #
      # 1 "*" TO MATCH EVERYTHING
      # 2 "!DIR" TO EXCLUDE "DIR"
      # 3 "DIR" TO MATCH DIR
      #
      # FOR INSTANCE IN THE SPECIFICATION BELOW:
      #
      # gmail-inbox gets the folder INBOX, ARCHIVE, and everything under "ARCHIVE*"
      # gmail-trash gets only the "[Gmail]/Trash" folder and stores it to the local "trash" folder

      Channel gmail-inbox
      Master :gmail-remote:
      Slave :gmail-local:
      Create Both
      Expunge Both
      SyncState *

      Channel gmail-archive
      Master :gmail-remote:"Archived"
      Slave :gmail-local:archive
      Create Both
      Expunge Both
      SyncState *

      Channel gmail-trash
      Master :gmail-remote:"[Gmail]/Bin"
      Slave :gmail-local:trash
      Create Both
      Expunge Both
      SyncState *

      Channel gmail-spam
      Master :gmail-remote:"[Gmail]/Spam"
      Slave :gmail-local:spam
      Create Both
      Expunge Both
      SyncState *

      Channel gmail-sent
      Master :gmail-remote:"[Gmail]/Sent Mail"
      Slave :gmail-local:sent
      Create Both
      Expunge Both
      SyncState *

      # GROUPS PUT TOGETHER CHANNELS, SO THAT WE CAN INVOKE
      # MBSYNC ON A GROUP TO SYNC ALL CHANNELS
      #
      # FOR INSTANCE: "mbsync gmail" GETS MAIL FROM
      # "gmail-inbox", "gmail-sent", and "gmail-trash"
      #

      Group all
      Channel gmail-archive
      Channel gmail-inbox
      Channel gmail-sent
      Channel gmail-spam
      Channel gmail-trash
      Channel icloud-archive
      Channel icloud-inbox
      Channel icloud-sent
      Channel icloud-spam
      Channel icloud-trash

      Group inboxes
      Channel gmail-inbox
      Channel icloud-inbox
    #+END_SRC

*** Avoid "Duplicate UID" messages during mbsync runs

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-change-filenames-when-moving t)
    #+END_SRC

*** Make the mu4e update window smaller than default

    This seems more appropriate for mbsync, since it's much less verbose
    than offlineimap by default.

    #+BEGIN_SRC emacs-lisp
    (setq mu4e~update-buffer-height 3)
    #+END_SRC

*** Be silent about indexing messages

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-hide-index-messages t)
      (setq mu4e-update-interval nil)
    #+END_SRC

*** Cycle addresses in the From header

    Add a keybinding to cycle between from addresses in the message buffer.
    Credit to [[https://www.emacswiki.org/emacs/GnusTutorial][GnusTutorial]] which is where I found the example I adopted this
    from.

    #+BEGIN_SRC emacs-lisp
      (setq message-alternative-emails
            (regexp-opt mu4e-user-mail-address-list))

      (setq message-from-selected-index 0)
      (defun message-loop-from ()
	(interactive)
	(setq message-article-current-point (point))
	(goto-char (point-min))
	(if (eq message-from-selected-index (length mu4e-user-mail-address-list))
            (setq message-from-selected-index 0) nil)
	(while (re-search-forward "^From:.*$" nil t)
          (replace-match (concat "From: " user-full-name " <" (nth message-from-selected-index mu4e-user-mail-address-list) ">")))
	(goto-char message-article-current-point)
	(setq message-from-selected-index (+ message-from-selected-index 1)))

      (add-hook 'message-mode-hook
		(lambda ()
                  (define-key message-mode-map "\C-c\C-f\C-f" 'message-loop-from)))
    #+END_SRC

*** Compose Emails with Org mode

    I want to be able to create links to messages from Org mode capture
    templates, as email Inbox is a terrible TODO list.

    #+BEGIN_SRC emacs-lisp
      (use-package org-mu4e)
    #+END_SRC

    I define =C-c x= as a short-cut to switch to Org mode, and back, to message
    mode, so that I can use full Org mode to edit messages if I want.

    #+BEGIN_SRC emacs-lisp
      (use-package mu4e :bind (:map mu4e-compose-mode-map
                                    ("C-c x" . org-mode)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package org-mime
	:ensure t
	:bind (:map message-mode-map
                    ("C-c h" . org-mime-htmlize))
	:init
	(setq org-mime-preserve-breaks nil))
    #+END_SRC

*** Sending mail with MSMTP

    MSMTP's configuration is really simple, and it will detect the account to
    use from the "from" address. Let's go!

    MSMTP obtains passwords from the system Keychain. See the [[http://msmtp.sourceforge.net/doc/msmtp.html#Authentication][Authentication]]
    section in the msmtp documentation for details.

    #+BEGIN_SRC conf :tangle ~/.msmtprc
      defaults

      port 587
      tls on
      tls_trust_file /usr/local/etc/openssl/cert.pem
      auth on

      ###############
      account private

      from stig@brautaset.org
      host mail.gandi.net
      user mailbox@brautaset.org

      #############
      account icloud

      from stig.brautaset@icloud.com
      host smtp.mail.me.com
      user stig.brautaset@icloud.com

      ############
      account work

      from sbrautaset@laterpay.net
      host smtp.gmail.com
      user sbrautaset@laterpay.net

      #########################
      account default : private
    #+END_SRC

    Finally we have to tell Emacs to use msmtp to send mail:

    #+BEGIN_SRC emacs-lisp
      (setq message-send-mail-function 'message-send-mail-with-sendmail
            sendmail-program "/usr/local/bin/msmtp")
    #+END_SRC

*** Don't keep buffer for sent messages

    #+BEGIN_SRC emacs-lisp
    (setq message-kill-buffer-on-exit t)
    #+END_SRC

*** Lookup by lists

    #+BEGIN_SRC emacs-lisp
      (defun my4e~query-lists-command ()
	(concat
	 "mu find --fields v 'list:.* AND date:1m.. AND flag:new' | sort -u"))

      (defun my4e~headers-ask-for-list ()
	(let* ((output (shell-command-to-string
			(my4e~query-lists-command)))
               (lists (split-string output "\n")))
          (ivy-completing-read "[mu4e] Jump to list: " lists)))

      (defun my4e-headers-jump-to-list (listid)
	(interactive
	 (let ((listid (my4e~headers-ask-for-list)))
           (list listid)))
	(when listid
          (mu4e-mark-handle-when-leaving)
          (mu4e-headers-search (format "flag:new list:\"%s\"" listid))))

      (define-key mu4e-headers-mode-map (kbd "l") 'my4e-headers-jump-to-list)
    #+END_SRC

*** Make editing with mu4e's format=flowed mode nicer

    I don't like how it forces you to use long lines, rather than use
    soft newlines, but setting a wide fringe and visual line mode makes
    it bearable.

    #+BEGIN_SRC emacs-lisp
      (setq mu4e-compose-format-flowed t)
    #+END_SRC

*** On-the-fly spell checking for email messages

    Do spell checking on-the-fly in message mode.

    #+BEGIN_SRC emacs-lisp
      (use-package flyspell-lazy
	:ensure t
	:config
	(defun my-message-setup-routine ()
          (flyspell-mode 1))
	(add-hook 'mu4e-compose-mode-hook 'my-message-setup-routine))
    #+END_SRC
*** Get New Mail                                               :EXPERIMENTAL:

    #+begin_src emacs-lisp
    (setq mu4e-get-mail-command "mbsync -a")
    #+end_src
** Flymake

   #+BEGIN_SRC emacs-lisp
     (use-package flymake
       :bind (:map flymake-mode-map
	      ("M-n" . flymake-goto-next-error)
	      ("M-p" . flymake-goto-prev-error)))
   #+END_SRC
** International Support

    I'm Norwegian, but use a GB keyboard. I also use Dvorak keyboard
    layout. I also have Polish colleagues whose names I don't want to
    mangle completely. Keep this in mind if you find the below
    confusing.

*** Always use UTF-8 encoding

    Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

    #+BEGIN_SRC emacs-lisp
      (setq locale-coding-system 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
    #+END_SRC

*** Conveniently type Norwegian characters

    Let's define keybindings for the three additional Norwegian
    characters characters that I don't have natively on my British
    keyboard.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "s-'") (kbd "æ"))
      (global-set-key (kbd "s-\"") (kbd "Æ"))
      (global-set-key (kbd "s-O") (kbd "Ø"))
      (global-set-key (kbd "s-o") (kbd "ø"))
      (global-set-key (kbd "s-A") (kbd "Å"))
      (global-set-key (kbd "s-a") (kbd "å"))
      #+END_SRC

*** Use Aspell with UK English Dictionary

    Configure Emacs to use the Queen's English for spell checking. Also,
    use /aspell/ rather than /ispell/.

    #+BEGIN_SRC emacs-lisp
      (setq ispell-program-name "aspell"
            ispell-dictionary "british")
    #+END_SRC

    Install aspell with the appropriate dictionary using brew.

    #+BEGIN_SRC sh
      brew install aspell
    #+END_SRC

*** (Some) Polish Characters Support

    I have Polish colleagues whose names I don't want to mangle.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-x 8 ' l") (kbd "ł"))
    #+END_SRC
** Lilypond

  #+BEGIN_SRC emacs-lisp
    (use-package lilypond-mode
      :load-path "/Applications/LilyPond.app/Contents/Resources/share/emacs/site-lisp/"
      :mode (("\\.ly\\'" . LilyPond-mode)
	     ("\\.ily\\'" . LilyPond-mode))
      :init
      (autoload 'LilyPond-mode "lilypond-mode" "LilyPond Editing Mode" t)
      (add-hook 'LilyPond-mode-hook (lambda () (turn-on-font-lock))))
  #+END_SRC

** Magit & GitHub
*** Magit

    I use [[http://magit.vc][Magit]] all day. If you use git a lot it's possibly worth switching to
    Emacs just for it. It is excellent. I bind =H-m= to =magit-status=, which is
    the main entry point for the mode.

    #+BEGIN_SRC emacs-lisp
      (use-package magit
	:ensure t
	:bind (("M-m" . magit-status)
	       ("s-b" . magit-blame)))
    #+END_SRC

*** GitHub

    There's a new GitHub integration tool... Let's try that instead of
    magit-gh-pulls for a bit.

    #+BEGIN_SRC emacs-lisp
      (use-package magithub
	:ensure t
	:after magit
	:init
	(setq magithub-clone-default-directory "~/work")
	:config
	(magithub-feature-autoinject t))
    #+END_SRC

    Link to file location on github.

    #+BEGIN_SRC emacs-lisp
      (use-package git-link
	:ensure t
	:bind ("C-c g l" . git-link))
    #+END_SRC

*** Gists

    Viewing & editing gists in Emacs? Sure! I want that!

    #+BEGIN_SRC emacs-lisp
      (use-package gist
	:ensure t
	:bind (("C-x g l" . gist-list)
               ("C-x g c" . gist-region-or-buffer-private))
	:init

	;; The defaults for these are too small for gists
	(setq max-specpdl-size 3000)
	(setq max-lisp-eval-depth 2000)

	(setq gist-ask-for-description t))
    #+END_SRC

*** Resolving Conflicts

    Sometimes I have to resolve conflicts. I then use Ediff, which I
    launch from Magit. Occasionally I want to pick *both* sides of the
    conflicts. (If both branches add an entry to a list, for example;
    which can often happen in hieradata / puppet.) This adds =d= as a
    shortcut to do that. ([[http://stackoverflow.com/a/29757750/5950][Credits]].) You can use =~= to swap the A and B
    buffers, so in effect you can get A then B, /or/ B then A.

    #+BEGIN_SRC emacs-lisp
      (defun ediff-copy-both-to-C ()
	(interactive)
	(ediff-copy-diff ediff-current-difference nil 'C nil
			 (concat
                          (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                          (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
      (defun add-d-to-ediff-mode-map () (define-key ediff-mode-map "d" 'ediff-copy-both-to-C))
      (add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map)
    #+END_SRC

*** Auto commit

    In some projects (notably, my Org/Agenda setup) I want to
    automatically commit when editing files.

    #+BEGIN_SRC emacs-lisp
      (use-package git-auto-commit-mode
	:ensure t
	:init
	(setq gac-shell-and "; and "))
    #+END_SRC

** Miscellaneous
   Now on to the actual configuration of packages & Emacs behaviour.

*** Auto-complete

    #+BEGIN_SRC emacs-lisp
    (use-package company
      :ensure t
      :init
      ;; https://emacs.stackexchange.com/a/10838
      (setq company-dabbrev-downcase nil)
      :config
      (global-company-mode))
    #+END_SRC

*** I like big fonts and I cannot lie

 #+BEGIN_SRC emacs-lisp
 (set-face-attribute 'default nil :height 150)
 #+END_SRC
*** Add =/usr/local/bin= to our path

    The GUI Emacs gets exec path from the system, rather than the login shell.
    This requires us to add "/usr/local/bin" to exec-path lest it can't find
    any programs installed by =brew=.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'exec-path "/usr/local/bin")

      ;; This is for Eshell
      (require 's)
      (setenv "PATH" (s-join ":" (-butlast exec-path)))

      ;; Avoid "WARNING: terminal is not fully functional" prompt every time
      ;; I invoke `aws $subcommand help`.
      (setenv "PAGER" "cat")
    #+END_SRC

*** Don't hide Emacs when  ⌘-h is pressed

    In Emacs Mac Port, ⌘-h bypasses any Emacs keybindings and instead sends a
    "pass command to system" message to Mac OSX, which then hides the entire
    application. [[https://github.com/railwaycat/homebrew-emacsmacport/issues/55][I don't want that]].

    #+BEGIN_SRC emacs-lisp
      (setq mac-pass-command-to-system nil)
    #+END_SRC

*** Disable mouse interface, splash screen & beeps

    I don't tend to use a mouse in Emacs very often, so I turn off mouse
    interface early to avoid momentary display during launch.

    #+BEGIN_SRC emacs-lisp
      (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
      (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    #+END_SRC

    I also don't need to see a splash screen on every launch.

    #+BEGIN_SRC emacs-lisp
      (setq inhibit-startup-message t)
    #+END_SRC

    I do not like Emacs to beep at me; I prefer a visual bell.

    #+BEGIN_SRC emacs-lisp
      (setq visible-bell t)
    #+END_SRC

*** Make mouse scrolling smoother

    The adaptive mouse scrolling is far, far too quick so let's turn that off.

    #+BEGIN_SRC emacs-lisp
    (setq mouse-wheel-progressive-speed nil)
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))))
    #+END_SRC

*** Support for fullscreen

    I like to run apps in fullscreen mode. Unfortunately emerge, when running
    an Emacs version without Yamamoto's Mac patch set, doesn't really work in
    fullscreen---it ends up putting the small emerge control frame on a
    different screen. Because I like Emacs 25 (for up-to-date Gnus) I work
    around this problem by exiting fullscreen and just maximising the frame
    instead.

    Toggling frame maximation is already available as =M-<f10>=, so all we need
    to do is add a key binding to toggle fullscreen. I found this function at
    the [[https://www.emacswiki.org/emacs/FullScreen#toc26][EmacsWiki Fullscreen page]], and it does just that.

    #+BEGIN_SRC emacs-lisp
      (defun my-toggle-fullscreen ()
	"Toggle full screen"
	(interactive)
	(set-frame-parameter
         nil 'fullscreen
         (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

      (global-set-key (kbd "M-<f11>") 'my-toggle-fullscreen)
    #+END_SRC

    Sometimes (when using ediff) I don't use fullscreen. By resizing the window
    by pixels rather than characters we can still fill the entire screen.

    #+BEGIN_SRC emacs-lisp
      (setq frame-resize-pixelwise t)
    #+END_SRC

*** Disable kill-emacs

    Disable =s-q= (=kill-emacs=) as it is too close to =M-q= which I use for
    reflowing text.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "s-q") nil)
    #+END_SRC

*** Put Custom settings in a separate file

    I prefer to code my configuration, but sometimes Custom settings are good
    enough. I prefer that such settings live in a separate file though. Load
    that file if it exists.

    #+BEGIN_SRC emacs-lisp
      (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
      (if (file-exists-p custom-file)
          (load custom-file))
    #+END_SRC

*** Start the Emacs Daemon

    We want Emacs to be running its server so we can interact with it using =emacsclient=.

   #+BEGIN_SRC emacs-lisp
     (require 'server)
     (unless (server-running-p)
       (server-start))
   #+END_SRC

*** End all files in a newline

    All files should end in a newline. Insert one if there isn't one already.

    #+BEGIN_SRC emacs-lisp
      (setq require-final-newline t)
    #+END_SRC

*** Highlight & deal with whitespace annoyances

    This highlights certain whitespace annoyances, and adds a key binding to
    clean it up.

    #+BEGIN_SRC emacs-lisp
      (require 'whitespace)
      (setq whitespace-style '(face empty tabs trailing))
      (global-whitespace-mode t)

      (global-set-key (kbd "s-w") 'whitespace-cleanup)
    #+END_SRC

*** Set up modifier keys on OS X

    Set up the modifier keys the way that best fits my keyboard.

    #+BEGIN_SRC emacs-lisp
      (setq mac-command-modifier 'meta
            mac-option-modifier 'super
            mac-control-modifier 'control
            ns-function-modifier 'hyper)
    #+END_SRC

*** Auto revert mode

    When files change on disk, revert the buffer automatically.

    #+BEGIN_SRC emacs-lisp
      (global-auto-revert-mode 1)
    #+END_SRC

*** Don't store backup files next to originals

    I don't like backup files (those dreaded =foo~= ones) all over my disk.
    This places them in =~/.emacs.d/backups=.

    #+BEGIN_SRC emacs-lisp
      (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
    #+END_SRC

*** Transparently open compressed files

    I *do* like it when Emacs transparently opens compressed files. It gives
    me the warm fuzzies.

    #+BEGIN_SRC emacs-lisp
      (auto-compression-mode t)
    #+END_SRC

*** Make 'y' and 'n' satisfy prompts

    Answering just 'y' or 'n' will do, rather than having to spell out "yes"
    or "no".

    #+BEGIN_SRC emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

*** Toggle Window Split function

    Sometimes a window is split horizontally, and you would prefer
    vertically. Or vice versa. This function can help! Just don't ask me how
    it works: I found it on StackOverflow. (I think. Again.)

    #+BEGIN_SRC emacs-lisp
      (defun toggle-window-split ()
	(interactive)
	(if (= (count-windows) 2)
            (let* ((this-win-buffer (window-buffer))
                   (next-win-buffer (window-buffer (next-window)))
                   (this-win-edges (window-edges (selected-window)))
                   (next-win-edges (window-edges (next-window)))
                   (this-win-2nd (not (and (<= (car this-win-edges)
                                               (car next-win-edges))
                                           (<= (cadr this-win-edges)
                                               (cadr next-win-edges)))))
                   (splitter
                    (if (= (car this-win-edges)
                           (car (window-edges (next-window))))
			'split-window-horizontally
                      'split-window-vertically)))
              (delete-other-windows)
              (let ((first-win (selected-window)))
		(funcall splitter)
		(if this-win-2nd (other-window 1))
		(set-window-buffer (selected-window) this-win-buffer)
		(set-window-buffer (next-window) next-win-buffer)
		(select-window first-win)
		(if this-win-2nd (other-window 1))))))

      (define-key ctl-x-4-map "t" 'toggle-window-split)
    #+END_SRC

*** Delete the file for the current buffer function

    "Delete this file." Simple, huh?

    #+BEGIN_SRC emacs-lisp
      (defun delete-current-buffer-file ()
	"Removes file connected to current buffer and kills buffer."
	(interactive)
	(let ((filename (buffer-file-name))
              (buffer (current-buffer))
              (name (buffer-name)))
          (if (not (and filename (file-exists-p filename)))
              (ido-kill-buffer)
            (when (yes-or-no-p "Are you sure you want to remove this file? ")
              (delete-file filename)
              (kill-buffer buffer)
              (message "File '%s' successfully removed" filename)))))

      (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
    #+END_SRC

*** Eshell

    I have started using /Eshell/. It is close to magic. There's not a lot of
    setup (it has its own [[file:eshell/alias][alias file]]), but I've got a keybinding to bring up
    eshell quickly. This launches eshell if it is not already running, or
    switches to it if it is.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-c s") 'eshell)
    #+END_SRC

    Eshell is great, and its Tramp integration allows me to open remote files
    in local Emacs seamlessly with the =find-file= command. (Which I have
    aliased to =ff=.) Eshell also makes sure that my shell behaves the same,
    and has the same config, whether I am on a local machine or a remote one.

*** Tramp

    Allow using sudo over ssh, so we can sudo to root remotely on a machine
    that does not allow root login.

    #+BEGIN_SRC emacs-lisp
      (set-default 'tramp-default-proxies-alist
                   (quote ((".*" "\\`root\\'" "/ssh:%h:"))))
    #+END_SRC

    For opening files using sudo locally, don't connect via SSH. (My local
    machine doesn't accept SSH connections.)

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'tramp-default-proxies-alist
                   '((regexp-quote (system-name)) nil nil))
    #+END_SRC

    If I don't set this then tramp will attempt to use OS X's tempfile
    directory on a remote machine, which does not work. I don't understand
    why it won't use the remote machine's temp directory automatically, but
    there you go.

    #+BEGIN_SRC emacs-lisp
      (setq temporary-file-directory "/tmp/")
    #+END_SRC

    Apparently using =ssh= is faster than the default =scp= mode, so let's use
    that.

    #+BEGIN_SRC emacs-lisp
    (setq tramp-default-method "ssh")
    #+END_SRC

    This function lets me re-open the currently open file using sudo[fn:1].
    I've bound it to =C-c C-s=. It works for both local and remote buffers.

    #+BEGIN_SRC emacs-lisp
      (defun sudo-edit-current-file ()
	(interactive)
	(let ((position (point)))
          (find-alternate-file
           (if (file-remote-p (buffer-file-name))
               (let ((vec (tramp-dissect-file-name (buffer-file-name))))
                 (tramp-make-tramp-file-name
                  "sudo"
                  (tramp-file-name-user vec)
                  (tramp-file-name-host vec)
                  (tramp-file-name-localname vec)))
             (concat "/sudo:root@localhost:" (buffer-file-name))))
          (goto-char position)))
    #+END_SRC

    The man pages on my OS X local machine are very oqften different from the
    remote machines I'm logged in to. Thus, when in eshell, in a /remote/ path,
    I would like to display /remote/ man pages from that system. I'm not sure
    the regular man command can do that, but /woman/ can, with a bit of help.

    I've not /completely/ nailed this, so the useability is a bit rough. But
    with the below command in eshell you can do:

    #+BEGIN_EXAMPLE
    alias man 'tramp-aware-woman ${*man -c --path $1}'
    #+END_EXAMPLE

    Now you have an alias which will open a woman buffer with the /remote/ man
    page of the man page you want.

    #+BEGIN_SRC emacs-lisp
      (defun tramp-aware-woman (man-page-path)
	(interactive)
	(let ((dir (eshell/pwd)))
          (woman-find-file
           (if (file-remote-p dir)
               (let ((vec (tramp-dissect-file-name dir)))
                 (tramp-make-tramp-file-name
                  (tramp-file-name-method vec)
                  (tramp-file-name-user vec)
                  (tramp-file-name-host vec)
                  man-page-path))
             man-page-path))))
    #+END_SRC

*** Set up Clipboard

    These settings improve pasting behaviour with programs outside Emacs.

    Save clipboard strings into the kill ring before replacing them. This is
    useful if you select something in Emacs, then select something from
    _another_ program. If you don't set this to non-nil the previous selection
    done from within Emacs is gone. This preserves it in the kill ring,
    enabling you to retrieve it.

    #+BEGIN_SRC emacs-lisp
      (setq save-interprogram-paste-before-kill t)
    #+END_SRC

    Copying ("yanking") with the mouse copies at point, rather than where you
    click.

    #+BEGIN_SRC emacs-lisp
      (setq mouse-yank-at-point t)
    #+END_SRC

*** Show more "recent files" in =M-x b= window

    Keep up to 100 recent files, rather than the default of 20.

    #+BEGIN_SRC emacs-lisp
     (setq recentf-max-saved-items 100)
    #+END_SRC

*** Save my place in each file

    It's nice if Emacs knows where I was last time I opened a file.

    #+BEGIN_SRC emacs-lisp
      (setq-default save-place t)
      (setq save-place-file (concat user-emacs-directory "places"))
    #+END_SRC

*** Save minibuffer history

    This allows us to "tap up" in the minibuffer to recall previous items,
    even from a previous session.

    #+BEGIN_SRC emacs-lisp
      (savehist-mode 1)
    #+END_SRC

*** Show Matching parens

    This is extremely useful. Put the mark on a paren (any of =()[]{}=,
    actually) and Emacs shows the matching closing/opening one.

    #+BEGIN_SRC emacs-lisp
      (show-paren-mode 1)
    #+END_SRC

*** Add keybinding to join next line to this

    With cursor at any point in a line, hit =M-j= to move to the end, and
    delete the newline. The cursor is left where the newline used to be.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "M-j")
                      (lambda ()
			(interactive)
			(join-line -1)))
    #+END_SRC

*** Buffer-local regex search

    I like the =C-s= and =C-r= keybindings to mean "search forward/backward
    for this regex".

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-s") 'isearch-forward-regexp)
      (global-set-key (kbd "C-r") 'isearch-backward-regexp)
    #+END_SRC

*** Running tests

    Add a convenient keybinding for running tests interactively.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-x t") 'ert)
    #+END_SRC

*** IRC

    But /of course/ Emacs has a built-in IRC client. In fact it has two! But I
    digress. Let's use the oldest one, and configure it slightly.

    #+BEGIN_SRC emacs-lisp
    (setq rcirc-default-nick "stigbra")
    (setq rcirc-default-full-name "Stig Brautaset")
    #+END_SRC

*** SmartParens

    I use smartparens rather that paredit. I cannot remember why; probably
    something to do with it being better supported for Cider/Clojure? Anyway,
    here's my SmartParens config. It is  mostly cribbed from the author, with
    small changes to make suitable for plugging into =use-package=.

    One notable thing: I remove "'" from being a pair, because that character
    is used for quoting in lisps, and for apostrophe in text modes. Having two
    inserted every time you hit the key is very annoying.

    #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :ensure t

      :config
      (smartparens-global-mode t)
      (show-smartparens-global-mode t)
      (sp-pair "'" nil :actions :rem)

      ;; Add smartparens-strict-mode to all sp--lisp-modes hooks. C-h v sp--lisp-modes
      ;; to customize/view this list.
      (mapc (lambda (mode)
              (add-hook (intern (format "%s-hook" (symbol-name mode))) 'smartparens-strict-mode))
            sp--lisp-modes)

      ;; Conveniently set keys into the sp-keymap, limiting the keybinding to buffers
      ;; with SP mode activated
      (mapc (lambda (info)
              (let ((key (kbd (car info)))
                    (function (car (cdr info))))
		(define-key sp-keymap key function)))
            '(("C-M-f" sp-forward-sexp)
              ("C-M-b" sp-backward-sexp)

              ("C-M-d" sp-down-sexp)
              ("C-M-a" sp-backward-down-sexp)
              ("C-S-a" sp-beginning-of-sexp)
              ("C-S-d" sp-end-of-sexp)

              ("C-M-e" sp-up-sexp)

              ("C-M-u" sp-backward-up-sexp)
              ("C-M-t" sp-transpose-sexp)

              ("C-M-n" sp-next-sexp)
              ("C-M-p" sp-previous-sexp)

              ("C-M-k" sp-kill-sexp)
              ("C-M-w" sp-copy-sexp)

              ("C-M-<delete>" sp-unwrap-sexp)
              ("C-M-<backspace>" sp-backward-unwrap-sexp)

              ("C-<right>" sp-forward-slurp-sexp)
              ("C-<left>" sp-forward-barf-sexp)
              ("C-M-<left>" sp-backward-slurp-sexp)
              ("C-M-<right>" sp-backward-barf-sexp)

              ("M-D" sp-splice-sexp)
              ("C-M-<delete>" sp-splice-sexp-killing-forward)
              ("C-M-<backspace>" sp-splice-sexp-killing-backward)
              ("C-S-<backspace>" sp-splice-sexp-killing-around)

              ("C-]" sp-select-next-thing-exchange)
              ("C-<left_bracket>" sp-select-previous-thing)
              ("C-M-]" sp-select-next-thing)

              ("M-F" sp-forward-symbol)
              ("M-B" sp-backward-symbol)

              ("H-t" sp-prefix-tag-object)
              ("H-p" sp-prefix-pair-object)
              ("H-s c" sp-convolute-sexp)
              ("H-s a" sp-absorb-sexp)
              ("H-s e" sp-emit-sexp)
              ("H-s p" sp-add-to-previous-sexp)
              ("H-s n" sp-add-to-next-sexp)
              ("H-s j" sp-join-sexp)
              ("H-s s" sp-split-sexp)))

      ;; In Lisp modes, let ')' go to end of sexp
      (bind-key ")" 'sp-up-sexp emacs-lisp-mode-map)
      (bind-key ")" 'sp-up-sexp lisp-mode-map))
    #+END_SRC

*** CSS

    #+BEGIN_SRC emacs-lisp
    (use-package flymake-css
      :ensure t
      :config
      (add-hook 'css-mode-hook 'flymake-css-load))
    #+END_SRC
*** Aggressive Indent

    I like to keep my code indented properly at all times. Aggressive-indent
    helps ensure this. Turn it on for lisp modes.

    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
	:ensure t

	:config
	(add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
	(add-hook 'clojure-mode-hook #'aggressive-indent-mode)
	(add-hook 'css-mode-hook #'aggressive-indent-mode))
    #+END_SRC

*** Editorconfig

    Some projects I touch, particularly at work, use [[http://editorconfig.org][editorconfig]] to set up
    their indentation and file format preferences.

    #+BEGIN_SRC emacs-lisp
      (use-package editorconfig
	:ensure t
	:init
	(setq editorconfig-exclude-modes '(org-mode))
	(setq editorconfig-mode-lighter " EC")
	:config
	(editorconfig-mode))
    #+END_SRC

    Emacs requires an external tool for this to work. I install that using
    brew.

    #+BEGIN_SRC sh
      brew install editorconfig
    #+END_SRC

*** Ag / The Silver Searcher

    I use =ag= for searching quite a lot in Emacs.
    This requires an additional external tool for best performance:

    #+BEGIN_SRC sh
      brew install the_silver_searcher
    #+END_SRC

    Then make sure the Emacs ag package is installed.

    #+BEGIN_SRC emacs-lisp
      (use-package ag :ensure t)
    #+END_SRC

    "Writable grep" mode for ag is pretty close to magic. When in a buffer
    showing ag results, try hitting =C-c C-p=--this lets you _edit the results
    of the search, right from the ag results buffer!_ Just hit =C-x C-s= to
    save the results.

    If you hit =C-c C-p= while already in writable grep mode you can delete the
    entire matched line from the file where it was found by hitting =C-c C-d=
    on it. I use this _a lot_ when cleaning up Hieradata.

    Recently ag broke wgrep-ag by starting to group its output. The grouping is
    quite nice, but I prefer working wgrep so I turn the grouping off.

    #+BEGIN_SRC emacs-lisp
      (use-package wgrep-ag
	:ensure t
	:init
	(setq ag-group-matches t))
    #+END_SRC

*** Projectile

    I use Projectile to navigate my projects. Some of the things I like about
    it are that it provides the following key bindings:

    - =C-c p t= :: This switches from an implementation file to its test file,
                   or vice versa. I use this extensively in Clojure mode. It
                   might not make sense for all languages; YMMV.
    - =C-c p 4 t= :: The same, as above, but open the file in "other" buffer.
    - =C-c p s s= :: Ag search for something in this project. If point is at a
                     token, default to searching for that. (Mnemonic:
                     "Projectile Silver Searcher".)

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
	:ensure t
	:init
	(setq projectile-mode-line
	      '(:eval (format " Proj[%s]"
			      (projectile-project-name))))
	:config
	(projectile-mode))
    #+END_SRC

*** Helm Projectile

    This next package adds =C-c p h=, which invokes =helm-find-file= in project
    context. Invaluable.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-projectile
	:ensure t
	:config
	(helm-projectile-on))
    #+END_SRC

*** Multiple Cursors

    This package is another one of those near-magical ones. It allows me to do
    multiple edits in the same buffer, using several cursors. You can think of
    it as an interactive macro, where you can constantly see what's being done.

    #+BEGIN_SRC emacs-lisp
      (use-package multiple-cursors
	:ensure t

	:bind (("C-c M-e" . mc/edit-lines)
               ("C-c M-a" . mc/mark-all-dwim)
               ("s-n" . mc/mark-next-like-this)
               ("s-p" . mc/mark-previous-like-this)))
    #+END_SRC

*** AppleScript support

    #+BEGIN_SRC emacs-lisp
      (use-package apples-mode
	:ensure t)
    #+END_SRC

*** Sphinx & reStructuredText

    I like to build Sphinx docs locally to check I've got the right syntax, and
    that links are accounted for. I use sphinx-fronted for that:

    #+BEGIN_SRC emacs-lisp
    (use-package sphinx-frontend
      :ensure t)
    #+END_SRC

    That does require installing python, as OS X's default install doesn't come
    with pip:

    #+BEGIN_SRC sh
      brew install python
    #+END_SRC

    Then, we need to install sphinx itself:

    #+BEGIN_SRC sh
      pip install sphinx
    #+END_SRC

    While we're at it, turn on auto-complete for reStructuredText.

    #+BEGIN_SRC emacs-lisp
      (use-package auto-complete-rst
	:ensure t
	:mode "\\.rst\'"
	:config
	(auto-complete-rst-init)
	(setq auto-complete-rst-other-sources
              '(ac-source-filename
		ac-source-abbrev
		ac-source-dictionary
		ac-source-yasnippet)))
    #+END_SRC

*** Graphviz

    I sometimes use Graphviz to create diagrams. I have to actually install the
    graphviz program separately using brew.

    #+BEGIN_SRC sh
    brew cask install graphviz
    #+END_SRC

    I also have to tell Emacs how to launch GraphViz.

    #+BEGIN_SRC emacs-lisp
      (use-package graphviz-dot-mode
	:ensure t
	:init
	(setq default-tab-width 8)
	(setq graphviz-dot-view-command "open -a Graphviz %s"))
    #+END_SRC

*** Fish

    Add a mode for editing [[http://fishshell.com][FISH]] shell files.

    #+BEGIN_SRC emacs-lisp
      (use-package fish-mode
	:ensure t)
    #+END_SRC

*** Trash

    This allows moving files to trash rather than deleting them from =dired=.
    Delete files by moving them to Trash. This way they _can_ be retrieved
    again.

    #+BEGIN_SRC emacs-lisp
      (use-package osx-trash
	:ensure t
	:init
	(setq delete-by-moving-to-trash t)
	:config
	(osx-trash-setup))
    #+END_SRC

    To support that we need to install a supporting program.

    #+BEGIN_SRC sh
     brew install trash
    #+END_SRC

*** Plant UML Mode

    I use this for [[http://plantuml.com/sequence.html][sequence diagrams]] etc.

    #+BEGIN_SRC emacs-lisp
      (use-package plantuml-mode
	:ensure t
	:mode "\\.puml\\'"
	:init
	(setq puml-plantuml-jar-path
	      (-last-item (directory-files "/usr/local/opt/plantuml/libexec" t))))
    #+END_SRC

    This requires installing plantuml using brew.

    #+BEGIN_SRC sh
      brew install plantuml
    #+END_SRC

*** YAS

    YAS is a templating package. You can define mode-specific or global
    templates, and insert templates with keycombinations or triggered based on
    trigger words in the text.

    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
	:ensure t
	:config
	(yas-global-mode))
    #+END_SRC

*** Visual line mode / word wrapping

    #+BEGIN_SRC emacs-lisp
    (add-hook 'text-mode-hook 'visual-line-mode)
    #+END_SRC

*** Markdown

    I'm a sucker for lists, and I want to be able to reorder list items
    easily and have them renumbered automatically.

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
	:ensure t
	:bind (("M-<up>" . markdown-move-list-item-up)
	       ("M-<down>" . markdown-move-list-item-down)))
    #+END_SRC
*** Box quotes are so cute!

    Install boxquote to make fancy text boxes like this:

    #+BEGIN_EXAMPLE
      ,----
      | This is a box quote!
      `----
    #+END_EXAMPLE

    You can even set a title!

    #+BEGIN_EXAMPLE
      ,----[ with a title! ]
      | This is another box quote
      `----
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (use-package boxquote :ensure t)
    #+END_SRC

** Org mode

   I now use Org mode for all writing I initiate. The Emacs org mode's support
   for tables, TOC, footnotes, TODO and agenda items makes it an easy choice.
   Gists and GitHub READMEs support Org mode too, and I can export to other
   formats including if I want.

   To avoid having one gigantic section, this file uses NOWEB syntax to weave
   together config snippets.

   The particular version of package I use is annoying to install because the
   installed package has a different name from what you would use in your
   config. However, =use-package= supports this by passing the name of the
   package to install as the value to =:ensure=.

   #+BEGIN_SRC emacs-lisp :noweb yes
     (use-package org
       :ensure org-plus-contrib
 ;;      :load-path (lambda () (expand-file-name "~/play/org-mode/lisp"))

       <<key-bindings>>

       :init
       <<capturing>>
       <<refiling>>

       ;; I don't rely on many properties, so this should speed up my Agenda
       ;; view, according to http://orgmode.org/worg/agenda-optimization.html
       (setq org-agenda-ignore-properties '(effort appt stats))

       ;; When hitting C-c C-z to take a note, always put it in the LOGBOOK drawer
       (setq org-log-into-drawer t)

       ;; Sometimes I accidentally edit non-visible parts of org document. This
       ;; helps, apparently.
       (setq org-catch-invisible-edits 'show-and-error)

       ;; If running interactively, I want export to copy to the kill-ring
       (setq org-export-copy-to-kill-ring 'if-interactive)

       (setq org-hide-emphasis-markers t)

       (setq org-element-use-cache nil)

       (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

       <<org-babel-init>>

       <<org-agenda-init>>
       :config

       <<org-habit-config>>

       <<org-babel-config>>)
   #+END_SRC

   Ditaa requires a package installed by brew.

   #+BEGIN_SRC sh
     brew install ditaa
   #+END_SRC

*** Key bindings

    The Org manual expects the top four of these to be available in any mode, so
    define them globally. I prefer to follow conventions. It makes reading the
    manual and tutorials a lot easier!

    #+name: key-bindings
    #+BEGIN_SRC emacs-lisp :tangle no
      :bind (("C-c l" . org-store-link)
             ("C-c a" . org-agenda)
             ("C-c c" . org-capture)
             ("C-c b" . org-iswitchb)
	     ("C-s-<return>" . org-insert-subheading)
	     ("C-s-S-<return>" . org-insert-todo-subheading)
             :map org-mode-map
             ("C-c x" . mu4e-compose-mode)
             ("C-n" . org-next-link)
             ("C-p" . org-previous-link))
    #+END_SRC

*** Agenda

    #+name: org-agenda-init
    #+BEGIN_SRC emacs-lisp :tangle no
      ;; I don't want to show these in the TODO list,
      ;; because they'll show in the Agenda anyway.
      (setq org-agenda-todo-ignore-scheduled 'future
	    org-agenda-todo-ignore-deadlines 'far
	    org-agenda-todo-ignore-timestamp 'future)

      (setq org-agenda-skip-deadline-prewarning-if-scheduled t
	    org-agenda-skip-scheduled-if-deadline-is-shown 'not-today)

      ;; Make tags-todo search ignore scheduled items too
      (setq org-agenda-tags-todo-honor-ignore-options t)

      (setq org-log-done 'time)

      (setq org-stuck-projects '("/PROJ" ("TODO" "NEXT" "WAITING") nil ""))

      (setq org-agenda-custom-commands
	    '(("p" "Current Projects" tags "/PROJ")
	      ("S" "Someday" tags-todo "/SOMEDAY")
	      ("w" todo "WAITING")))
    #+END_SRC

*** Refiling

    I got all of this from [[https://www.youtube.com/watch?v=ECWtf6mAi9k][this YouTube video]].

    #+name: refiling
    #+BEGIN_SRC emacs-lisp :tangle no
      (setq org-refile-targets '((org-agenda-files :maxlevel . 3)
				 (org-agenda-files :tag . "PROJECT")))

      ;; Allow refiling to sub-paths
      (setq org-refile-use-outline-path 'file)

      (setq org-refile-allow-creating-parent-nodes 'confirm)
    #+END_SRC

*** Capturing

    Set up capture templates. This is mainly from [[http://koenig-haunstetten.de/2014/08/29/the-power-of-orgmode-capture-templates/][Rainer's blog post]]. No doubt
    this will grow...

    #+name: capturing
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun capture-blog-post-file ()
	(let* ((title (read-string "Slug: "))
	       (slug (replace-regexp-in-string "[^a-z0-9]+" "-" (downcase title))))
	  (expand-file-name
	   (format "~/blog/articles/%s/%s.org"
		   (format-time-string "%Y" (current-time))
		   slug))))

      (setq org-default-notes-file "~/org/inbox.org")

      (setq org-capture-templates
	    '(("t" "TODOs")
	      ("tt" "Plain TODO entry (with initial content if marked)" entry (file "")
	       "* TODO %?\n\n  %i")
	      ("tl" "TODO entry with link" entry (file "")
	       "* TODO %?\n\n  %a\n\n  %i")
	      ("tr" "Process email" entry (file "")
	       "* TODO %:subject\n  SCHEDULED: %^t\n  %a\n\n  %?")
	      ("te" "To Expense" entry (file "")
	       "* TODO %:subject  :EXPENSE:\n  SCHEDULED: %^t\n\n  %a\n")
	      ("tp" "New Project" entry (file "")
	       "* %^{Project Name} :PROJECT:\n  :LOGBOOK:\n  - Added: %U\n  :END:")

	      ("d" "Log Daily Activity")
	      ("dr" "Log Reactive Activity" entry (file+datetree "DailyLog.org")
	       "* %^{Activity} %^g%^{Reactive}p\n\n%?"
	       :empty-lines 1
	       :tree-type week)
	      ("dp" "Log Planned Activity" entry (file+datetree "DailyLog.org")
	       "* %^{Activity} %^g%^{Planned}p\n\n%?"
	       :empty-lines 1
	       :tree-type week)

	      ("L" "Learning" entry (file+datetree "Learning.org")
	       "* %^{Title} %^g\n  %?")

	      ("n" "Note" entry (file+datetree "Notes.org")
	       "* %^{Subject} %^g\n\n  %?"
	       :empty-lines 1
	       :clock-in t)

	      ("m" "Meter Readings")
	      ("mg" "Gas Meter" table-line (file "notes/gas-consumption.org")
	       "|%^{Reading Time}t|%^{Reading Value}|%^{Price Per Litre|0.65}"
	       :table-line-pos "II-1")
	      ("me" "Electricity Meter" table-line (file "notes/electricity-consumption.org")
	       "|%^{Reading Time}t|%^{Reading Value}|%^{Price Per Unit|0.1333}"
	       :table-line-pos "II-1")

	      ("T" "Trip" entry (file "")
	       (file "templates/trip.org") :empty-lines 1)

	      ("a" "Absence")
	      ("ah" "Holiday" entry (file+olp "Absence.org" "2018") "* TODO %^{Reason} :Holiday:\n  %^{From}t--%^{To}t\n\n  %?%^{Holidays}p")
	      ("as" "Sick leave" entry (file+olp "Absence.org" "2018") "* DONE %^{Reason} :Sick:\n  %^{From}t--%^{To}t\n\n  %?%^{Sickdays}p")
	      ("ao" "Other leave" entry (file+olp "Absence.org" "2018") "* TODO %^{Reason} :Other:\n  %^{From}t--%^{To}t\n\n  %?%^{Days}p")

	      ("P" "password" entry (file "~/Org/passwords.org.gpg")
	       "* %^{Title}\n %^{URL}p %^{USERNAME}p %^{PASSWORD}p" :empty-lines 1)

	      ("b" "Blog Post" plain
	       (file capture-blog-post-file)
	       (file "templates/blog-post.org"))

	      ("r" "GTD Review" entry (file+datetree "GTDReview.org")
	       (file "templates/gtd-review.org")
	       :empty-lines 1
	       :clock-in t
	       :jump-to-captured t)

	      ("i" "New Invoice" plain (file "invoices/Invoices.org")
	       (file "templates/invoice.org")
	       :empty-lines 1 :immediate-finish t :jump-to-captured t)))
    #+END_SRC

*** Babel

    I wrote a module for executing AppleScript from Babel. Let's install it, so
    we can make sure it works.

    #+BEGIN_SRC emacs-lisp
      (use-package ob-applescript
	:ensure t)
    #+END_SRC

    Some initialisation settings for Org Babel is in order.

    I don't want export to execute babel stuff: I like to execute them manually
    before exporting. This is a security feature, as sometimes I have documents
    that log in to servers and does things.

    Ditaa requires a path to the installed Jar; this recently stopped working
    because I had upgraded Ditaa, and the Jar has a version number in its name.
    Now we look at the file system and grab the highest-versioned Jar available.

    When executing shell commands, I want to see the stderr output. We can
    achieve that by redirecting stderr to stdout. I got this from a post on the
    orgmode mailing list, I believe.

    #+name: org-babel-init
    #+BEGIN_SRC emacs-lisp
      ;; Tell Org where to find ditaa jar
      (setq org-ditaa-jar-path
            (-last-item (directory-files "/usr/local/opt/ditaa/libexec" t)))

      (setq org-plantuml-jar-path
            (-last-item (directory-files "/usr/local/opt/plantuml/libexec" t)))

      ;; Always include stderr output for shell
      (setq org-babel-default-header-args:sh
            '((:prologue . "exec 2>&1")
              (:epilogue . ":")))
    #+END_SRC

    We have to specify the list of languages we want to support so Orgmode knows
    to look out for them:

    #+name: org-babel-config
    #+BEGIN_SRC emacs-lisp :tangle no
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
	 (clojure . t)
	 (python . t)
	 (gnuplot . t)
	 (lilypond . t)
	 (ditaa . t)
	 (plantuml . t)
	 (applescript . t)
	 (dot . t)
	 (sql . t)
	 (shell . t)))
    #+END_SRC

*** Org Export

    I hate writing JIRA markup, so I wrote a JIRA export backend for Org mode.

    #+BEGIN_SRC emacs-lisp
      (use-package ox-jira
	:ensure t)
    #+END_SRC

    I'm not that fond of writing Markdown either. I don't feel the need to
    install these by default, but I load them if they are present.

    #+BEGIN_SRC emacs-lisp
      (use-package ox-md)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
    (require 'ox-beamer)
    (use-package ox-rst)
    #+END_SRC

*** Presenting

    Let's try presenting with Emacs.

    #+BEGIN_SRC emacs-lisp
      (use-package org-tree-slide
	:bind (("<f8>" . org-tree-slide-mode)
               ("S-<f8>" . org-tree-slide-skip-done-toggle)

               :map org-tree-slide-mode-map
               ("<f7>" . org-tree-slide-move-previous-tree)
               ("<f8>" . org-tree-slide-mode)
               ("<f9>" . org-tree-slide-move-next-tree)
               ("<f12>" . org-tree-slide-content)))
    #+END_SRC

*** Passwords

    #+BEGIN_SRC emacs-lisp
      (use-package org-passwords
	:init

	(setq org-passwords-time-opened "30 min")

	;; Where's my passwords file?
	(setq org-passwords-file "~/Org/passwords.org.gpg")

	;; Use completion for org elements
	(setq org-completion-use-ido t)

	:bind (("C-c P P" . org-passwords)
               ("C-c P g" . org-passwords-generate-password)
               :map org-passwords-mode-map
               ("C-c C-c u" . org-passwords-copy-username)
               ("C-c C-c p" . org-passwords-copy-password)
               ("C-c C-c o" . org-passwords-open-url)))
    #+END_SRC

*** Invoicing

    I have a capture template that generate invoices. In it I use the following
    functions to generate the next invoice id.

    #+BEGIN_SRC emacs-lisp
      (defun all-invoice-ids ()
	(-non-nil
	 (org-map-entries (lambda ()
                            (org-entry-get nil "InvoiceId"))
                          nil
                          '("~/Org/invoices/Invoices.org"))))

      (defun max-invoice-id ()
	(apply #'max
               (mapcar #'string-to-number
                       (all-invoice-ids))))

      (defun next-invoice-id ()
	(number-to-string
	 (+ 1
            (max-invoice-id))))
    #+END_SRC

    All my invoices go into the same file. In the template, it's used like this:

    #+BEGIN_SRC org
    * DRAFT Invoice #%(next-invoice-id)
    :PROPERTIES:
    :InvoiceId: %(next-invoice-id)
    :EXPORT_DATE: %(format-time-string "%-d %B, %Y" (org-read-date nil t "1"))
    :EXPORT_FILE_NAME: Invoice-%(next-invoice-id)
    :END:
    #+END_SRC

    I generally export each section separately, which is why I've got that
    =EXPORT_FILE_NAME= property in there.

*** Calendar

    I use calendar with org, so configure it here.

    #+BEGIN_SRC emacs-lisp
    ;; Prefer YMD to the crazy american MDY
    (setq calendar-date-style 'iso)

    ;; Include Calendar/Diary information in Agenda
    (setq org-agenda-include-diary t)
    #+END_SRC

    I prepare my invoice on the last weekday of the month. Here's a
    function to determine if that is today.

    #+BEGIN_SRC emacs-lisp
      (defun last-weekday-of-month-p (date)
	(let* ((day-of-week (calendar-day-of-week date))
               (month (calendar-extract-month date))
               (year (calendar-extract-year date))
               (last-month-day (calendar-last-day-of-month month year))
               (month-day (cadr date)))

          (or
           ;; it's the last day of the month & it is a weekday
           (and (eq month-day last-month-day)
		(memq day-of-week '(1 2 3 4 5)))

           ;; it's a friday, and it's the last-but-one or last-but-two days
           ;; of the month
           (and (eq day-of-week 5)
		(or (eq month-day (1- last-month-day))
                    (eq month-day (1- (1- last-month-day))))))))
    #+END_SRC

*** Publishing

    Publishing projects.

  #+BEGIN_SRC emacs-lisp
    (defun sb/org-html-format-drawer (name content)
      (concat "<div class=\"drawer " (downcase name) "\">\n"
	      "<h6>" (capitalize name) "</h6>\n"
	      content
	      "\n</div>"))

    (setq org-publish-project-alist
	  '(("www"
	     :components ("www-pages" "www-static" "www-rss"))

	    ("www-static"
	     :base-directory "~/blog"
	     :publishing-directory "~/public_html"
	     :base-extension "css\\|jpg\\|png\\|pdf\\|html"
	     :recursive t
	     :publishing-function org-publish-attachment)

	    ("www-pages"
	     :exclude ",.*"
	     :base-directory "~/blog"
	     :publishing-directory "~/public_html"
	     :publishing-function org-html-publish-to-html
	     :recursive t
	     :section-numbers nil
	     :time-stamp-file nil
	     :with-toc nil
	     :with-drawers t
	     :html-format-drawer-function sb/org-html-format-drawer

	     :html-html5-fancy t
	     :html-doctype "html5"
	     :html-footnotes-section "<div id=\"footnotes\"><!--%s-->%s</div>"
	     :html-link-up "/"
	     :html-link-home "/"
	     :html-home/up-format "
      <div id=\"org-div-home-and-up\">
	<nav>
	  <ul>
	    <li><a accesskey=\"H\" href=\"%s\"> Home </a> (<a href=\"/index.xml\">RSS</a>)</li>
	    <li><a accesskey=\"p\" href=\"/publications.html\"> Publications </a></li>
	    <li><a accesskey=\"A\" href=\"/about.html\"> About </a></li>
	    <li>Licence: <a accesskey=\"l\" href=\"https://creativecommons.org/licenses/by-sa/4.0/\">CC BY-SA 4.0</a></li>
	  </ul>
	</nav>
      </div>"
	     :html-head "
      <link rel=\"stylesheet\" type=\"text/css\" href=\"/etc/main.css\" />
      <link rel=\"icon\" type=\"image/png\" href=\"/etc/icon.png\" />
      <link rel=\"alternative\" type=\"application/rss+xml\"
            href=\"https://www.brautaset.org/index.xml\"
	    title=\"Stig's Soapbox RSS Feed\" />"

	     :html-head-include-default-style nil
	     :html-head-include-scripts nil

	     :html-preamble nil
	     :html-postamble-format auto
	     :html-metadata-timestamp-format "%e %B %Y")

	    ("www-rss"
	     :base-directory "~/blog"
	     :base-extension "org"
	     :html-link-home "https://www.brautaset.org"
	     :html-link-use-abs-url t
	     :rss-extension "xml"
	     :publishing-directory "~/public_html"
	     :publishing-function (org-rss-publish-to-rss)
	     :section-numbers nil
	     :exclude ".*"              ;; To exclude all files...
	     :include ("index.org")     ;; ... except index.org.
	     :table-of-contents nil)))
  #+END_SRC

*** Blogging Support

    I create blog entries in a directory under =~/blog= and link to them
    from the main index page. It has so far been a manual job, but I
    have finally managed to create a function to automate it a bit.

    #+BEGIN_SRC emacs-lisp
      (defun sb/org-kw-get (key)
	"Return a lambda that takes an Org keyword element and returns
      its :value property if its :key property matches `key'."
	`(lambda (kw)
	   (if (equal ,key (org-element-property :key kw))
	       (org-element-property :value kw))))

      (defun sb/parse-metadata ()
	"Call in a blog post to get an entry suitable for linking to this
      post from the index page."
	(interactive)
	(let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
	       (tree (org-element-parse-buffer))

	       (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
	       (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY")))
	       (abstract
		(org-element-interpret-data
		 (org-element-map tree 'special-block
		   (lambda (sb)
		     (if (equal "abstract" (org-element-property :type sb))
			 (org-element-contents sb)))))))

	  (with-temp-buffer
	    (org-mode)
	    (org-insert-heading)

	    ;; Would have loved to use `org-insert-link' here but
	    ;; I can't stop it from presenting a prompt :-(
	    (insert "[[file:" path "][" title "]]")

	    (insert "\n\n")
	    (insert abstract)

	    (org-set-property "RSS_PERMALINK"
			      (format "%s.html"
				      (file-name-sans-extension path)))

	    ;; Need to go back to the first line to set tags
	    (goto-char (point-min))
	    (org-set-tags-to categories)
	    (org-set-tags nil t) ;; adjust tags in the source

	    ;; Return the contents temporary buffer as a string *without properties*
	    (copy-region-as-kill
	     (point-min) (point-max)))))


      (defun sb/find-drafts ()
	"Find org files in `~/blog/articles' not already linked from
		    `~/blog/index.org'."
	(interactive)
	(let* ((prefix (expand-file-name "~/blog/"))
	       (posts
		(directory-files-recursively
		 (concat prefix "articles") ".org"))
	       (index-contents (get-string-from-file (concat prefix "index.org")))
	       (drafts (cl-remove-if (lambda (needle)
				       (string-match
					(string-remove-prefix prefix needle)
					index-contents))
				     posts))
	       (buffer-name "*blog drafts*"))
	  (if drafts
	      (progn
		(with-current-buffer (get-buffer-create buffer-name)
		  (erase-buffer)
		  (org-mode)
		  (insert
		   (mapconcat
		    (lambda (entry)
		      (format "- file:%s" entry))
		    drafts
		    "\n"))
		  (buffer-string))
		(unless (get-buffer-window buffer-name t)
		  (pop-to-buffer buffer-name nil t))
		(shrink-window-if-larger-than-buffer
		 (get-buffer-window buffer-name)))
	    (message "No drafts could be found!"))))
    #+END_SRC

*** Drilling

  Org drill is used for learning things by repetition.

  #+BEGIN_SRC emacs-lisp
    (use-package org-drill)
  #+END_SRC

*** Experiments

  #+BEGIN_SRC emacs-lisp
    (defun sb/org-time-max (a b)
      (if (org-time>= a b)
          a
	b))

    (defun sb/org-time-min (a b)
      (if (org-time>= a b)
          b
	a))

    (defun sb/org-columns--summary-max-time (values fmt)
      (reduce #'sb/org-time-max values))

    (defun sb/org-columns--summary-min-time (values fmt)
      (reduce #'sb/org-time-min values))

    (defun sb/org-collect-confirmed (property)
      "Return `PROPERTY' for `CONFIRMED' entries"
      (if (equal "[X]" (org-entry-get nil "CONFIRMED"))
          (org-entry-get nil property)
	"0"))

    (defun sb/org-collect-confirmed-alt (compound-property)
      "Return `PROPERTY' for `CONFIRMED' entries"
      (let ((props (s-split-words compound-property)))
	(if (equal "[X]" (org-entry-get nil (car props)))
            (org-entry-get nil (cadr props))
          "0")))

    (setq org-columns-summary-types
          '(("X+" org-columns--summary-sum sb/org-collect-confirmed)
            ("XX+" org-columns--summary-sum sb/org-collect-confirmed-alt)
            ("max-time" . sb/org-columns--summary-max-time)
            ("min-time" . sb/org-columns--summary-min-time)))
  #+END_SRC

*** Attachments

    One annoying thing is not being able to find attachments once
    you've attached files. Luckily, it turns out you can ask Org to
    create links to attachments.

    #+BEGIN_SRC emacs-lisp
    (setq org-attach-store-link-p t)
    #+END_SRC
*** Helm org

    Use helm to narrow to headings in Org agenda buffers.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-org
	:bind (:map org-mode-map
                    ("C-c h" . helm-org-in-buffer-headings)
                    ("C-c f" . helm-org-agenda-files-headings)))
    #+END_SRC

*** Diffing Org files

    Sometimes I diff Org files. (Particularly for runbooks.) This
    snippet makes sure that Org buffers don't start folded, as ediff is
    rather useless in that case. (Credit: [[mu4e:msgid:CAA01p3rSzUYvH4EmwOjw0xG=3q049fujbfC5Qi6vGZCV03EPfg@mail.gmail.com][Oleh Krehel]] on emacs-orgmode
    mailing list.)

    #+BEGIN_SRC emacs-lisp
      (defun sb/ediff-prepare-buffer ()
	(when (memq major-mode '(org-mode emacs-lisp-mode))
	  (outline-show-all)))

      (add-hook 'ediff-prepare-buffer-hook #'sb/ediff-prepare-buffer)
    #+END_SRC
*** Tempo

  This was previously called "easy templates" but is now its own package.

  #+BEGIN_SRC emacs-lisp-not-yet
  (use-package org-tempo)
  #+END_SRC

** Python

   Work projects are all in Python. This is me exploring Emacs' Python
   support.

*** Elpy

    I'll try Elpy first because of its touted refactoring support.

   #+BEGIN_SRC emacs-lisp :noweb yes
     (use-package elpy
       :ensure t
       :config
       (elpy-enable)
       (add-hook 'elpy-mode-hook 'flymake-mode))
   #+END_SRC

*** Python prerequisites

    Some [[https://github.com/jorgenschaefer/elpy#quick-installation][python modules are required]]:

    #+BEGIN_SRC sh
      pip install jedi flake8 autopep8
    #+END_SRC

*** Create a UTF-8 alias

    Our Python code tends to have the following lines:

    : # -*- coding: UTF-8 -*-

    These cause Emacs to have a sad and say:

    : Warning (mule): Invalid coding system 'UTF-8' is specified

    I don't want to change all of them, so let's just define an alias. (Thanks
    to Lucas Sampaio for this tip!)

    #+BEGIN_SRC emacs-lisp
      (define-coding-system-alias 'UTF-8 'utf-8)
    #+END_SRC
*** Convert between string types

    #+BEGIN_SRC emacs-lisp
      (use-package python-switch-quotes
	:ensure t
	:bind ("C-c '" . python-switch-quotes))
    #+END_SRC

*** Pipenv

  #+BEGIN_SRC emacs-lisp
  (use-package pipenv
    :hook (python-mode . pipenv-mode))
  #+END_SRC
*** Flymake

    #+BEGIN_SRC emacs-lisp
    (use-package flymake-python-pyflakes
      :ensure t
      :init
      (setq flymake-python-pyflakes-executable "flake8")
      :config
      (add-hook 'python-mode-hook 'flymake-python-pyflakes-load))
    #+END_SRC

** Themes
*** Load one theme at a time

    For years I thought that theme switching in Emacs was broken---until
    I read Greg Hendershott's [[http://www.greghendershott.com/2017/02/emacs-themes.html][emacs themes]] blog post. It turns out Emacs
    supports /multiple themes being active at the same time/, which I'm
    sure is convenient sometimes but becomes a right nuisance when
    attempting to switch themes IMO. Add a utility function to disable
    all currently enabled themes first.

    #+BEGIN_SRC emacs-lisp
      (defun sb/disable-all-themes ()
	(interactive)
	(mapc #'disable-theme custom-enabled-themes))

      (defun sb/load-theme (theme)
	"Enhance `load-theme' by first disabling enabled themes."
	(sb/disable-all-themes)
	(load-theme theme))
    #+END_SRC

*** Hydra Theme Switching

    Switch themes with Hydra! This loads all available themes and
    presents a menu to let you switch between them. The theme switcher
    is bound to =C-c w t=.

    The switcher is, regretfully, not automatically updated when
    installing new themes from the package selector menu, so you need to
    evaluate this block again manually.

    #+BEGIN_SRC emacs-lisp
      (setq sb/hydra-selectors
	    "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

      (defun sb/sort-themes (themes)
	(sort themes (lambda (a b) (string< (symbol-name a) (symbol-name b)))))

      (defun sb/hydra-load-theme-heads (themes)
	(mapcar* (lambda (a b)
		   (list (char-to-string a) `(sb/load-theme ',b) (symbol-name b)))
		 sb/hydra-selectors themes))

      (defun sb/hydra-theme-switcher ()
	(interactive)
	(call-interactively
	 (eval `(defhydra sb/hydra-select-themes (:hint nil :color pink)
		  "Select Theme"
		  ,@(sb/hydra-load-theme-heads (sb/sort-themes (custom-available-themes)))
		  ("DEL" (sb/disable-all-themes))
		  ("RET" nil "done" :color blue)))))
    #+END_SRC

*** Leuven Theme

    Install & activate a nice-looking theme.  This used to be my
    default for a looong time.

    #+BEGIN_SRC emacs-lisp
      (use-package leuven-theme
	:defer t
	:ensure t)
    #+END_SRC

*** Material Theme

    I'm experimenting with this theme at the moment.

    #+BEGIN_SRC emacs-lisp
      (use-package material-theme
	:ensure t
	:config
	(load-theme 'material-light))
    #+END_SRC

** Writing

   I'm not a great writer. I need all the crutches I can get. Lucklily,
   Emacs has them.

*** Writegood Mode

    This helps highlight passive voice, weasel words, etc in writing.

    #+BEGIN_SRC emacs-lisp
      (use-package writegood-mode
	:ensure t
	:init
	(add-hook 'text-mode-hook 'writegood-mode))
    #+END_SRC

*** String Inflection

  Sometimes I need to swap between CamelCase and snake_case, or even
  SNAKE_CASE.

  #+begin_src emacs-lisp
    (use-package string-inflection
      :bind (("C-c C-s C-v" . string-inflection-all-cycle)
	     ("C-c C-s C-c" . string-inflection-camelcase)
	     ("C-c C-s C-k" . string-inflection-kebab-case)
	     ("C-c C-s C-u" . string-inflection-upcase)))
  #+end_src

** YAML

   #+BEGIN_SRC emacs-lisp
   (use-package yaml-mode :ensure t)

   (use-package flymake-yaml
     :ensure t
     :config
     (add-hook 'yaml-mode-hook 'flymake-yaml-load))
   #+END_SRC
* Footnotes

[fn:1] Found at http://www.emacswiki.org/emacs/TrampMode#toc31
