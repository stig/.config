#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t
#+PROPERTY: header-args:              :mkdirp yes
#+PROPERTY: header-args:emacs-lisp    :tangle ~/.config/emacs/init.el :results silent
#+STARTUP: content
* Introduction

This is my Emacs configuration.  Because I'm forgetful, it is a
[[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document: prose interspersed with code.  I edit
this file, and /tangle/ it into [[file:../../../../../Users/stig/.config/emacs/init.el][init.el]] (and other config files) by
hitting =C-c C-v C-t=.

* Installing

I install Emacs from the [[https://github.com/d12frosted/homebrew-emacs-plus][emacs-plus]] tap, along with all other tools
(~ripgrep~, etc) using a [[file:Brewfile][Brewfile]].

* Early Init

Emacs 27 loads =~/.config/emacs/early-init.el= before loading GUI
components. This makes it a great place to disable the mouse
interface, etc.

First make sure it uses lexial binding for performance. Next I turn
off the mouse interface here to avoid momentary display during launch.
I also don't need to see a splash screen on every launch. Finally I do
/not like/ Emacs beeping at me: I prefer a visual bell.

#+BEGIN_SRC emacs-lisp :tangle ~/.config/emacs/early-init.el
;; -*- lexical-binding: t; -*-

(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

(setq inhibit-startup-message t)
(setq visible-bell t)
#+end_src

Let's also turn off GC during launch, to try to improve startup speed.
I stole this from [[https://github.com/sulami/dotfiles/blob/master/emacs/.emacs.d/init.el][Robin Schroer's config]], who got it via doom-emacs.

#+begin_src emacs-lisp :tangle ~/.config/emacs/early-init.el
;; Enable debug-on-error during launch
(setq debug-on-error t)

;; Prevent GC during launch
(setq gc-cons-threshold 500000000
      gc-cons-percentage 0.6)

;; We don't need file handlers during launch either
(defvar sulami--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

;; Don't use package.el
(setq package-enable-at-startup nil
      package--init-file-ensured t)

;; Don't check packages for rebuild on startup
(setq straight-check-for-modifications '(find-when-checking
                                         check-on-save))

;; Prefer newer bytecode
(setq load-prefer-newer t)

;; Reset file handlers & GC settings after we're done loading
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq file-name-handler-alist sulami--file-name-handler-alist)
            (setq gc-cons-threshold 16777216
                  gc-cons-percentage 0.1)
            (setq debug-on-error nil)))
#+end_src

* Bootstrap configuration

I'm trialling [[https://github.com/raxod502/straight.el][straight.el]] right now. I like that it should make it
easier to contribute back to modules I use.

** Bootstrap ~straight.el~ itself

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

** Install & configure ~use-package~

Install ~use-package~ and configure it to install packages by default.

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(straight-use-package 'bind-key)
(straight-use-package 'diminish)

(eval-when-compile
  (require 'use-package))
(require 'diminish)
(require 'bind-key)

;; No need to use ~:straight t~ for every package.
(setq straight-use-package-by-default t)

;; Avoid conflicts between multiple Org versions, cf
;; https://www.reddit.com/r/emacs/comments/g61lyn/help_needed_orgpriorityhighest/fpria2d/
(straight-use-package '(org-plus-contrib :includes (org) :local-repo "org"))
#+end_src

* Introduce Myself

In case something needs my name/email address.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Stig Brautaset"
      user-mail-address "stig@brautaset.org"
      user-login-name "stig")
#+END_SRC

* Configure PATH (and other variables) from shell

I configure ~PATH~ in ~/etc/paths~ and ~/etc/paths.d/TeX~.

The GUI Emacs gets exec path from the system, rather than the
login shell.  We have to load ~PATH~ et. al. from the shell to get
access to programs installed by Homebrew.

Copy ~PATH~ and certain other variables from my login shell so these
variables are available in Eshell.  (And elsewhere in Emacs.)

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :custom
  (exec-path-from-shell-variables '("PATH" "MANPATH"
				    "LDFLAGS" "CPPFLAGS"
				    "EDITOR"
				    "JAVA_HOME"
				    "NVM_DIR"))
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

* Make Customize settings transient
I prefer to code my configuration. This makes sure we store the custom
settings in a temporary file, so they don't persist across restarts of
Emacs. Credit to Robin Schroer for this trick.

#+BEGIN_SRC emacs-lisp
(setq custom-file (make-temp-file ""))
#+END_SRC

* Configure the basics

** Expand Region
#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+end_src
** Prefer Ibuffer over Buffer Menu
One of the key features for me is ibuffer's ability to filter by major mode.
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src
** Support recursive minibuffers

I like to be able to use my kill-ring in the minibuffer.

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src
** Ensure we don't use unencrypted auth sources

This could take the form of e.g. saving auth info to =~/.authinfo=, or
=~/.netrc= rather than =~/.authinfo.gpg=, for example.

#+begin_src emacs-lisp
(setq auth-sources (quote ("~/.authinfo.gpg")))
#+end_src

** Configure Meta/super/hyper keys

#+BEGIN_SRC emacs-lisp
(setq mac-command-modifier 'meta
      mac-option-modifier 'super
      mac-function-modifier 'hyper)
#+END_SRC

** Confirm kill emacs

The default keybinding for this is close to =M-q= which I use for
reflowing text.

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

** Make 'y' and 'n' satisfy prompts

Answering just 'y' or 'n' will do, rather than having to spell out "yes"
or "no".

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Auto-revert mode

Because I use Syncthing to share files between two computers, I want
auto-revert mode on.

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

** Make mouse scrolling smoother

The adaptive mouse scrolling is far, far too quick so let's turn that off.

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-progressive-speed nil)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))))
#+END_SRC

** Store backup files in a separate folder

I don't like backup files (those dreaded =foo~= ones) all over my disk.
This places them in a separate directory.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory))))
#+END_SRC

** Auto-save visited files

Since I sync my Org files with Synchthing I want to make sure to save
my Org files regularly to avoid lost content.

Moreover, I don't like auto-save files (those pesky =#foo#= ones) all
over my disk. This places them in a separate directory.

#+BEGIN_SRC emacs-lisp
(auto-save-visited-mode)
(setq sb/auto-save-dir (expand-file-name "auto-save" user-emacs-directory))
(setq auto-save-list-file-prefix sb/auto-save-dir)
(setq auto-save-file-name-transforms `((".*" ,sb/auto-save-dir)))
#+END_SRC

** Clipboard

These settings improve pasting behaviour with programs outside
Emacs.  Save clipboard text into kill ring before replacing them.
Copying with the mouse copies at point, rather than where you
click.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
(setq mouse-yank-at-point t)
#+END_SRC

** Font size and type

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :height 150)
(set-face-attribute 'default nil :font "Jetbrains Mono")
#+END_SRC

** UTF-8: everywhere, always

Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

** End all files in a newline

All files should end in a newline. Insert one if there isn't one already.

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

** Save my place in each file

It's nice if Emacs knows where I was last time I opened a file.

#+BEGIN_SRC emacs-lisp
(setq-default save-place t)
(setq save-place-file (concat user-emacs-directory "places"))
#+END_SRC

** Add keybinding to join next line to this

With cursor at any point in a line, hit =M-j= to move to the end, and
delete the newline. Leave the cursor where the newline used to be.

#+BEGIN_SRC emacs-lisp
(bind-key "M-j" (lambda ()
                  (interactive)
                  (join-line -1)))
#+END_SRC

** String Inflection

Sometimes I need to swap between CamelCase and snake_case, or even
SNAKE_CASE.

#+begin_src emacs-lisp
(use-package string-inflection
  :bind (("C-c C-x C-s" . string-inflection-all-cycle)
         ("C-c C-x C-c" . string-inflection-camelcase)
         ("C-c C-x C-k" . string-inflection-kebab-case)
         ("C-c C-x C-u" . string-inflection-upcase)))
#+end_src

** Unfill paragraphs and regions

The default binding for =M-q= fills a paragraph. Very good. But
sometimes I want to /unfill/[fn:: Particularly when editing markdown
that is going to end up on GitHub, as otherwise the result has lots
of hard linebreaks. This happens every time I edit a PR description
in Magit, for example.]. [[https://stackoverflow.com/a/2478549/5950][Credit]].

#+begin_src emacs-lisp
(defun sb/unfill-paragraph ()
  (interactive)
  (let ((fill-column (point-max)))
    (fill-paragraph nil)))

(defun sb/fill-or-unfill-paragraph (arg)
  "Fill a paragraph. If called with a `C-u' prefix, /unfill/ a paragraph."
  (interactive "P")
  (if arg
      (sb/unfill-paragraph)
    (fill-paragraph)))

(bind-key "M-q" 'sb/fill-or-unfill-paragraph)

(defun sb/unfill-region ()
  (interactive)
  (let ((fill-column (point-max)))
    (fill-region (region-beginning) (region-end) nil)))
#+end_src

** Cycle Spaces

Replaces all spaces and tabs around cursor with a single space. If
called with prefix arg N, leaves N spaces. If N is negative, deletes
newlines too.

#+begin_src emacs-lisp
(bind-key "M-SPC" #'cycle-spacing)
#+end_src
** Support for fullscreen

I like to run apps in fullscreen mode. Sometimes it's useful to be
able to toggle it on or off, which this function does. I found it
at the [[https://www.emacswiki.org/emacs/FullScreen#toc26][EmacsWiki Fullscreen page]].

#+BEGIN_SRC emacs-lisp
(defun my-toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

(bind-key "M-<f11>" 'my-toggle-fullscreen)
#+END_SRC

** Toggle Window Split function

Sometimes a window is split horizontally, and you would prefer
vertically. Or vice versa. This function can help! Just don't ask me how
it works: I found it on StackOverflow. (I think. Again.)

#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(define-key ctl-x-4-map "t" 'toggle-window-split)
#+END_SRC

** Diary (Calendar) Functions

Prefer YMD to the /crazy/ american MDY order.

I schedule some things every weekday,
so add a convenience function for that.

#+BEGIN_SRC emacs-lisp
(setq calendar-date-style 'iso)

(defun sb/weekday-p (date)
  "Is `date' a weekday?"
  (memq (calendar-day-of-week date) '(1 2 3 4 5)))
#+END_SRC

** Git Link

Lets me link to a file location on GitHub/Bitbucket/GitLab
from a local git repository.

#+BEGIN_SRC emacs-lisp
(use-package git-link
  :after magit
  :bind ("C-c g l" . git-link))
#+END_SRC

** GnuPG

Emacs will open =.gpg= files transparently, but I need to install gnupg
& pinentry for that to work.

#+begin_src emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+end_src

** Remove ANSI colours

#+begin_src emacs-lisp
(defun sb/remove-ansi-colours-from-buffer ()
  (interactive)
  (ansi-color-filter-region (point-min) (point-max)))
#+end_src

** Don't require two spaces to end a sentence

Having this enabled makes it harder to collaborate with others, and
move sentences around in texts I haven't written.

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

** Delete buffer and file it is visiting

Copied from [[https://github.com/sulami/dotfiles/blob/master/emacs/.emacs/README.org#delete-buffer-file][sulami]]'s config.

#+begin_src emacs-lisp
(defun sb/delete-file-and-buffer ()
  "Deletes a buffer and the file it's visiting."
  (interactive)
  (when-let* ((file-name (buffer-file-name))
              (really (yes-or-no-p (format "Delete %s? "
                                           file-name))))
    (delete-file file-name)
    (kill-buffer)))
#+end_src

** Sending mail with MSMTP

MSMTP's [[file:../msmtp/config][configuration]] is really simple, and it will detect the account
to use from the "from" address.

Passwords are stored in the system Keychain. See the [[http://msmtp.sourceforge.net/doc/msmtp.html#Authentication][Authentication]]
section in the msmtp documentation for details.

: security add-internet-password -s mail.gandi.net -r smtp -a stig@brautaset.org -w

Finally we have to tell Emacs to use msmtp to send mail.  (And to
kill the message buffer on exit.)

#+BEGIN_SRC emacs-lisp
(setq sendmail-program "msmtp"
      message-send-mail-function 'message-send-mail-with-sendmail
      message-kill-buffer-on-exit t
      message-directory "~/.mail"
      message-sendmail-envelope-from 'header
      mail-envelope-from 'header
      mail-specify-envelope-from t)
#+END_SRC

** Display line numbers

Displaying line numbers is incredibly useful when remotely pairing
with other people.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode)))
#+end_src

** Lorem Ipsum input

Useful for quickly filling in placeholder text.

#+begin_src emacs-lisp
(use-package lorem-ipsum)
#+end_src

** View Mode

Navigate read-only buffers up and down with space and backspace.

#+begin_src emacs-lisp
(setq view-read-only t)
#+end_src
** Pulse

I used to use Beacon for this, but now I don't need a separate module.
[[https://karthinks.com/software/batteries-included-with-emacs/#pulse--pulse-dot-el][Source]].

#+BEGIN_SRC emacs-lisp
(defun pulse-line (&rest _)
      "Pulse the current line."
      (pulse-momentary-highlight-one-line (point)))

(dolist (command '(scroll-up-command scroll-down-command
                   recenter-top-bottom other-window))
  (advice-add command :after #'pulse-line))
#+end_src
** Upcase-dwim and dowcase-dwim

Acts like ~upcase-word~ with no region selected, and ~upcase-region~
when one is.

#+begin_src emacs-lisp
(bind-key "M-u" #'upcase-dwim)
(bind-key "M-l" #'downcase-dwim)
#+end_src
* Minor modes

A minor mode provides some functionality that you can turn off or on.
Multiple minor modes can be active for a buffer.

** Ace Window

This lets me rapidly switch to a different frame/window.  I use
this mainly when resolving conflicts in ediff merge, since I need
to swap between two frames there.

#+begin_src emacs-lisp
(use-package ace-window
  :bind (("C-S-s-<tab>" . ace-window) ; aka Meh-<tab>
	 ("M-`" . ace-window)))
#+end_src

** Auto commit

In some projects (notably, my Org/Agenda setup) I want to
automatically commit when editing files.

#+BEGIN_SRC emacs-lisp
(use-package git-auto-commit-mode
  :custom
  (gac-automatically-add-new-files-p t)
  (gac-automatically-push-p t))
#+END_SRC

** Company (COMplete ANYthing)
#+begin_src emacs-lisp
(use-package company
  :hook (after-init . global-company-mode))
#+end_src
** Counsel

This provides =counsel-find-file=, among others.

#+begin_src emacs-lisp
(use-package amx) ;; make counsel-M-x work the way I like

(use-package counsel
  :diminish
  :after org
  :demand
  :bind (("C-c i" . counsel-semantic-or-imenu)
	 :map org-mode-map
	 ("C-c i" . counsel-org-goto))
  :config
  (counsel-mode 1))
#+end_src

** Diff Highlight

#+begin_src emacs-lisp
(use-package diff-hl
  :config
  (global-diff-hl-mode))
#+end_src

** Dumb-jump

Trying this out again, now that it registers an xref backend:

#+begin_src emacs-lisp
(use-package dumb-jump
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

** Edit "Org-like" lists in non-Org buffers

#+begin_src emacs-lisp
(use-package orgalist
  :after org
  :hook
  (message-mode . orgalist-mode))
#+end_src

** Flycheck

#+begin_src emacs-lisp
(use-package flycheck-mode
  :straight flycheck
  :hook clojure-mode)
#+end_src

** Highlight & deal with whitespace annoyances

This highlights certain whitespace annoyances, and adds a key binding to
clean it up.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :bind ("C-c w" . whitespace-cleanup)
  :custom
  (whitespace-style '(face empty tabs trailing))
  :config
  (global-whitespace-mode t))
#+END_SRC

** Ivy

I've long been a happy Helm user, but it confuses me (and is slow!)
in some situations so I thought I'd try again to see if Ivy fares
any better.

#+begin_src emacs-lisp
(use-package ivy
  :diminish
  :demand
  :bind (("C-c C-r" . ivy-resume)
         ("C-x b" . ivy-switch-buffer)
         ("C-c v" . ivy-push-view)
         ("C-c V" . ivy-pop-view))
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-count-format "%d/%d ")
  :config
  (ivy-mode 1))
#+end_src

** LSP (Language Server Protocol)

LSP is useful for =M-.= (~find-definitions~) and =M-?= (~find-references~),
among other things.

#+begin_src emacs-lisp
;; Important for lsp performance
(setq read-process-output-max (* 1024 1024))

(use-package lsp-mode
  :hook ((clojure-mode . lsp)
         (lsp-mode . lsp-enable-which-key-integration))
  :commands lsp
  :custom
  (lsp-enable-file-watchers . nil))

(use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
(use-package lsp-treemacs :commands lsp-treemacs-errors-list)

(use-package lsp-java
  :commands lsp
  :hook (java-mode . lsp))
#+end_src

** Multiple Cursors

This package is another one of those near-magical ones. It allows me to do
multiple edits in the same buffer, using several cursors. You can think of
it as an interactive macro, where you can constantly see what's being done.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-c M-e" . mc/edit-lines)
         ("C-c M-a" . mc/mark-all-dwim)
         ("s-n" . mc/mark-next-like-this)
         ("s-p" . mc/mark-previous-like-this)))
#+END_SRC

** Projectile

I use Projectile to navigate my projects. Some of the things I like about
it are that it provides the following key bindings:

- =C-c p f= :: Find a file in this project.
- =C-c p k= :: Close all buffers for this project.
- =C-c p t= :: This switches from an implementation file to its test file,
               or vice versa. I use this extensively in Clojure mode. It
               might not make sense for all languages; YMMV.
- =C-c p s r= :: Ripgrep for something in this project. If point is at
                 a token, default to searching for that.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :diminish
  :bind-keymap ("C-c p" . projectile-command-map)
  :custom
  (projectile-completion-system 'ivy)
  (projectile-dynamic-mode-line nil)
  :config

  ;; I use /usr/local/src on my work laptop in an attempt to avoid the
  ;; dreaded Sophos Penalty, but ~/src is much more convenient so I
  ;; use that on my personal machine. I would just set both, but
  ;; projectile doesn't like it if the directories don't exist.
  (setq projectile-project-search-path
	(seq-filter (lambda (e) (file-directory-p e))
		    '("/usr/local/src" "~/src")))

  (projectile-mode))

(use-package counsel-projectile)
#+END_SRC

** Rainbow Delimiters

This makes it slightly easier to discern matching parens when the
nesting goes deep.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Save minibuffer history

This allows us to "tap up" in the minibuffer to recall previous items,
even from a previous session.

#+BEGIN_SRC emacs-lisp
(savehist-mode 1)
#+END_SRC

** Show Matching parens

This is extremely useful. Put the mark on a paren (any of =()[]{}=,
actually) and Emacs shows the matching closing/opening one.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

** SmartParens

Structural editing is a must when editing lisp, and it has bled
into other aspects of programming for me.  In particular the
ability to remove surrounding parens / quotes with ~sp-splice-sexp~
is incredibly useful even when writing prose.

#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :straight smartparens
  :demand
  :custom
  (sp-base-key-bindings 'sp)
  (sp-show-pair-from-inside t)
  :config
  (sp-local-pair 'text-mode "'" nil :actions :rem)
  (show-smartparens-global-mode t))
(add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
(add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)
(add-hook 'org-mode-hook 'turn-on-smartparens-strict-mode)
#+END_SRC

** Subword

Treats CapitalizedWords as separate, so we can move forward by
their components.  Useful in anything that looks like Java.

#+begin_src emacs-lisp
(use-package subword
  :hook (prog-mode . subword-mode))
#+end_src

** Swiper

Invoke swiper (find in current buffer).

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :bind (("C-s" . swiper)))
#+END_SRC

** Transparently open compressed files

I *do* like it when Emacs transparently opens compressed files. It gives
me the warm fuzzies.

#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC

** Visual line mode / word wrapping

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'visual-line-mode)
#+END_SRC

** Which Key Mode

Show incomplete key cheatsheet.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+END_SRC

** Writegood Mode

I'm not a great writer. I need all the crutches I can get. Lucklily,
Emacs has them.

This helps highlight passive voice, weasel words, etc in writing.

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :hook text-mode)
#+END_SRC

** YAS

A templating engine for Emacs.

#+begin_src emacs-lisp
(use-package yasnippet
  :config
  (yas-global-mode))
#+end_src


* Major modes

Each buffer has exactly one major mode. (Though a major mode can be
/derived/ from another one.)

** Clojure

#+BEGIN_SRC emacs-lisp
(use-package flycheck-clj-kondo)

(use-package clojure-mode
  :config
  (require 'flycheck-clj-kondo)
  (put-clojure-indent 'as-> ':defn)
  (put-clojure-indent 'run ':defn)
  (put-clojure-indent 'dosync ':defn)
  (put-clojure-indent 'speculate 1)
  (put-clojure-indent 'doseq ':defn)
  (put-clojure-indent 'wrap-with-timing ':defn)
  (put-clojure-indent 'wrap-with-per-call-timing ':defn))

(use-package cider
  :hook ((cider-mode . sb/unload-cider-jumps)
	 (cider-repl-mode . sb/unload-cider-jumps))
  :config
  (defun sb/unload-cider-jumps ()
    ;; I prefer lsp's jumps, so kindly don't steal them
    (define-key cider-mode-map (kbd "M-.") nil)
    (define-key cider-mode-map (kbd "M-,") nil))
  :custom
  (cider-prompt-for-symbol nil)
  (cider-redirect-server-output-to-repl nil)
  (cider-prefer-local-resources t)
  (cider-auto-track-ns-form-changes t)
  (cider-repl-pop-to-buffer-on-connect nil)
  (cider-eldoc-display-context-dependent-info t)
  (cider-font-lock-dynamically '(macro core function var)))

(use-package clj-refactor
  :disabled
  :after (yas clojure-mode)
  :init
  (defun sb/clojure-mode-hook ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1))
  :hook (clojure-mode . sb/clojure-mode-hook))
#+END_SRC

** Ediff

Sometimes I have to resolve conflicts. I use Ediff, which I
(usually) launch from Magit.

*** Automatically Unfold Org files

This snippet makes sure that Org buffers don't start folded, as
ediff is rather useless in that case. (Credit: Oleh Krehel on
emacs-orgmode mailing list.)

#+BEGIN_SRC emacs-lisp
(defun sb/ediff-prepare-buffer ()
  (when (memq major-mode '(org-mode emacs-lisp-mode))
    (outline-show-all)))

(add-hook 'ediff-prepare-buffer-hook #'sb/ediff-prepare-buffer)
#+END_SRC

*** Picking /both/ sides in a conflict

If both branches add an entry to a list I may want to pick *both*
sides. This adds =d= as a shortcut to do that. ([[http://stackoverflow.com/a/29757750/5950][Credits]].) I can use
=~= to swap the A and B buffers, which lets me choose A then B, /or/ B
then A.

#+BEGIN_SRC emacs-lisp
(defun sb/ediff-copy-both-to-C ()
  (interactive)
  (ediff-copy-diff ediff-current-difference nil 'C nil
                   (concat
                    (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                    (ediff-get-region-contents
                    ediff-current-difference 'B
                    ediff-control-buffer))))

(defun sb/add-d-to-ediff-mode-map ()
  (define-key ediff-mode-map "d" 'sb/ediff-copy-both-to-C))

(add-hook 'ediff-keymap-setup-hook 'sb/add-d-to-ediff-mode-map)
#+END_SRC

** Elfeed

~org-elfeed~ stores the feed config in =elfeed.org= rather than =custom.el=.

I keep my Elfeed DB in a folder that I sync between my work and home
machine, so I don't have to mark stuff read in multiple places.

#+BEGIN_SRC emacs-lisp
(use-package elfeed-org
  :custom
  (rmh-elfeed-org-files `("~/org/elfeed.org"))
  :config
  (elfeed-org))

(use-package elfeed
  :bind (("C-x w" . elfeed)
         :map elfeed-search-mode-map
         ("m" . elfeed-toggle-star) )
  :custom
  (elfeed-db-directory "~/Sync/elfeed")
  :config
  (defalias 'elfeed-toggle-star
    (elfeed-expose #'elfeed-search-toggle-all 'star)))
#+END_SRC

** Eshell

I have started using /Eshell/. It is close to magic. There's not a lot ofs
etup (it has its own [[file:eshell/alias][alias file]]), but I've got a keybinding to bring up
eshell quickly. This launches eshell if it is not already running, or
switches to it if it is.

#+BEGIN_SRC emacs-lisp
(bind-key "C-c s" 'eshell)
#+END_SRC

Eshell is great, and its Tramp integration allows me to open remote files
in local Emacs seamlessly with the =find-file= command. (Which I have
aliased to =ff=.) Eshell also makes sure that my shell behaves the same,
and has the same config, whether I am on a local machine or a remote one.

** HugSQL

#+begin_src emacs-lisp
(use-package hugsql
  :straight nil
  :defer t
  :init
  (defun sulami/init-hugsql-imenu ()
    (when (string-suffix-p ".hug.sql" (buffer-file-name))
      (setq imenu-generic-expression
	    '((nil "^--[[:space:]]:name[[:space:]]+\\([[:alnum:]-]+\\)" 1)))))
  :hook
  (sql-mode . sulami/init-hugsql-imenu))
#+end_src

** JSON Mode

#+begin_src emacs-lisp
(use-package json-mode)
#+end_src
** Magit & Friends

I use [[http://magit.vc][Magit]], a git porcelain for Emacs, all day.  I rarely use the
git cli any more.  I've seen someone suggest learning Emacs just to
run Magit.

Forge is an extension to Magit that interacts with GitHub / GitLab etc.

#+BEGIN_SRC emacs-lisp
(use-package transient)

(use-package magit
  :bind (("C-x C-g C-s" . magit-status)
	 ("C-S-s-m" . magit-status)
	 ("C-S-s-b" . magit-blame-addition)
         ("C-x C-g s" . magit-status)
         ("C-x C-g C-b" . magit-blame-addition)
         ("C-x C-g b" . magit-blame-addition)))

(use-package forge)
#+END_SRC

** Markdown

I'm a sucker for lists, and I want to be able to reorder list items
easily and have them renumbered automatically.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  ;; I essentially don't use Markdown
  ;; outside GitHub any more
  :mode ("\\.md\\'" . gfm-mode)
  :bind (("M-<up>" . markdown-move-list-item-up)
         ("M-<down>" . markdown-move-list-item-down))
  :custom
  (markdown-fontify-code-blocks-natively t)
  (markdown-asymmetric-header t))
#+END_SRC
** Notmuch

I like to use Emacs for /all/ writing, including email. I don't want a
separate program to read and write emails, so it follows I must /read/
email in Emacs too. I currently use [[https://notmuchmail.org][Notmuch]] for this.

Notmuch works pretty well for me out of the box.

Notmuch's Emacs bindings are closely tied to the binary programs, so
they (strongly) recommend that you don't install Notmuch from ELPA.

I configure Notmuch to save a copy of outgoing mail into my sent mail
folder.

#+BEGIN_SRC emacs-lisp
(use-package notmuch
  :demand
  :hook
  (notmuch-message-mode . turn-off-auto-fill)
  :custom
  (notmuch-archive-tags '("-inbox" "+archived"))
  (notmuch-multipart/alternative-discouraged '("text/x-amp-html" "text/plain" "text/html"))
  (notmuch-search-oldest-first nil)
  (notmuch-address-use-company nil)
  (notmuch-hello-thousands-separator ",")
  (notmuch-mua-cite-function (quote message-cite-original-without-signature))
  (notmuch-fcc-dirs "Sent +sent -inbox -unread")
  (notmuch-saved-searches
   `((:name "Inbox" :query "tag:inbox" :key "i")
     (:name "Flagged" :query "tag:flagged" :key "f")
     (:name "Drafts" :query "tag:draft" :key "d")
     (:name "Recent" :query "date:2d.. and not tag:lists" :key "r" :search-type tree)
     (:name "My Threads" :query "thread:\"{from:stig}\" and tag:lists and tag:unread" :key "t" :search-type tree)))
  (notmuch-tagging-keys
   (quote
    (("a" notmuch-archive-tags "Archive")
     ("u" notmuch-show-mark-read-tags "Mark read")
     ("f" ("+flagged") "Flag")
     ("s" ("+spam" "-inbox") "Mark as spam")
     ("d" ("+deleted" "-inbox") "Delete")))))
#+END_SRC

** PlantUML

I sometimes need to draw UML diagrams. For some reason I can't get the
Jar to work in the major mode, but it works fine in Org mode.

#+begin_src emacs-lisp
(use-package plantuml-mode
  :custom
  (plantuml-default-exec-mode 'executable)
  (plantuml-font-lock-keywords t))

(use-package ob-plantuml
  :after org
  :straight nil
  :custom
  (org-plantuml-jar-path "/usr/local/opt/plantuml/libexec/plantuml.jar"))
#+end_src

** Protobuf Mode
We use protobufs for service-to-service communication at work.

#+begin_src emacs-lisp
(use-package protobuf-mode)
#+end_src

** Ripgrep

Even faster than The Silver Searcher, apparently.

#+begin_src emacs-lisp
(use-package ripgrep
  :custom
  ;; I often look for stuff in .circleci/config.yml
  (ripgrep-arguments '("--hidden")))
#+end_src

** Simple HTML Renderer (HTML Email)

I mostly use shr for reading HTML mail.  I normally use a
fullscreen window, but I don't like reading HTML mails with lines
running all the way across.  Thus I prefer linebreaks roughly every
80 characters.

#+begin_src emacs-lisp
(setq shr-width 80)
#+end_src

** Spell Checking

I use aspell, with British English dictionary.

#+BEGIN_SRC emacs-lisp
(use-package ispell)
#+END_SRC

** Tramp

Trying to speed up Tramp over SSH with these settings from the [[https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html][FAQ]],
and cribbing liberally from [[https://github.com/sulami/dotfiles/tree/master/emacs/.emacs][Robin Schroer]]'s config.

#+begin_src emacs-lisp
(setq tramp-ssh-controlmaster-options
      "-o ControlMaster=auto -o ControlPath='tramp.%%C'")

;; Various speedups
;; from https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html
(setq remote-file-name-inhibit-cache 3600
      tramp-completion-reread-directory-timeout nil
      vc-ignore-dir-regexp (format "%s\\|%s"
				   vc-ignore-dir-regexp
				   tramp-file-name-regexp)
      tramp-verbose 0)

;; Disable the history file on remote hosts
(setq tramp-histfile-override t)

;; Save backup files locally
;; from https://stackoverflow.com/a/47021266
(add-to-list 'backup-directory-alist
	     (cons tramp-file-name-regexp "/tmp/emacs-backup/"))
#+end_src

** Typescript
Credit to Robin Schroer.

#+begin_src emacs-lisp
(use-package typescript-mode
  :mode "\\.tsx\\'"
  :defer t
  :custom
  (typescript-indent-level 2))

(use-package tide
  :defer t
  :config
  (defun sulami/tide-setup ()
    (when (equal "tsx"
                 (file-name-extension buffer-file-name))
      (tide-setup)
      (flycheck-mode +1)
      (eldoc-mode +1)))
  :hook
  ((typescript-mode . sulami/tide-setup)
   (web-mode . sulami/tide-setup)))
#+end_src
** Wgrep (aka "writable grep")

~wgrep~ mode is pretty close to magic. When in a buffer showing
grep/ag/ripgrep results, I can hit =C-c C-p= to let me /edit the
results of the search right from the results buffer!/ I can then
hit =C-x C-s= to save the results.

Hitting =C-c C-p= while already in writable grep mode I can delete
the entire matched line by hitting =C-c C-d=.

#+begin_src emacs-lisp
(use-package wgrep
  :straight (wgrep :type git
		   :host github
		   :repo "mhayashi1120/Emacs-wgrep"))
#+end_src

** YAML

CircleCI and CloudFormation loves YAML.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
#+END_SRC

* Org mode

I use Org mode for all writing I initiate.  Org mode's support for
tables, TOC, footnotes, TODO and Agenda items makes it an easy
choice.  Gists and GitHub READMEs support Org mode too, and I can
export to other formats including if I want.

The Org manual expects the =C-c {l,a,c}= keybindings to be available
in any mode, so define them globally.  I prefer to follow
conventions.  It makes reading the manual and tutorials a lot
easier!

I use Org's refiling when "refactoring" documents such as this one.
I learnt about it from this from [[https://www.youtube.com/watch?v=ECWtf6mAi9k][this YouTube video]].

I use Org Agenda for keeping track of my TODOs. I don't normally use
properties, so I ignore most to help speed up my agenda view. ([[http://orgmode.org/worg/agenda-optimization.html][ref]]) I
configure TODO list and tag search to ignore future scheduled,
deadlined, and timestamped issues. These will show in the Agenda
eventually anyway.

I love Org's markup so much I wrote a JIRA export backend for it.  I
also write in Org and export to GitHub.  GitHub unfortunately
doesn't properly ignore linebreaks in Markdown, so I use the =gfm=
exporter, as this deletes linebreaks.  This means the rendered
paragraphs re-flow properly on GitHub.

#+BEGIN_SRC emacs-lisp
;; This is the opposite direction of the sb/capture-tag, so that we
;; can exclude home tasks from work and vice versa, but still have
;; tasks that show up both home and at work.
(setq sb/agenda-tag (if (string-match "margil" (system-name))
			"-@work" "-@home"))

(use-package org
  :straight org-plus-contrib
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c c" . org-capture)
	 ;; I try to track time...
	 ("C-c C-x C-j" . org-clock-goto)
         :map org-mode-map
         ("C-x C-<return>" . org-insert-subheading)
         ("C-S-<return>" . org-insert-todo-subheading)
         ("C-n" . org-next-link)
         ("C-p" . org-previous-link))

  :mode (("\\.org\\'" . org-mode)
         ("\\.org_archive\\'" . org-mode))

  :custom
  ;; Whitespace and edits
  (org-adapt-indentation nil)
  (org-src-preserve-indentation nil)
  (org-edit-src-content-indentation 0)
  (org-hide-emphasis-markers nil)
  (org-link-file-path-type 'relative)
  (org-log-into-drawer t "When hitting C-c C-z to take a note, always put it in the LOGBOOK drawer")
  (org-catch-invisible-edits 'smart)
  (org-export-copy-to-kill-ring 'if-interactive "If running interactively, I want export to copy to the kill-ring")
  (org-export-with-section-numbers nil)
  (org-export-with-toc nil)
  (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

  (org-table-header-line-p t)

  (org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)")
		       (sequence "PROJ(p)" "|" "COMPLETE")
		       (sequence "|" "CANCELLED")))

  (org-tag-alist '(("@work" . ?w)
		   ("@home" . ?h)
		   ("proj" . ?p)
                   ("someday" . ?s)
		   ("noexport" . ?n)
		   ("toil" . ?t)
		   ("meeting" . ?m)
		   ("brag" . ?b)
		   ("achievement" . ?a)
		   ("inbox" . ?i)
		   ("interrupt" . ?I)
		   ("note" . ?N)))

  (org-log-done 'time)
  (org-stuck-projects '("-someday/PROJ" ("TODO" "WAITING") nil ""))

  (org-refile-use-outline-path 'file "Allow refiling to sub-paths")
  (org-refile-allow-creating-parent-nodes 'confirm)
  (org-refile-targets '((org-agenda-files . (:todo . "PROJ"))
                        (org-agenda-files . (:tag . "recurring"))
			(org-agenda-files . (:maxlevel . 1))))
  (org-goto-interface 'outline-path-completion "Make 'org-refile' work better with Ivy")
  (org-outline-path-complete-in-steps nil "Make 'org-refile' work better with Ivy")
  (org-agenda-include-diary t)
  (org-agenda-files "~/org/org-agenda-files.txt")

  (org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2 :fileskip0 t))
  (org-agenda-tags-todo-honor-ignore-options t)
  (org-agenda-todo-ignore-scheduled 'future)
  (org-agenda-todo-ignore-deadlines 'far)
  (org-agenda-todo-ignore-with-date 'future)
  (org-agenda-todo-ignore-timestamp 'future)
  (org-agenda-skip-deadline-prewarning-if-scheduled t)
  (org-agenda-skip-timestamp-if-done t)
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-skip-deadline-if-done t)
  (org-agenda-skip-scheduled-if-deadline-is-shown 'repeated-after-deadline)

  (org-agenda-custom-commands
   `(("d" "Day Agenda & Top Tasks"
      ((agenda "")
       (tags-todo "-PRIORITY=\"C\"/TODO"))
      ((org-agenda-span 'day)
       (org-agenda-tag-filter-preset '(,sb/agenda-tag
				       "-someday"
				       "-inbox"))))
     ("g" . "Getting Things Done")
     ("gA" "Agenda minus recurring tasks"
      agenda ""
      ((org-agenda-tag-filter-preset '("-recurring"))))
     ("gi" "Inbox" tags "inbox")
     ("gs" "Someday"
      ((todo "PROJ")
       (tags-todo "-proj/TODO"))
      ((org-agenda-tag-filter-preset '("+someday"))))
     ("gc" "Review for Tasks Complete"
      todo "TODO"
      ((org-agenda-tag-filter-preset '("-someday" "-recurring" "-gtd"))))
     ("gw" "Waiting tasks" todo "WAITING")
     ("ga" "Archivable"
      ((todo "COMPLETE")
       (tags "-proj-gtd/DONE")
       (tags "-proj-gtd/CANCELLED")))
     ("gp" "Projects" tags-todo "-someday/PROJ")))
  :config
  (require 'org-habit))

(use-package ox-jira
  ;; Need to specify the branch here because of
  ;; https://github.com/raxod502/straight.el/issues/279
  :straight (ox-jira :type git
		     :host github
		     :repo "stig/ox-jira.el"
		     :branch "trunk")

  :custom
  ;; This lets foo_bar through "unmolested", while foo_{1} uses a subscript
  ;; See https://github.com/stig/ox-jira.el/issues/53
  (org-export-with-sub-superscripts '{}))

(use-package ox-gfm)
#+end_src

** Capturing

Set up capture templates. I learnt about these from [[http://koenig-haunstetten.de/2014/08/29/the-power-of-orgmode-capture-templates/][Rainer's blog post]]
(and YouTube series). It has grown a bit since then.

I have a special function to create ~@work~ and ~@home~ tags, based on
which machine I am capturing the item. It's not always correct, but
usually I am in a work frame of mind on my work computer and vice versa.

#+begin_src emacs-lisp
;; This is the tag we assign based on which machine we tag on.
(setq sb/capture-tag (if (string-match "margil" (system-name))
		      "@home" "@work"))

(use-package org
  :straight org-plus-contrib
  :custom
  (org-default-notes-file
   (let ((name (downcase (car (split-string (system-name) "\\.")))))
     (expand-file-name (format "%s.org" name) "~/org")))

  (org-capture-templates
   `(("t" "TODO" entry (file "") ,(format "* TODO %%? :inbox:%s:" sb/capture-tag))
     ("l" "TODO with [l]ink to here" entry (file "") ,(format "* TODO %%? :inbox:%s:\ncf %%a " sb/capture-tag))

     ("T" "Trip" entry (file "") (file "templates/trip.org"))

     ("g" "New Gas Meter Reading" table-line
      (file "~/org/notes/gas-consumption.org")
      (file "templates/gas-consumption.org"))
     ("e" "New Electricity Meter Reading" table-line
      (file "~/org/notes/electricity-consumption.org")
      (file "templates/electricity-consumption.org"))

     ("f" "Decide Focus Areas" entry
      (file "~/org/focus-areas.org")
      (file "templates/focus-areas.org"))
     ("b" "Boulders for the Week" entry
      (file "~/org/boulders.org")
      "* %<%Y/%B/Week %V>\n1. %?")

     ("r" "New GTD Review" entry
      (file+olp+datetree "~/org/archive/gtd_review.org")
      (file "templates/gtd-review.org") :clock-in t))))
#+end_src

** Babel

Org Babel is magical: execute code from different languages in the
same file, and capture the output! I list the languages I want to
support. I also have to load some modules so they're available when I
need them.

#+begin_src emacs-lisp
(use-package org
  :init
  (require 'ob-shell)
  :config
  (org-babel-do-load-languages 'org-babel-load-languages
			       '((emacs-lisp . t)
				 (sql . t)
				 (shell . t)
				 (plantuml . t))))
#+end_src

** Verb

This is a package I use for interacting with REST HTTP APIs. Before
arriving at it I tried restclient, walkman, and http.el. All have
their strengths and weaknesses, but Verb seems the most well-rounded
feature set. The hierachical inheritance is what really sold me, as it
works really well with REST APIs to reduce boilerplate.

#+begin_src emacs-lisp
(use-package verb
  :init
  (defun sb/api-token-for-host (host)
    "Return a token for the specified host."
    (let ((found (nth 0 (auth-source-search :host host :create nil))))
      (when found
	(let ((secret (plist-get found :secret)))
	  (if (functionp secret)
	      (funcall secret)
	    secret)))))
  :config
  (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
#+end_src

** Roam
[[https://github.com/org-roam/org-roam][Org-roam]] is a new one for me. It's meant to be an "exo-brain",
modelled after the Zettelkasten method. I'm excited to try it and see
if it improves how I work.

#+begin_src emacs-lisp
(use-package org-roam
  :ensure t
  :custom
  (org-roam-dailies-directory "daily/")
  (org-roam-dailies-capture-templates
   '(("d" "daily" entry #'org-roam-capture--get-point
      "* %<%H:%M> %?\n"
      :file-name "daily/%<%Y-%m-%d>"
      :head "#+title: %<%Y-%m-%d>\n#+roam-tags: %<%Yw%V>\n\n")
     ("j" "Jira entry" entry #'org-roam-capture--get-point
      (file "templates/jira.org")
      :file-name "daily/%<%Y-%m-%d>"
      :head "#+title: %<%Y-%m-%d>\n#+roam-tags: %<%Yw%V>\n\n")))
  (org-roam-rename-file-on-title-change t)
  (org-roam-directory "~/org/roam")
  (org-roam-completion-system 'ivy)
  (org-roam-tag-sources '(prop all-directories))
  ;; The below required due to https://github.com/org-roam/org-roam/issues/597
  (org-roam-index-file "~/org/roam/index.org")
  :bind ((("C-c n d" . org-roam-dailies-capture-today)
	  ("C-c n l" . org-roam)
	  ("C-c n j" . org-roam-jump-to-index)
	  ("C-c n b" . org-roam-db-build-cache)
	  ("C-c n f" . org-roam-find-file)
	  ("C-c n g" . org-roam-graph))
	 :map org-mode-map
	 (("C-c n i" . org-roam-insert))
	 (("C-c n I" . org-roam-insert-immediate))))
#+end_src

*** Org Roam Protocol

This should allow interaction with Roam from outside Emacs, for
example capturing from a Firefox bookmarklet.

#+begin_src emacs-lisp
(use-package org-roam-protocol
  :after org-roam
  :straight nil
  :init
  (server-start)
  :custom
  (org-roam-capture-ref-templates
   '(("r" "ref" plain #'org-roam-capture--get-point ""
      :file-name "website/%<%Y%m%d%H%M%S>-${slug}"
      :head "#+title: ${title}\n#+roam_key: ${ref}"
      :unnarrowed t)
     ("rs" "ref" plain #'org-roam-capture--get-point ""
      :file-name "website/%<%Y%m%d%H%M%S>-${slug}"
      :head "#+title: ${title}\n#+roam_key: ${ref}\n\n${selection}"
      :unnarrowed t)
     )))
#+end_src

*** Org Roam Server

This exposes an HTTP server that makes it easier to browse the graphs
of notes.

#+begin_src emacs-lisp
(use-package org-roam-server
  :custom
  (org-roam-server-host "127.0.0.1")
  (org-roam-server-port 4040)
  (org-roam-server-export-inline-images t)
  (org-roam-server-authenticate nil)
  (org-roam-server-network-arrows nil)
  (org-roam-server-network-label-truncate t)
  (org-roam-server-network-label-truncate-length 60)
  (org-roam-server-network-label-wrap-length 20)
  (org-html-postamble nil)
  :hook (after-init . org-roam-server-mode))
#+end_src

** Org Jira

#+begin_src emacs-lisp
(use-package org-jira
  :defer t
  :custom
  (jiralib-url "https://circleci.atlassian.net")
  ;; FIXME haven't confirmed these yet, probably wrong.
  ;; (org-jira-pross-issue-flow '(("Ready for Dev" . "In Progress")
  ;;                              ("In Progress" . "Code Review")
  ;;                              ("Code Review" . "Production Testing")
  ;;                              ("Production Testing" . "Done")
  ;;                              ("Done" . "In Progress")))
  (org-jira-custom-jqls
   '(;; Ready for dev
     (:jql " issuetype != Epic and \"Dev Team\" = Pipelines and status in (\"Ready for Dev\")"
           :limit 10
           :filename "jira-ready-for-dev")
     ;; My tickets
     (:jql " issuetype != Epic and assignee = \"Stig Brautaset\" and (status != Done or resolution changed after -7d)"
           :limit 10
           :filename "jira-my-tickets")
     ;; My epics
     (:jql " issuetype = Epic and assignee = \"Stig Brautaset\" and (status != Done or resolution changed after -7d)"
           :limit 10
           :filename "jira-my-epics"))))

#+end_src

** Compose Emails with Org mode

Very occasionally I want to create HTML mail. (For tables, for
example.) I then write my message using Org mode syntax and use
org-mime-htmlize.

#+BEGIN_SRC emacs-lisp
(use-package org-mime
  :bind (:map message-mode-map
              ("C-c h" . org-mime-htmlize))
  :custom
  (org-mime-preserve-breaks nil))
#+END_SRC

** Allow linking to emails in Notmuch

I don't like using my email inbox as a todo list. When I receive an
email I need to act on but /can't yet/ for some reason, I link to it
from my Org mode agenda and archive it. When Org agenda prompts me I
can click on the link and immediately get to the mail in my archive,
and can reply to it from there.

#+begin_src emacs-lisp
(use-package ol-notmuch
  :straight org-plus-contrib
  :after (org notmuch))
#+end_src

** Org drill (for learning new things)

I use org-drill for drilling music theory.

#+begin_src emacs-lisp
(use-package org-drill
  :custom
  (org-drill-add-random-noise-to-intervals-p t)
  (org-drill-adjust-intervals-for-early-and-late-repetitions-p t))
#+end_src

* Themes

** Load one theme at a time

For years I thought that theme switching in Emacs was broken---until
I read Greg Hendershott's [[http://www.greghendershott.com/2017/02/emacs-themes.html][emacs themes]] blog post. It turns out Emacs
supports /multiple themes being active at the same time/, which I'm
sure is convenient sometimes but becomes a right nuisance when
attempting to switch themes IMO. Add a utility function to disable
all currently enabled themes first.

#+BEGIN_SRC emacs-lisp
(defun sb/disable-all-themes ()
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(defun sb/load-theme (the-theme)
  "Enhance `load-theme' by first disabling enabled themes."
  (sb/disable-all-themes)
  (load-theme the-theme t))
#+END_SRC

** Hydra Theme Switching

Switch themes with Hydra! This loads all available themes and
presents a menu to let you switch between them. The theme switcher
is bound to =C-c w t=.

The switcher is, regretfully, not automatically updated when
installing new themes from the package selector menu, so you need to
evaluate this block again manually.

#+BEGIN_SRC emacs-lisp
(setq sb/hydra-selectors
      "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

(defun sb/load-theme-heads (themes)
  (cl-map 'list
          (lambda (a b)
            (list (char-to-string a)
                  `(sb/load-theme ',b)
                  (symbol-name b)))
          sb/hydra-selectors
          themes))

(defun sb/switch-theme ()
  (interactive)
  (call-interactively
   (eval `(defhydra sb/select-theme (:hint nil :color pink)
            "Select Theme"
            ,@(sb/load-theme-heads (custom-available-themes))
            ("DEL" (sb/disable-all-themes))
            ("RET" nil "done" :color blue)))))
#+END_SRC

** Default Theme

For years I've been using Leuven as my default theme. In general I
like white / light backgrounds, and I like how it has special styles
to make Org mode documents a pleasure to look at. However, right now
I'm experimenting with "Doom solarized light".

#+begin_src emacs-lisp
(use-package doom-themes
  :config
  (sb/load-theme 'leuven))
#+end_src

* Blogging
I create blog entries in a directory under =~/blog= and link to them
from the main index page. It has so far been a manual job, but I have
finally managed to create a function to automate it a bit.

** Helper function to get a value from Org keyword element

#+begin_src emacs-lisp
(defun sb/org-kw-get (key)
  "Return a lambda that takes an Org keyword element and returns
its :value property if its :key property matches `key'."
  `(lambda (kw)
     (if (equal ,key (org-element-property :key kw))
         (org-element-property :value kw))))
#+end_src

** Create blog post index entry

#+BEGIN_SRC emacs-lisp
(defun sb/blog-post-index-entry ()
  "Call in a blog post to get an entry suitable for linking to this
post from the index page."
  (interactive)
  (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
         (tree (org-element-parse-buffer))
         (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
         (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY"))))
    (with-temp-buffer
      (org-mode)
      (org-insert-heading)
      ;; Would have loved to use `org-insert-link' here but
      ;; I can't stop it from presenting a prompt.
      (insert "[[file:" path "][" title "]]\n"
              "#+include: " path "::abstract :only-contents t")
      ;; Need to go back to the first line to set tags, as
      ;; org-set-tags assumes point is on a headline.
      (goto-char (point-min))
      (org-set-tags categories)
      ;; Return the contents temporary buffer as a string *without properties*
      (copy-region-as-kill
       (point-min) (point-max)))))
#+END_SRC

** Create RSS entry

Creating an entry in the RSS feed is another manual step. This way I
can "soft publish" and publish to RSS separately from the index page.

#+begin_src emacs-lisp
(defun sb/blog-post-rss-entry ()
  "Call in a blog post to get an entry suitable for linking to this
post from the index page."
  (interactive)
  (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
         (tree (org-element-parse-buffer))
         (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
         (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY"))))
    (with-temp-buffer
      (org-mode)
      (org-insert-heading)
      (insert title "\n"
	      "#+include: " path)
      (org-set-property "RSS_PERMALINK"
                        (format "%s.html"
                                (file-name-sans-extension path)))
      (copy-region-as-kill
       (point-min) (point-max)))))
#+end_src

=org-rss= requires these to do its thing:

#+begin_src emacs-lisp
(require 'ox-icalendar)
(require 'ox-rss)
#+end_src

** Find drafts

#+begin_src emacs-lisp
(defun sb/find-drafts ()
  "Find org files in `~/blog/articles' not already linked from
              `~/blog/index.org'."
  (interactive)
  (let* ((prefix (expand-file-name "~/blog/"))
         (posts
          (directory-files-recursively
           (concat prefix "articles") ".org"))
         (index-contents (get-string-from-file (concat prefix "index.org")))
         (drafts (cl-remove-if (lambda (needle)
                                 (string-match
                                  (string-remove-prefix prefix needle)
                                  index-contents))
                               posts))
         (buffer-name "*blog drafts*"))
    (if drafts
        (progn
          (with-current-buffer (get-buffer-create buffer-name)
            (erase-buffer)
            (org-mode)
            (insert
             (mapconcat
              (lambda (entry)
                (format "- file:%s" entry))
              drafts
              "\n"))
            (buffer-string))
          (unless (get-buffer-window buffer-name t)
            (pop-to-buffer buffer-name nil t))
          (shrink-window-if-larger-than-buffer
           (get-buffer-window buffer-name)))
      (message "No drafts could be found!"))))
#+end_src

** Blog server

While noodling around with my blog locally I publish to =~/blog=
and use a simple Python server to host it.

#+begin_src emacs-lisp
(defun sb/blog-server ()
  (interactive)
  (start-process "Blog Server" "*blog server*"
                 "python3"
                 "-m" "http.server"
                 "--directory" (expand-file-name "~/blog/"))
  (message "Blog Server started"))
#+end_src

** Load Blog Publish Configuration

This needs clearing up.

#+begin_src emacs-lisp
(setq org-export-allow-bind-keywords t)

;; Don't use inline CSS for source code
(setq org-html-htmlize-output-type "css")

(setq sb/copyright "<p>Copyright &copy; 2001-2020 Stig Brautaset</p>")

(setq org-html-footnotes-section "<div id=\"footnotes\"><hr/><!--%s-->%s</div>")

(setq org-html-format-drawer-function
      (lambda (name content)
	(format "<div class=\"drawer %s\"><h6>%s</h6>%s</div>"
		(downcase name)
		(capitalize name)
		content)))

(setq org-html-home/up-format "
<div id=\"org-div-home-and-up\">
  <nav>
    <a accesskey=\"h\" href=\"%s\">Home</a>
    |
    <a accesskey=\"H\" href=\"%s\">About</a>
  </nav>
</div>
")

(setq common-properties
      '(:author "Stig Brautaset"
	:email "stig@brautaset.org"

	:section-numbers nil
	:time-stamp-file nil
	:with-drawers t
	:with-toc nil

	:html-doctype "html5"
	:html-head-include-default-style nil
	:html-head-include-scripts nil
	:html-html5-fancy t
	:html-metadata-timestamp-format "%e %B %Y"))

(setq org-publish-project-alist
      `(("www"
	 :components ("www-pages" "www-articles" "www-rss"))

        ("www-pages"
	 ,@common-properties
	 :base-directory "~/blog"
         :exclude ".*"
	 :html-postamble ,sb/copyright
	 :include ("index.org" "articles.org" "about.org" "style-demo.org")
	 :publishing-directory "~/blog"
	 :publishing-function org-html-publish-to-html)

	("www-articles"
	 ,@common-properties
	 :base-directory "~/blog/articles"
         :html-postamble ,sb/copyright
	 :publishing-directory "~/blog/articles"
	 :publishing-function org-html-publish-to-html
	 :recursive t)

	("www-rss"
	 ,@common-properties
	 :base-directory "~/blog"
	 :exclude ".*"
	 :html-link-home "https://www.brautaset.org"
	 :html-link-use-abs-url t
	 :include ("feed.org")
	 :publishing-directory "~/blog"
	 :publishing-function (org-rss-publish-to-rss)
	 :rss-image-url "https://www.brautaset.org/icon.png"
	 :rss-extension "xml")))

;; Turn off a harmless (but annoying) warning during publication.
;; ("Can't guess python-indent-offset, using defaults 4")
(setq python-indent-guess-indent-offset-verbose nil)
#+end_src

** Turn off annoying ~python-indent-offset~ during publication
Turn off a harmless (but annoying) warning during publication:

: Can't guess python-indent-offset, using defaults 4

#+begin_src emacs-lisp
(setq python-indent-guess-indent-offset-verbose nil)
#+end_src
