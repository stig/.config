#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t
#+PROPERTY: header-args:              :mkdirp yes
#+PROPERTY: header-args:emacs-lisp    :tangle ~/.emacs.d/init.el :results silent
#+STARTUP: content
* Introduction

  This is my Emacs configuration. Because I'm prone to forget what
  does what, my configuration is in the form of a [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]]
  document: prose, interspaced with code. The configuration snippets
  here are not copied-and-pasted from my config; rather this is the
  document where I edit my config, then I and /tangle/ the config into
  [[file:init.el][init.el]] and other config files by hitting =C-c C-v C-t=.

* Install Emacs & tools

  I install Emacs from https://emacsformacosx.com/

  I install (most) dependent tools using Nix:

  #+begin_src sh
    nix-env -i aspell aspellDicts.en awscli clojure curl ditaa editorconfig-core-c fluidsynth freepats gnused gnutls graphviz isync jq msmtp notmuch pinentry plantuml pwgen python3 sbt silver-searcher
  #+end_src

* Early Init

  Emacs 27 automatically loads =~/.emacs.d/early-init.el= before
  initialising GUI components, so it's a great place to turn off mouse
  interface etc to avoid flicker during startup.

** Disable splash screen, mouse interface & beeps

   I like to turn off the mouse interface early to avoid momentary
   display during launch. I also don't need to see a splash screen on
   every launch. Finally I do not like Emacs to beep at me; I prefer a
   visual bell.

   #+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/early-init.el
     (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
     (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
     (setq inhibit-startup-message t)
     (setq visible-bell t)
   #+END_SRC

** Emacs <27 Compatibility

   In older versions of Emacs we load ~early-init.el~ manually. Emacs 27
   also initialises packages before loading the user config, but older
   ones does not, requiring me to manually call =package-initialize= at
   this point.

   #+BEGIN_SRC emacs-lisp
    (if (not visible-bell)
	(progn
	  (load (expand-file-name "~/.emacs.d/early-init.el") t)
	  (require 'package)
	  (package-initialize)))
   #+END_SRC

** Introduce Myself

   In case something needs my name/email address.

   #+BEGIN_SRC emacs-lisp
   (setq user-full-name "Stig Brautaset")
   (setq user-mail-address "stig@brautaset.org")
   #+END_SRC

** Zsh

   This is how I set up Zsh. It feels weird to set it up here, but
   it's the best way I have found so far. The config snippets here are
   in the order Zsh reads them.

   #+begin_src sh :tangle ~/.zshenv
     # This config file is always read first by Zsh, for both interactive
     # and non-interactive shells. It's where we should set up PATH, etc.

     # Let our enviroment find binaries installed by Nix
     . ~/.nix-profile/etc/profile.d/nix.sh

     # Use the OS-provided Certificate file.
     export SSL_CERT_FILE=/etc/ssl/cert.pem
   #+end_src

   #+begin_src sh :tangle ~/.zshrc
     # This config file is for interactive shells.

     setopt INC_APPEND_HISTORY
     setopt HIST_IGNORE_ALL_DUPS

     export HISTFILE=~/.zsh_history
     export SAVEHIST=800
     export HISTSIZE=1000

     export EDITOR=emacsclient
   #+end_src

** Add Nix =site-lisp= directory to ~load-path~

   #+begin_src emacs-lisp
     (add-to-list 'load-path (expand-file-name "~/.nix-profile/share/emacs/site-lisp/"))
   #+end_src

* Configure the base install
** Add keybinding to join next line to this

   With cursor at any point in a line, hit =M-j= to move to the end, and
   delete the newline. Leave the cursor where the newline used to be.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-j")
                     (lambda ()
		       (interactive)
		       (join-line -1)))
   #+END_SRC

** Always use UTF-8 encoding

   Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

   #+BEGIN_SRC emacs-lisp
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+END_SRC

** Auto revert mode

   When files change on disk, revert the buffer automatically.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
   #+END_SRC

** Buffer-local regex search

   I like the =C-s= and =C-r= keybindings to mean "search forward/backward
   for this regex".

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-s") 'isearch-forward-regexp)
     (global-set-key (kbd "C-r") 'isearch-backward-regexp)
   #+END_SRC

** Clipboard

   These settings improve pasting behaviour with programs outside Emacs.

   Save clipboard text into kill ring before replacing them.

   #+BEGIN_SRC emacs-lisp
     (setq save-interprogram-paste-before-kill t)
   #+END_SRC

   Copying ("yanking") with the mouse copies at point, rather than where you
   click.

   #+BEGIN_SRC emacs-lisp
     (setq mouse-yank-at-point t)
   #+END_SRC

** Configure Aspell with British English dictionary

   #+BEGIN_SRC emacs-lisp
     (setq ispell-dictionary "british"
	   ispell-extra-args '("-W" "2" "--sug-mode=ultra"))
   #+END_SRC

   Configure aspell and let it find dictionaries:

   #+begin_src conf :tangle ~/.aspell.conf
   master british
   extra-dicts en-computers.rws
   add-extra-dicts en_GB-science.rws
   data-dir /Users/stig/.nix-profile/lib/aspell
   #+end_src

** Diary (Calendar) Functions

   Prefer YMD to the /crazy/ american MDY order.

   I schedule some things every weekday,
   so add a convenience function for that.

   #+BEGIN_SRC emacs-lisp
     (setq calendar-date-style 'iso)

     (defun sb/weekday-p (date)
       "Is `date' a weekday?"
       (memq (calendar-day-of-week date) '(1 2 3 4 5)))
   #+END_SRC

** Disable kill-emacs

   Disable =s-q= (=kill-emacs=) as it is too close to =M-q= which I use for
   reflowing text.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-q") nil)
   #+END_SRC

** Don't store backup files next to originals

   I don't like backup files (those dreaded =foo~= ones) all over my disk.
   This places them in =~/.emacs.d/backups=.

   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
   #+END_SRC

** Ediff

   Sometimes I have to resolve conflicts. I use Ediff, which I
   (usually) launch from Magit.

*** Automatically Unfold Org files

    This snippet makes sure that Org buffers don't start folded, as
    ediff is rather useless in that case. (Credit: Oleh Krehel on
    emacs-orgmode mailing list.)

    #+BEGIN_SRC emacs-lisp
      (defun sb/ediff-prepare-buffer ()
	(when (memq major-mode '(org-mode emacs-lisp-mode))
	  (outline-show-all)))

      (add-hook 'ediff-prepare-buffer-hook #'sb/ediff-prepare-buffer)
    #+END_SRC

*** Picking /both/ sides in a conflict

    If both branches add an entry to a list I may want to pick *both*
    sides. This adds =d= as a shortcut to do that. ([[http://stackoverflow.com/a/29757750/5950][Credits]].) I can use
    =~= to swap the A and B buffers, which lets me choose A then B, /or/ B
    then A.

    #+BEGIN_SRC emacs-lisp
      (defun sb/ediff-copy-both-to-C ()
	(interactive)
	(ediff-copy-diff ediff-current-difference nil 'C nil
			 (concat
			  (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
			  (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

      (defun sb/add-d-to-ediff-mode-map ()
	(define-key ediff-mode-map "d" 'sb/ediff-copy-both-to-C))

      (add-hook 'ediff-keymap-setup-hook 'sb/add-d-to-ediff-mode-map)
    #+END_SRC

** End all files in a newline

   All files should end in a newline. Insert one if there isn't one already.

   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC

** Eshell

   I have started using /Eshell/. It is close to magic. There's not a lot of
   setup (it has its own [[file:eshell/alias][alias file]]), but I've got a keybinding to bring up
   eshell quickly. This launches eshell if it is not already running, or
   switches to it if it is.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c s") 'eshell)

     ;; This helps with aws cli commands, and nix-env --help, a bit
     (setenv "PAGER" "cat")
   #+END_SRC

   Eshell is great, and its Tramp integration allows me to open remote files
   in local Emacs seamlessly with the =find-file= command. (Which I have
   aliased to =ff=.) Eshell also makes sure that my shell behaves the same,
   and has the same config, whether I am on a local machine or a remote one.

** Highlight & deal with whitespace annoyances

   This highlights certain whitespace annoyances, and adds a key binding to
   clean it up.

   #+BEGIN_SRC emacs-lisp
     (require 'whitespace)
     (setq whitespace-style '(face empty tabs trailing))
     (global-whitespace-mode t)

     (global-set-key (kbd "C-c w") 'whitespace-cleanup)
   #+END_SRC

** I like big fonts and I cannot lie

   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'default nil :height 150)
   #+END_SRC

** IRC

   But /of course/ Emacs has a built-in IRC client. In fact it has two! But I
   digress. Let's use the oldest one, and configure it slightly.

   #+BEGIN_SRC emacs-lisp
   (setq rcirc-default-nick "stigbra")
   (setq rcirc-default-full-name "Stig Brautaset")
   #+END_SRC

** Make 'y' and 'n' satisfy prompts

   Answering just 'y' or 'n' will do, rather than having to spell out "yes"
   or "no".

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Make mouse scrolling smoother

   The adaptive mouse scrolling is far, far too quick so let's turn that off.

   #+BEGIN_SRC emacs-lisp
   (setq mouse-wheel-progressive-speed nil)
   (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))))
   #+END_SRC

** Modifier keys on OS X

   Set up the modifier keys the way that best fits my keyboard.

   #+BEGIN_SRC emacs-lisp
     ;; Both Command keys are 'Meta'
     (setq mac-right-command-modifier 'meta
	   mac-command-modifier 'meta)

     ;; Option or Alt is 'Super'
     (setq mac-option-modifier 'super)

     ;; Right Alt (option) can be used to enter symbols like em dashes '—' and euros '€' and stuff.
     (setq mac-right-option-modifier 'nil)

     (setq ns-function-modifier 'hyper)
   #+END_SRC

** Put Custom settings in a separate file

   I prefer to code my configuration, but sometimes Custom settings are good
   enough. I prefer that such settings live in a separate file though. Load
   that file if it exists.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (if (file-exists-p custom-file)
         (load custom-file))
   #+END_SRC

** Running tests

   Add a convenient keybinding for running tests interactively.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x t") 'ert)
   #+END_SRC

** Save minibuffer history

   This allows us to "tap up" in the minibuffer to recall previous items,
   even from a previous session.

   #+BEGIN_SRC emacs-lisp
     (savehist-mode 1)
   #+END_SRC

** Save my place in each file

   It's nice if Emacs knows where I was last time I opened a file.

   #+BEGIN_SRC emacs-lisp
     (setq-default save-place t)
     (setq save-place-file (concat user-emacs-directory "places"))
   #+END_SRC

** Show Matching parens

   This is extremely useful. Put the mark on a paren (any of =()[]{}=,
   actually) and Emacs shows the matching closing/opening one.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode 1)
   #+END_SRC

** Support for fullscreen

   I like to run apps in fullscreen mode. Sometimes it's useful to be
   able to toggle it on or off, which this function does. I found it
   at the [[https://www.emacswiki.org/emacs/FullScreen#toc26][EmacsWiki Fullscreen page]].

   #+BEGIN_SRC emacs-lisp
     (defun my-toggle-fullscreen ()
       "Toggle full screen"
       (interactive)
       (set-frame-parameter
        nil 'fullscreen
        (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

     (global-set-key (kbd "M-<f11>") 'my-toggle-fullscreen)
   #+END_SRC

** Toggle Window Split function

   Sometimes a window is split horizontally, and you would prefer
   vertically. Or vice versa. This function can help! Just don't ask me how
   it works: I found it on StackOverflow. (I think. Again.)

   #+BEGIN_SRC emacs-lisp
     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
		       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
	       (funcall splitter)
	       (if this-win-2nd (other-window 1))
	       (set-window-buffer (selected-window) this-win-buffer)
	       (set-window-buffer (next-window) next-win-buffer)
	       (select-window first-win)
	       (if this-win-2nd (other-window 1))))))

     (define-key ctl-x-4-map "t" 'toggle-window-split)
   #+END_SRC

** Transparently open compressed files

   I *do* like it when Emacs transparently opens compressed files. It gives
   me the warm fuzzies.

   #+BEGIN_SRC emacs-lisp
     (auto-compression-mode t)
   #+END_SRC

** Unfill paragraphs and regions

   The default binding for =M-q= fills a paragraph. Very good. But
   sometimes I want to /unfill/[fn:: Particularly when editing markdown
   that is going to end up on GitHub, as otherwise the result has lots
   of hard linebreaks. This happens every time I edit a PR description
   in Magit, for example.]. [[https://stackoverflow.com/a/2478549/5950][Credit]].

   #+begin_src emacs-lisp
     (defun sb/unfill-paragraph ()
       (interactive)
       (let ((fill-column (point-max)))
	 (fill-paragraph nil)))

     (defun sb/fill-or-unfill-paragraph (arg)
       "Fill a paragraph. If called with a `C-u' prefix, /unfill/ a paragraph."
       (interactive "P")
       (if arg
	   (sb/unfill-paragraph)
	 (fill-paragraph)))

     (bind-key "M-q" 'sb/fill-or-unfill-paragraph)

     (defun sb/unfill-region ()
       (interactive)
       (let ((fill-column (point-max)))
	 (fill-region (region-beginning) (region-end) nil)))
   #+end_src

** Visual line mode / word wrapping

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'visual-line-mode)
   #+END_SRC

** Themes
*** Load one theme at a time

    For years I thought that theme switching in Emacs was broken---until
    I read Greg Hendershott's [[http://www.greghendershott.com/2017/02/emacs-themes.html][emacs themes]] blog post. It turns out Emacs
    supports /multiple themes being active at the same time/, which I'm
    sure is convenient sometimes but becomes a right nuisance when
    attempting to switch themes IMO. Add a utility function to disable
    all currently enabled themes first.

    #+BEGIN_SRC emacs-lisp
      (defun sb/disable-all-themes ()
	(interactive)
	(mapc #'disable-theme custom-enabled-themes))

      (defun sb/load-theme (theme)
	"Enhance `load-theme' by first disabling enabled themes."
	(sb/disable-all-themes)
	(load-theme theme))
    #+END_SRC

*** Hydra Theme Switching

    Switch themes with Hydra! This loads all available themes and
    presents a menu to let you switch between them. The theme switcher
    is bound to =C-c w t=.

    The switcher is, regretfully, not automatically updated when
    installing new themes from the package selector menu, so you need to
    evaluate this block again manually.

    #+BEGIN_SRC emacs-lisp
      (setq sb/hydra-selectors
	    "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

      (defun sb/sort-themes (themes)
	(sort themes (lambda (a b) (string< (symbol-name a) (symbol-name b)))))

      (defun sb/load-theme-heads (themes)
	(mapcar* (lambda (a b)
		   (list (char-to-string a) `(sb/load-theme ',b) (symbol-name b)))
		 sb/hydra-selectors themes))

      (defun sb/switch-theme ()
	(interactive)
	(call-interactively
	 (eval `(defhydra sb/select-themes (:hint nil :color pink)
		  "Select Theme"
		  ,@(sb/load-theme-heads (sb/sort-themes (custom-available-themes)))
		  ("DEL" (sb/disable-all-themes))
		  ("RET" nil "done" :color blue)))))
    #+END_SRC

* Configure ELPA Packages
** Initialise the Package Manager
*** Initialize ~package-archives~

    We need to add the URLs of the package archives we want to use. I
    install most packages via Melpa Stable Nix, but some from unstable.
    I need the =org= archive because I use some =org-contrib= stuff that
    doesn't make it into Emacs proper.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
      (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
      (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
    #+END_SRC

*** Install ~use-package~

    Install ~use-package~ and configure it to install packages from stable
    melpa archive by default.

    #+begin_src emacs-lisp
      ;; Automatically :ensure each use-package.
      (setq use-package-always-ensure t)

      ;; Default value for :pin in each use-package.
      (setq use-package-always-pin "melpa-stable")

      ;; Bootstrap use-package
      (unless (package-installed-p 'use-package)
	(package-refresh-contents)
	(package-install 'use-package))
      (require 'use-package)
    #+end_src

** Install & Configure Packages
*** Ace Window

    #+begin_src emacs-lisp
    (use-package ace-window
      :bind ("M-`" . ace-window))
    #+end_src
*** Ag (The Silver Searcher)

    I use =ag= for searching a lot in Emacs. Its "writable grep"
    companion mode is pretty close to magic. When in a buffer showing
    ag results, try hitting =C-c C-p=--this lets you /edit the results of
    the search right from the ag results buffer!/ Just hit =C-x C-s= to
    save the results.

    If you hit =C-c C-p= while already in writable grep mode you can
    delete the entire matched line by hitting =C-c C-d=.

    #+BEGIN_SRC emacs-lisp
      (use-package ag :pin melpa)
      (use-package wgrep :pin melpa)
      (use-package wgrep-ag :pin melpa)

      ;; This fixes the last group not being editable until it's fixed
      ;; upstream, cf https://github.com/mhayashi1120/Emacs-wgrep/pull/61
      (eval-after-load "wgrep-ag"
	'(defun wgrep-ag-prepare-header/footer ()
	   (save-excursion
	     (goto-char (point-min))
	     ;; Look for the first useful result line.
	     (if (re-search-forward (concat wgrep-ag-grouped-result-file-regexp
					    "\\|"
					    wgrep-ag-ungrouped-result-regexp))
		 (add-text-properties (point-min) (line-beginning-position)
				      '(read-only t wgrep-header t))
	       ;; No results in this buffer, let's mark the whole thing as
	       ;; header.
	       (add-text-properties (point-min) (point-max)
				    '(read-only t wgrep-header t)))

	     ;; OK, header dealt with. Now let's try find the footer.
	     (goto-char (point-max))
	     (re-search-backward "^\\(?:-[^:]+?:[[:digit:]]+:[[:digit:]]+:\\)" nil t)
	     ;; Point is now at the beginning of the result nearest the end
	     ;; of the buffer, AKA the last result.  Move to the start of
	     ;; the line after the last result, and mark everything from
	     ;; that line forward as wgrep-footer.  If we can't move to the
	     ;; line after the last line then there apparently is no
	     ;; footer.
	     (when (zerop (forward-line 1))
	       (add-text-properties (point) (point-max)
				    '(read-only t wgrep-footer t))))))

      (add-hook 'ag-mode-hook 'wgrep-ag-setup)
    #+END_SRC

*** Aggressive Indent

    I like to keep my code indented properly at all times. Aggressive-indent
    helps ensure this. Turn it on for lisp modes.

    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
	:init
	(add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
	(add-hook 'clojure-mode-hook #'aggressive-indent-mode)
	(add-hook 'css-mode-hook #'aggressive-indent-mode))
    #+END_SRC

*** Auto commit

    In some projects (notably, my Org/Agenda setup) I want to
    automatically commit when editing files.

    #+BEGIN_SRC emacs-lisp
      (use-package git-auto-commit-mode)
    #+END_SRC

*** Beacon

    Highlight my cursor when scrolling

    #+begin_src emacs-lisp
    (use-package beacon :pin gnu)
    #+end_src

*** Blog server

    While noodling around with my blog locally I publish to
    =~/public_html= and use a simple Python server to host it.
    Previously I launched it in an Eshell buffer, but it's nicer to
    run it as an asynchronous command tied to a buffer.

    #+begin_src emacs-lisp
      (defun sb/blog-server ()
	(interactive)
	(start-process "Blog Server" "*blog server*"
		       "python3"
		       "-m" "http.server"
		       "--directory" (expand-file-name "~/public_html/"))
	(message "Blog Server started"))
    #+end_src
*** Clojure

    #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode)
     (use-package clojure-mode-extra-font-locking)
     (use-package cider)
     (use-package clj-refactor)
    #+END_SRC

*** Company

    Auto-complete of code and prose.

    #+BEGIN_SRC emacs-lisp
    (use-package company
      :init
      ;; https://emacs.stackexchange.com/a/10838
      (setq company-dabbrev-downcase nil)
      :config
      (global-company-mode))
    #+END_SRC

*** Counsel

    This provides =counsel-find-file=, among others.

    #+begin_src emacs-lisp
    (use-package amx) ;; make counsel-M-x work the way I like
    (use-package counsel)
    (counsel-mode 1)
    #+end_src

*** Editorconfig

    Some projects I touch, particularly at work, use [[http://editorconfig.org][editorconfig]] to set up
    their indentation and file format preferences.

    #+BEGIN_SRC emacs-lisp
      (use-package editorconfig
	:init
	(setq editorconfig-exclude-modes '(org-mode))
	(setq editorconfig-mode-lighter " EC")
	:config
	(editorconfig-mode))
    #+END_SRC

*** Elfeed

    I use custom.el for the actual feeds.

    #+BEGIN_SRC emacs-lisp
      (use-package elfeed
	:bind ("C-x w" . elfeed)
	:config
	(defalias 'elfeed-toggle-star
	  (elfeed-expose #'elfeed-search-toggle-all 'star))

	(eval-after-load 'elfeed-search
	  '(define-key elfeed-search-mode-map (kbd "m") 'elfeed-toggle-star)))
    #+END_SRC

*** Elpy

    I'll try Elpy first because of its touted refactoring support.

    #+BEGIN_SRC emacs-lisp :noweb yes
     (use-package elpy
       :config
       (elpy-enable))
    #+END_SRC

*** Email

    Because I like to use Emacs for writing, I like to use it for email
    too. I tried Gnus, but don't really read news so it felt a bit
    overkill. I've been using [[http://www.djcbsoftware.nl/code/mu/][mu4e]] for a while, but I'm slightly
    annoyed by some of its quirks (particularly interacting with Gmail,
    which I have to use for work) so thought I'd try [[https://notmuchmail.org][notmuch]].

    I use [[http://msmtp.sourceforge.net/][msmtp]] for sending email, and [[http://isync.sourceforge.net][mbsync]] for syncing IMAP messages
    between my local machine and upstream servers.

**** Download email with mbsync

     I used to use OfflineIMAP for this, but mbsync (from the isync suite) seems
     faster and doesn't have this annoying db outside of the Maildir to keep in
     sync.

***** mbsync configuration

      #+BEGIN_SRC conf :tangle ~/.mbsyncrc
	IMAPAccount gandi
	Host mail.gandi.net
	User stig@brautaset.org
	SSLType IMAPS
	AuthMechs LOGIN
	PassCmd "security find-generic-password -s mbsync-gandi-password -w"
	# To rotate:
	# > security delete-generic-password -s mbsync-gandi-password
	# > security add-generic-password -a stig@brautaset.org -s mbsync-gandi-password -w APP-SPECIFIC-PASSWORD

	IMAPStore gandi-remote
	Account gandi

	MaildirStore gandi-local
	AltMap yes
	Path ~/Mail/Gandi/
	Inbox ~/Mail/Gandi/INBOX
	Trash trash

	Channel gandi-inbox
	Master :gandi-remote:
	Slave :gandi-local:
	Create Slave
	SyncState *

	Channel gandi-sent
	Master :gandi-remote:Sent
	Slave :gandi-local:sent
	Create Slave
	SyncState *

	Channel gandi-org-mode
	Master :gandi-remote:org-mode
	Slave :gandi-local:org-mode
	Create Slave
	SyncState *
	MaxMessages 500
	ExpireUnread yes
	Expunge Both

	Channel gandi-lilypond
	Master :gandi-remote:lilypond
	Slave :gandi-local:lilypond
	Create Slave
	SyncState *
	MaxMessages 500
	ExpireUnread yes
	Expunge Both

	Channel gandi-clojure
	Master :gandi-remote:clojure
	Slave :gandi-local:clojure
	Create Slave
	SyncState *
	MaxMessages 500
	ExpireUnread yes
	Expunge Both

	Channel gandi-tuls
	Master :gandi-remote:tuls
	Slave :gandi-local:tuls
	Create Slave
	SyncState *
	MaxMessages 500
	Expunge Both

	Channel gandi-archive
	Master :gandi-remote:archive
	Slave :gandi-local:archive
	Create Slave
	SyncState *

	# ACCOUNT INFORMATION
	IMAPAccount gmail
	Host imap.gmail.com
	User sbrautaset@laterpay.net
	Timeout 60
	PassCmd "security find-generic-password -s mbsync-gmail-password -w"
	AuthMechs PLAIN
	SSLType IMAPS
	CertificateFile /etc/ssl/cert.pem

	# REMOTE STORAGE (USE THE IMAP ACCOUNT SPECIFIED ABOVE)
	IMAPStore gmail-remote
	Account gmail

	# LOCAL STORAGE (CREATE DIRECTORIES with mkdir -p Mail/gmail)
	MaildirStore gmail-local
	AltMap yes
	Path ~/Mail/Work/
	Inbox ~/Mail/Work/INBOX
	Trash trash

	Channel gmail-inbox
	Master :gmail-remote:
	Slave :gmail-local:
	Create Slave
	SyncState *

	Channel gmail-archive
	Master :gmail-remote:"[Gmail]/All Mail"
	Slave :gmail-local:archive
	Create Slave
	SyncState *

	Channel gmail-sent
	Master :gmail-remote:"[Gmail]/Sent Mail"
	Slave :gmail-local:sent
	Create Slave
	SyncState *

	Group inboxes gandi-inbox gmail-inbox
      #+END_SRC

***** Invoke mbsync

      I used to run this periodically, but I've noticed I usually run
      it interactively just before checking mail, so let's just go with
      that. It's not abnormal for this to take 30 seconds, but usually
      it's less.

      #+BEGIN_SRC emacs-lisp
	(defun sb/mbsync (&rest group)
	  (interactive)
	  (let ((args (if group (mapconcat 'identity group " ") "--all")))
	    (message "mbsync %s: starting.." args)
	    (start-process "mbsync" "*mbsync*" "mbsync" "--verbose" "--quiet" args))))
      #+END_SRC

**** Reading mail with NotMuch

     After installing NotMuch I ran =notmuch setup= to configure it.
     Then I ran =notmuch new= to index my existing mail. (This was
     already in =~/Maildir/= since I've been using mu4e before.) You can
     also set config values independently. That is my preference now,
     as I can do everything from this file.

     #+begin_src sh :results silent
     notmuch config set database.path ~/Mail

     notmuch config set user.name "Stig Brautaset"

     notmuch config set user.primary_email "stig@brautaset.org"

     notmuch config set user.other_email 'sbrautaset@laterpay.net;stig.brautaset@icloud.com;stigbrau@start.no;stigbrau@online.no;stig.brautaset@me.com;S.Brautaset@westminster.ac.uk;Stig.Brautaset@MorganStanley.com;stig.brautaset@ktsplc.com'

     notmuch config set new.tags 'new;unread;inbox'

     notmuch config set new.ignore '.mbsyncstate;.mbsyncstate.journal;.mbsyncstate.lock;.mbsyncstate.new;.uidvalidity;.isyncuidmap.db'

     notmuch config set search.exclude_tags 'deleted;spam;draft'
     #+end_src

     We can now read the config back in, to verify our change.

     #+BEGIN_SRC sh :results output replace :exports results :tangle no
     notmuch config list
     #+END_SRC

     #+RESULTS:
     #+begin_example
     database.path=/Users/stig/Mail
     user.name=Stig Brautaset
     user.primary_email=stig@brautaset.org
     user.other_email=sbrautaset@laterpay.net;stig.brautaset@icloud.com;stigbrau@start.no;stigbrau@online.no;stig.brautaset@me.com;S.Brautaset@westminster.ac.uk;Stig.Brautaset@MorganStanley.com;stig.brautaset@ktsplc.com
     new.tags=new;unread;inbox
     new.ignore=.mbsyncstate;.mbsyncstate.journal;.mbsyncstate.lock;.mbsyncstate.new;.uidvalidity;.isyncuidmap.db
     search.exclude_tags=deleted;spam;draft
     maildir.synchronize_flags=true
     built_with.compact=true
     built_with.field_processor=true
     built_with.retry_lock=true
     #+end_example

***** Configuring Notmuch inside Emacs

      Installing Notmuch (with brew/nix/apt/yum) should also install
      the =notmuch.el= Emacs package into somewhere Emacs can find it.
      (If not you might need to add its directory to your ~load-path~.) I
      then launched it with =M-x notmuch=.

      With that out of the way Notmuch works pretty well for me out of
      the box. Mainly I set up a keybinding to quickly bring it up.
      Its threading and MIME handling appears a lot better than mu4e,
      from a cursory glance.

      I don't like using my email inbox as a todo list, so when I
      receive an email I need to act on but /can't yet/ for some reason,
      I link to it from my Org mode agenda and archive it. When Org
      agenda prompts me I can click on the link and immediately get to
      the mail in my archive, and can reply to it from there.

      NotMuch doesn't have built-in support for multiple profiles.
      (Mu4e does, but configuring it was difficult, IMO.) I tried
      using "gnus-alias" with Notmuch, but couldn't get it to work
      either. (I'm perhaps just not smart enough to deal with multiple
      identities!) Thus I'm going with a simpler scheme now: reply to
      the address they write to, and base my signature on the from
      address.

      For personal mail I save a copy into my sent mail folder. For
      work I rely on Gmail to automatically copy outgoing mail to my
      sent folder.

      #+BEGIN_SRC emacs-lisp
	(require 'notmuch)

	;; A function to launch mbsync in the background whenever I bring up
	;; Notmuch, and automatically refresh the current buffer when done.
	;; To save time, request that mbsync only checks inboxes.
	(defun sb/notmuch (arg)
	  (interactive "P")
	  (set-process-sentinel
	   (sb/mbsync (if arg "--all" "inboxes"))
	   (lambda (proc state)
	     (message nil) ;; clear minibuffer
	     (notmuch))))

	(bind-key "C-x m" 'sb/notmuch)

	(bind-key "M-]" 'notmuch-cycle-notmuch-buffers)
	(add-hook 'notmuch-message-mode-hook #'turn-off-auto-fill)

	;; Allow linking to NotMuch messages from Org mode
	(require 'org-notmuch)

	(defun sb/message-signature-setup-hook ()
	  (setq message-signature-file
		(if (string-match "laterpay" (mail-fetch-field "from"))
		    "~/.signature.work" nil))
	  (message "Selected %s for signature" message-signature-file))

	(add-hook 'message-signature-setup-hook
		  'sb/message-signature-setup-hook)

	(setq notmuch-fcc-dirs
	      '(("stig@brautaset.org" . "Gandi/sent +sent -unread -inbox")))
      #+END_SRC


***** Remove "new" tag & obsolete drafts

      Remove the =new= tag from any messages just before refreshing.  Do
      this in a =pre-hook= so we can use the new =new= tag to optimise
      further tagging in the =post-hook= below.

      #+BEGIN_SRC sh :tangle ~/Mail/.notmuch/hooks/pre-new :shebang #!/bin/zsh :tangle-mode (identity #o755)
	notmuch tag -new -- tag:new
	notmuch search --output files tag:draft and tag:deleted | xargs rm
      #+END_SRC

***** Tag new messages

      Notmuch assigns the =new= tag when it first sees a message, so we
      can use it to limit the search space for further tagging.

      #+BEGIN_SRC sh :tangle ~/Mail/.notmuch/hooks/post-new :shebang #!/bin/zsh :tangle-mode (identity #o755)
	notmuch tag --batch <<EOF
	# Tag previously unseen messages
	+work -- path:/Work/ and tag:new
	+sent -- path:/sent/ and tag:new
	-inbox -- path:/archive/ and tag:new

	# Add specific tags for mailing lists, and remove from inbox
	+lists +org-mode -inbox -- path:/org-mode/ and tag:new
	+lists +lilypond -inbox -- path:/lilypond/ and tag:new
	+lists +clojure -inbox -- path:/clojure/ and tag:new

	# V. low volume lists gets to stay in inbox
	+lists +tuls -- path:/tuls/ and tag:new
	EOF
      #+END_SRC


***** Reading HTML mail

      I normally use a fullscreen window, but I don't like reading
      HTML mails with lines running all the way across. Thus I prefer
      linebreaks roughly every 80 characters.

      #+begin_src emacs-lisp
      (setq shr-width 80)
      #+end_src

**** Compose Emails with Org mode

     Very occasionally I want to create HTML mail. (For tables, for
     example.) I then write my message using Org mode syntax and use
     org-mime-htmlize.

     #+BEGIN_SRC emacs-lisp
       (use-package org-mime
	 :bind (:map message-mode-map
		     ("C-c h" . org-mime-htmlize))
	 :init
	 (setq org-mime-preserve-breaks nil))
     #+END_SRC

**** Sending mail with MSMTP

     MSMTP's configuration is really simple, and it will detect the account to
     use from the "from" address. Let's go!

     MSMTP obtains passwords from the system Keychain. See the [[http://msmtp.sourceforge.net/doc/msmtp.html#Authentication][Authentication]]
     section in the msmtp documentation for details.

     #+BEGIN_SRC conf :tangle ~/.msmtprc
       defaults

       port 587
       tls on
       tls_trust_file /etc/ssl/cert.pem
       auth on

       ###############
       account private

       from stig@brautaset.org
       host mail.gandi.net
       user stig@brautaset.org

       #############
       account icloud

       from stig.brautaset@icloud.com
       host smtp.mail.me.com
       user stig.brautaset@icloud.com

       ############
       account work

       from sbrautaset@laterpay.net
       host smtp.gmail.com
       user sbrautaset@laterpay.net

       #########################
       account default : private
     #+END_SRC

     Finally we have to tell Emacs to use msmtp to send mail:

     #+BEGIN_SRC emacs-lisp
       (setq message-send-mail-function 'message-send-mail-with-sendmail
             sendmail-program "msmtp"
	     message-sendmail-envelope-from 'header
	     mail-envelope-from 'header
	     mail-specify-envelope-from t)
     #+END_SRC

***** Don't keep buffer for sent messages

      #+BEGIN_SRC emacs-lisp
      (setq message-kill-buffer-on-exit t)
      #+END_SRC

*** Gists

    Viewing & editing gists in Emacs? Sure! I want that!

    #+BEGIN_SRC emacs-lisp
      (use-package gist
	:bind (("C-x g l" . gist-list)
	       ("C-x g c" . gist-region-or-buffer-private))
	:init
	(setq gist-ask-for-description t))
    #+END_SRC

*** Git Link

    Link to file location on GitHub/Bitbucket/GitLab/...

    #+BEGIN_SRC emacs-lisp
      (use-package git-link
	:bind ("C-c g l" . git-link))
    #+END_SRC

*** Graphviz

    I sometimes use Graphviz to create diagrams.

    I also have to tell Emacs how to launch GraphViz.

    #+BEGIN_SRC emacs-lisp
      (use-package graphviz-dot-mode
	:bind ("C-c C-p" . graphviz-dot-preview))
    #+END_SRC

*** Iedit

    Edit multiple symbols in one go. Similar in some respects to
    Multiple Cursors, but seems a little more light-weight.

    #+begin_src emacs-lisp
    (use-package iedit :pin melpa)
    #+end_src

*** Ivy

    I've long been a happy Helm user, but it confuses me (and is slow!)
    in some situations so I thought I'd try again to see if Ivy fares
    any better.

    #+begin_src emacs-lisp
      (use-package ivy
	:pin melpa
	:demand
	:config
	(setq ivy-use-virtual-buffers t
	      ivy-count-format "%d/%d "))
      (ivy-mode 1)

      ;; This should apparently allow opening multiple files from
      ;; ivy-find-file.
      (use-package ivy-hydra
	:pin melpa)
    #+end_src

*** LilyPond

    With Nix I am not able to install LilyPond, but I can install it
    via a download from https://lilypond.org.

    #+begin_src emacs-lisp
      (use-package lilypond-mode
	:load-path "/Applications/LilyPond.app/Contents/Resources/share/emacs/site-lisp"
	:mode (("\\.ily\\'" . LilyPond-mode)
	       ("\\.ly\\'" . LilyPond-mode))
	:init
	(setq LilyPond-midi-command "playmidi")
	(add-hook 'LilyPond-mode-hook (lambda () (turn-on-font-lock))))
    #+end_src

*** Magit

    I use [[http://magit.vc][Magit]] all day. If you use git a lot it's possibly worth switching to
    Emacs just for it. It is excellent. I bind =M-m= to =magit-status=, which is
    the main entry point for the mode.

    Forge is an extension to Magit that interacts with GitHub / GitLab etc.

    #+BEGIN_SRC emacs-lisp
      (use-package transient :pin melpa)
      (use-package magit
	:pin melpa
	:bind ("M-m" . magit-status))

      (use-package forge :pin melpa)
      (use-package magit-org-todos :pin melpa)
      (use-package magit-todos :pin melpa)
    #+END_SRC

*** Markdown

    I'm a sucker for lists, and I want to be able to reorder list items
    easily and have them renumbered automatically.

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
	:pin melpa
	:bind (("M-<up>" . markdown-move-list-item-up)
	       ("M-<down>" . markdown-move-list-item-down)))
    #+END_SRC
*** Multiple Cursors

    This package is another one of those near-magical ones. It allows me to do
    multiple edits in the same buffer, using several cursors. You can think of
    it as an interactive macro, where you can constantly see what's being done.

    #+BEGIN_SRC emacs-lisp
      (use-package multiple-cursors

	:bind (("C-c M-e" . mc/edit-lines)
               ("C-c M-a" . mc/mark-all-dwim)
               ("s-n" . mc/mark-next-like-this)
               ("s-p" . mc/mark-previous-like-this)))
    #+END_SRC

*** Nix

    Some modules useful for Nix.

    #+BEGIN_SRC emacs-lisp
      (use-package nix-mode :pin melpa)
      (use-package nix-sandbox :pin melpa)
    #+END_SRC

*** Org mode

    I now use Org mode for all writing I initiate. The Emacs org mode's support
    for tables, TOC, footnotes, TODO and agenda items makes it an easy choice.
    Gists and GitHub READMEs support Org mode too, and I can export to other
    formats including if I want.

    To avoid having one gigantic section, this file uses NOWEB syntax to weave
    together config snippets.

    The particular version of package I use is annoying to install because the
    installed package has a different name from what you would use in your
    config. However, =use-package= supports this by passing the name of the
    package to install as the value to =:ensure=.

    The Org manual expects the =C-c {l,a,c,b}= keybindings to be
    available in any mode, so define them globally. I prefer to follow
    conventions. It makes reading the manual and tutorials a lot
    easier!

    #+BEGIN_SRC emacs-lisp
      (use-package org
	:ensure org-plus-contrib
	:pin org
	:bind (("C-c l" . org-store-link)
	       ("C-c a" . org-agenda)
	       ("C-c c" . org-capture)
	       ("C-c b" . org-iswitchb)
	       ("C-x C-<return>" . org-insert-subheading)
	       ("C-S-<return>" . org-insert-todo-subheading)
	       :map org-mode-map
	       ("C-c x" . mu4e-compose-mode)
	       ("C-n" . org-next-link)
	       ("C-p" . org-previous-link))

	:mode (("\\.org\\'" . org-mode)
	       ("\\.org_archive\\'" . org-mode))

	:init

	(setq org-link-file-path-type 'relative)

	;; When hitting C-c C-z to take a note, always put it in the LOGBOOK drawer
	(setq org-log-into-drawer t)

	;; Sometimes I accidentally edit non-visible parts of org document. This
	;; helps, apparently.
	(setq org-catch-invisible-edits 'show-and-error)

	;; If running interactively, I want export to copy to the kill-ring
	(setq org-export-copy-to-kill-ring 'if-interactive)

	(setq org-hide-emphasis-markers t)

	(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
    #+END_SRC

**** Agenda

     #+BEGIN_SRC emacs-lisp
       ;; Include Calendar/Diary information in Agenda
       (setq org-agenda-include-diary t)

       ;; I don't rely on many properties, so this should speed up my Agenda
       ;; view, according to http://orgmode.org/worg/agenda-optimization.html
       (setq org-agenda-ignore-properties '(effort appt stats))

       ;; I don't want to show these in the TODO list,
       ;; because they'll show in the Agenda anyway.
       (setq org-agenda-todo-ignore-scheduled 'future
	     org-agenda-todo-ignore-deadlines 'far
	     org-agenda-todo-ignore-timestamp 'future)

       (setq org-agenda-skip-deadline-prewarning-if-scheduled t
	     org-agenda-skip-scheduled-if-deadline-is-shown 'not-today)

       ;; Make tags-todo search ignore scheduled items too
       (setq org-agenda-tags-todo-honor-ignore-options t)

       (setq org-log-done 'time)

       (setq org-stuck-projects '("/PROJ" ("TODO" "NEXT" "WAITING") nil ""))

       (setq org-agenda-custom-commands
	     '(("d" "Day Agenda"
		((agenda "" ((org-agenda-span 'day)))))
	       ("S" "Someday"
		((todo "PROJ"
		       ((org-agenda-files '("~/org/Someday.org"))))
		 (todo "TODO"
		       ((org-agenda-todo-list-sublevels nil)
			(org-agenda-files '("~/org/Someday.org"))))))))
     #+END_SRC

**** Refiling

     I got all of this from [[https://www.youtube.com/watch?v=ECWtf6mAi9k][this YouTube video]].

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-targets '((nil . (:level . 1))
				  (org-agenda-files . (:maxlevel . 2))
				  (org-agenda-files . (:tag . "PROJ"))

				  ;; Add special rule for refiling to
				  ;; Someday.org & Leisure so we can omit
				  ;; them from org-agenda-files but still
				  ;; refile there
				  ("~/org/Someday.org" . (:maxlevel . 2))
				  ("~/org/Leisure.org" . (:maxlevel . 2))))

       ;; Make 'org-refile' work better with Ivy
       (setq org-goto-interface 'outline-path-completion)
       (setq org-outline-path-complete-in-steps nil)

       ;; Allow refiling to sub-paths
       (setq org-refile-use-outline-path 'file)

       (setq org-refile-allow-creating-parent-nodes 'confirm)
     #+END_SRC

**** Capturing

     Set up capture templates. This is mainly from [[http://koenig-haunstetten.de/2014/08/29/the-power-of-orgmode-capture-templates/][Rainer's blog post]]. No doubt
     this will grow...

     #+BEGIN_SRC emacs-lisp
       (defun capture-blog-post-file ()
	 (let* ((title (read-string "Slug: "))
		(slug (replace-regexp-in-string "[^a-z0-9]+" "-" (downcase title))))
	   (expand-file-name
	    (format "~/blog/articles/%s/%s.org"
		    (format-time-string "%Y" (current-time))
		    slug))))

       (setq org-default-notes-file "~/org/inbox.org")

       (use-package org-contacts
	 :ensure org-plus-contrib
	 :pin org)

       (setq org-capture-templates
	     '(("t" "TODOs")
	       ("tn" "Todo Right Now (clock in!)" entry (file "")
		"* NEXT %?\n\n  %i" :clock-in t :clock-keep t)
	       ("tt" "Plain TODO entry (with initial content if marked)" entry (file "")
		"* TODO %?\n\n  %i")
	       ("tl" "TODO entry with link" entry (file "")
		"* TODO %?\n\n  %a\n\n  %i")
	       ("tr" "Process email" entry (file "")
		"* TODO %:subject\n  SCHEDULED: %^t\n  %a\n\n  %?")
	       ("te" "To Expense" entry (file "")
		"* TODO %:subject  :EXPENSE:\n  SCHEDULED: %^t\n\n  %a\n")
	       ("tp" "New Project" entry (file "")
		"* PROJ %^{Project Name}\n  :LOGBOOK:\n  - Added: %U\n  :END:")
	       ("tT" "Trip" entry (file "")
		(file "templates/trip.org") :empty-lines 1)

	       ("c" "Contacts" entry (file "~/org/contacts.org")
		"* %(org-contacts-template-name)
	 :PROPERTIES:
	 :EMAIL: %(org-contacts-template-email)
	 :BIRTHDAY:
	 :PHONE:
	 :ALIAS:
	 :NICKNAME:
	 :IGNORE:
	 :ICON:
	 :NOTE:
	 :ADDRESS:
	 :END:")

	       ("l" "Log Learning" entry (file+datetree "learning.org")
		"* %^{Title} %^g\n  %?")

	       ("n" "Note" entry (file+datetree "notes.org")
		"* %^{Subject} %^g\n\n  %?"
		:empty-lines 1
		:clock-in t)

	       ("m" "Meter Readings")
	       ("mg" "Gas Meter" table-line (file "notes/gas-consumption.org")
		"|%^{Reading Time}u|%^{Reading Value}|%^{Price Per Litre|0.7}"
		:table-line-pos "II-1")
	       ("me" "Electricity Meter" table-line (file "notes/electricity-consumption.org")
		"|%^{Reading Time}u|%^{Reading Value}|%^{Price Per Unit|0.1412}"
		:table-line-pos "II-1")

	       ("P" "password" entry (file "~/org/passwords.org.gpg")
		"* %^{Title}\n %^{URL}p %^{USERNAME}p %^{PASSWORD}p" :empty-lines 1)

	       ("b" "Blog Post" plain
		(file capture-blog-post-file)
		(file "templates/blog-post.org"))

	       ("r" "GTD Review" entry (file+datetree "GTDReview.org")
		(file "templates/gtd-review.org")
		:empty-lines 1
		:jump-to-captured t)))
     #+END_SRC

**** Babel

     Some initialisation settings for Org Babel is in order.
     I don't want export to execute babel stuff: I like to execute them manually
     before exporting. This is a security feature, as sometimes I have documents
     that log in to servers and does things.

     Ditaa requires a path to the installed Jar; this recently stopped working
     because I had upgraded Ditaa, and the Jar has a version number in its name.
     Now we look at the file system and grab the highest-versioned Jar available.

     #+BEGIN_SRC emacs-lisp
       ;; Tell Org where to find ditaa jar
       (setq org-ditaa-jar-path
	     (expand-file-name "~/.nix-profile/lib/ditaa.jar"))

       (setq org-plantuml-jar-path
	     (expand-file-name "~/.nix-profile/lib/plantuml.jar"))
     #+END_SRC

     We have to specify the list of languages we want to support so Orgmode knows
     to look out for them:

     #+BEGIN_SRC emacs-lisp
       (org-babel-do-load-languages
	'org-babel-load-languages
	'((emacs-lisp . t)
	  (ditaa . t)
	  (plantuml . t)
	  (dot . t)
	  (sql . t)
	  (shell . t)))
     #+END_SRC

**** Org Export

     I hate writing JIRA markup, so I wrote a JIRA export backend for
     Org mode. I also write in Org and export to GitHub. Regular GitHub
     markup unfortunately doesn't properly ignore linebreaks, so the
     regular markdown exporter is no use: I have to use the gfm
     exporter, as it deletes linebreaks so the rendered paragraphs
     re-flow properly on GitHub.

     #+BEGIN_SRC emacs-lisp
       (use-package ox-jira :pin melpa)
       (use-package ox-gfm)
       (require 'ox-latex)
       (setq org-export-backends '(html gfm jira latex))
     #+END_SRC

**** Passwords

     #+BEGIN_SRC emacs-lisp
       (use-package org-passwords
         :ensure org-plus-contrib
	 :pin org
	 :after org
	 :init

	 (setq org-passwords-time-opened "30 min")

	 ;; Where's my passwords file?
	 (setq org-passwords-file "~/org/passwords.org.gpg")

	 :bind (("C-c P P" . org-passwords)
		("C-c P g" . org-passwords-generate-password)
		:map org-passwords-mode-map
		("C-c C-c u" . org-passwords-copy-username)
		("C-c C-c p" . org-passwords-copy-password)
		("C-c C-c o" . org-passwords-open-url)))
     #+END_SRC

**** Drilling

     I use org-drill for drilling music theory.

     #+begin_src emacs-lisp
       (use-package org-drill
         :pin melpa
	 :init
	 (setq org-drill-add-random-noise-to-intervals-p t)
	 (setq org-drill-adjust-intervals-for-early-and-late-repetitions-p t))
     #+end_src

**** Blogging Support

     I create blog entries in a directory under =~/blog= and link to them
     from the main index page. It has so far been a manual job, but I
     have finally managed to create a function to automate it a bit.

     #+BEGIN_SRC emacs-lisp
       (defun sb/org-kw-get (key)
	 "Return a lambda that takes an Org keyword element and returns
       its :value property if its :key property matches `key'."
	 `(lambda (kw)
	    (if (equal ,key (org-element-property :key kw))
		(org-element-property :value kw))))

       (defun sb/blog-post-index-entry ()
	 "Call in a blog post to get an entry suitable for linking to this
       post from the index page."
	 (interactive)
	 (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
		(tree (org-element-parse-buffer))

		(title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
		(categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY")))
		(abstract
		 (org-element-interpret-data
		  (org-element-map tree 'special-block
		    (lambda (sb)
		      (if (equal "abstract" (org-element-property :type sb))
			  (org-element-contents sb)))))))

	   (with-temp-buffer
	     (org-mode)
	     (org-insert-heading)

	     ;; Would have loved to use `org-insert-link' here but
	     ;; I can't stop it from presenting a prompt.
	     (insert "[[file:" path "][" title "]]\n\n"
		     abstract
		     "\n\n")

	     ;; Need to go back to the first line to set tags, as
	     ;; org-set-tags assumes point is on a headline.
	     (goto-char (point-min))
	     (org-set-tags categories)

	     ;; Return the contents temporary buffer as a string *without properties*
	     (copy-region-as-kill
	      (point-min) (point-max)))))

       (defun sb/blog-post-rss-entry ()
	 "Call in a blog post to get an entry suitable for linking to this
       post from the index page."
	 (interactive)
	 (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
		(tree (org-element-parse-buffer))

		(title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
		(categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY")))
		(abstract
		 (org-element-interpret-data
		  (org-element-map tree 'special-block
		    (lambda (sb)
		      (if (equal "abstract" (org-element-property :type sb))
			  (org-element-contents sb)))))))

	   (with-temp-buffer
	     (org-mode)
	     (org-insert-heading)
	     (insert title "\n\n" abstract)
	     (org-set-property "RSS_PERMALINK"
			       (format "%s.html"
				       (file-name-sans-extension path)))
	     (copy-region-as-kill
	      (point-min) (point-max)))))


       (defun sb/find-drafts ()
	 "Find org files in `~/blog/articles' not already linked from
		     `~/blog/index.org'."
	 (interactive)
	 (let* ((prefix (expand-file-name "~/blog/"))
		(posts
		 (directory-files-recursively
		  (concat prefix "articles") ".org"))
		(index-contents (get-string-from-file (concat prefix "index.org")))
		(drafts (cl-remove-if (lambda (needle)
					(string-match
					 (string-remove-prefix prefix needle)
					 index-contents))
				      posts))
		(buffer-name "*blog drafts*"))
	   (if drafts
	       (progn
		 (with-current-buffer (get-buffer-create buffer-name)
		   (erase-buffer)
		   (org-mode)
		   (insert
		    (mapconcat
		     (lambda (entry)
		       (format "- file:%s" entry))
		     drafts
		     "\n"))
		   (buffer-string))
		 (unless (get-buffer-window buffer-name t)
		   (pop-to-buffer buffer-name nil t))
		 (shrink-window-if-larger-than-buffer
		  (get-buffer-window buffer-name)))
	     (message "No drafts could be found!"))))
     #+END_SRC

**** Attachments

     One annoying thing is not being able to find attachments once
     you've attached files. Luckily, it turns out you can ask Org to
     create links to attachments.

     #+BEGIN_SRC emacs-lisp
     (setq org-attach-store-link-p t)
     #+END_SRC

**** Edit "Org-like" lists in non-Org buffers

     #+begin_src emacs-lisp
     (use-package orgalist
       :pin gnu
       :config
       (add-hook 'message-mode-hook 'orgalist-mode))
     #+end_src

*** Plant UML Mode

    I use this for [[http://plantuml.com/sequence.html][sequence diagrams]] etc.

    #+BEGIN_SRC emacs-lisp
      (use-package plantuml-mode
	:mode "\\.puml\\'"
	;;       :init (setq plantuml-jar-path (expand-file-name "~/.nix-profile/lib/plantuml.jar"))
	)
    #+END_SRC

*** Playing Midi files

    We can play midi files with fluidsynth.

    Then we need a soundfont. Fluidsynth appears to recommend the one
    from http://www.schristiancollins.com/generaluser.php.

    #+begin_src sh :tangle ~/.local/bin/download_soundfont :tangle-mode (identity #o755)
      #!/bin/bash
      set -o errexit
      set -o nounset
      set -o pipefail

      tempfoo=`basename $0`
      TMPDIR=`mktemp -d -t ${tempfoo}`

      VERSION="1.471"

      mkdir -p ~/.local/share
      TARGET=~/.local/share/GeneralUserGS
      if test -d $TARGET ; then
          mv $TARGET $TARGET.$(date +%Y-%m-%d).$RANDOM
      fi

      DL=GeneralUser_GS_$VERSION
      curl -L https://www.dropbox.com/s/4x27l49kxcwamp5/GeneralUser_GS_$VERSION.zip?dl=1 -o ~/Downloads/$DL.zip
      cd $TMPDIR
      unzip ~/Downloads/$DL.zip

      mv "$(find $TMPDIR -mindepth 1 -maxdepth 1 -type d)" "$TARGET"

      rmdir $TMPDIR
    #+end_src


    Finally let's install a wrapper to more easily play stuff.

    #+begin_src sh :tangle  ~/.local/bin/playmidi :tangle-mode (identity #o755)
      #!/bin/bash
      set -o errexit
      set -o nounset
      set -o pipefail

      if ! test -d ~/.local/share/GeneralUserGS ; then
	echo "No soundfonts found, attempting to download..."
	download_soundfont
      fi

      fluidsynth -a coreaudio -m coremidi -ni ~/.local/share/GeneralUserGS/GeneralUser\ GS\ v1.471.sf2 "$@"
    #+end_src

*** Projectile

    I use Projectile to navigate my projects. Some of the things I like about
    it are that it provides the following key bindings:

    - =C-c p t= :: This switches from an implementation file to its test file,
                   or vice versa. I use this extensively in Clojure mode. It
                   might not make sense for all languages; YMMV.
    - =C-c p 4 t= :: The same, as above, but open the file in "other" buffer.
    - =C-c p s s= :: Ag search for something in this project. If point is at a
                     token, default to searching for that. (Mnemonic:
                     "Projectile Silver Searcher".)

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
	:bind ("C-c p" . projectile-command-map)
	:demand
	:init
	(setq projectile-completion-system 'ivy)
	:config
	(projectile-mode +1))


      ;; Register project subtype used by "gilded rose" kata.
      (projectile-register-project-type 'lein-spec '("project.clj" "spec")
					:compile "lein compile"
					:test "lein test"
					:test-suffix "_spec")

      (use-package counsel-projectile)
    #+END_SRC

*** Scala

    Then install ensime, the /ENhanced Scala Interaction Mode for Emacs/.

    #+begin_src emacs-lisp
      (use-package ensime)
      (use-package sbt-mode)
      (use-package scala-mode)
      (setq ensime-search-interface 'ivy)
    #+end_src

*** Set =PATH= etc from the login shell

    The GUI Emacs gets exec path from the system, rather than the login
    shell. We have to load PATH etc from Zsh to get access to programs
    installed by Nix.

    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
	:init
	(setq exec-path-from-shell-variables
	      '("PATH" "MANPATH" "SSL_CERT_FILE" "NIX_PATH"
		"LDFLAGS" "CPPFLAGS"
		"PYTEST_ADDOPTS"
		"LATERPAY_DATA_DIR"))
	:config
	(exec-path-from-shell-initialize))
    #+END_SRC

*** SmartParens

    #+BEGIN_SRC emacs-lisp
      (use-package smartparens-config
	:ensure smartparens
	:diminish

	;; I prefer to be explicit about the keybindings I use
	:bind (:map smartparens-mode-map
		    ("C-M-f" . sp-forward-sexp)
		    ("C-M-b" . sp-backward-sexp)
		    ("C-M-<SPC>" . sp-splice-sexp)
		    ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
		    ("C-<right>" . sp-forward-slurp-sexp)
		    ("C-<left>" . sp-forward-barf-sexp)
		    ("C-M-<left>" . sp-backward-slurp-sexp)
		    ("C-M-<right>" . sp-backward-barf-sexp))
	:init
	(add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
	(add-hook 'text-mode-hook 'turn-on-smartparens-mode)

	:config
	(show-smartparens-global-mode t))
    #+END_SRC

*** String Inflection

    Sometimes I need to swap between CamelCase and snake_case, or even
    SNAKE_CASE.

    #+begin_src emacs-lisp
      (use-package string-inflection
	:bind (("C-c C-x C-s" . string-inflection-all-cycle)
	       ("C-c C-x C-c" . string-inflection-camelcase)
	       ("C-c C-x C-k" . string-inflection-kebab-case)
	       ("C-c C-x C-u" . string-inflection-upcase)))
    #+end_src

*** Swiper

    Invoke swiper (find in current buffer).

    #+BEGIN_SRC emacs-lisp
      (use-package swiper
	:bind (("C-x /" . swiper)))
    #+END_SRC

*** Which Key Mode

    Show incomplete key cheatsheet.

    #+BEGIN_SRC emacs-lisp
      (use-package which-key
	:config
	(which-key-mode))
    #+END_SRC

*** Writegood Mode

    I'm not a great writer. I need all the crutches I can get. Lucklily,
    Emacs has them.

    This helps highlight passive voice, weasel words, etc in writing.

    #+BEGIN_SRC emacs-lisp
      (use-package writegood-mode
	:init
	(add-hook 'text-mode-hook 'writegood-mode))
    #+END_SRC

*** YAML

    CircleCI and CloudFormation loves YAML.

    #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode)
    #+END_SRC
*** Direnv

    #+begin_src emacs-lisp
      (use-package direnv
	:config
	(direnv-mode))
    #+end_src
