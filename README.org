#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t
#+PROPERTY: header-args:emacs-lisp    :tangle init.el
#+PROPERTY: header-args:sh            :tangle init.sh
#+PROPERTY: header-args            :results silent
#+STARTUP: content
* Introduction

  This is my Emacs configuration. Because I'm prone to forget what does what,
  my configuration is in the form of a [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document: prose,
  interspaced with code.

  After over a decade with BBEdit I started looking at Emacs again
  when I started learning Clojure. I started with the "better
  defaults" package and added things one-by-one as I found them,
  rather than stealing someone else's mammoth =.emacs= file that I
  didn't understand any of. Initially I drew a lot of inspiration from
  [[https://github.com/magnars/.emacs.d][magnars' .emacs.d]], but after rewriting it using [[https://github.com/jwiegley/use-package][use-package]] (which
  is great) and later using Org mode, it now feels like my own work.

  When I say this document uses literate programming, I mean that the
  configuration snippets here are not copied-and-pasted from my
  config, they /are/ my config. I edit everything in =init.org= and /tangle/
  the code into [[file:init.el][init.el]] by hitting =C-c C-v C-t=.

  However, this document doesn't just contain =emacs-lisp= snippets. It
  also contains some shell snippets to install Emacs itself, and some
  helper programs. By invoking =C-c C-v C-t= on this document an =init.sh=
  file is produced, that contains shell commands that will install all
  the helper programs via =brew=, or in some cases via =nix=.

** Check out this repo into =~/.emacs.d/=

** Install Emacs

   I'm experimenting with installing Emacs via Nix rather than
   homebrew. I use the Mac-version, and it's installed like this:

   #+BEGIN_SRC sh
   nix-env -i emacs-mac
   #+END_SRC

* Meta configuration

** Nix Site Start

   #+BEGIN_SRC emacs-lisp
   (load "~/.nix-profile/share/emacs/site-lisp/site-start.el")
   #+END_SRC

** Disable mouse interface, splash screen & beeps in =early-init.el=

   I don't tend to use a mouse in Emacs often, so I turn off mouse
   interface early to avoid momentary display during launch. Recent
   Emacsen read =early-init.el= before initialising GUI components, so
   it's a great place to turn off mouse interface to avoid flicker
   during startup.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
     (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
   #+END_SRC

   I also don't need to see a splash screen on every launch.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (setq inhibit-startup-message t)
   #+END_SRC

   I do not like Emacs to beep at me; I prefer a visual bell.

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (setq visible-bell t)
   #+END_SRC

** Pre Emacs 27 compat                                               :COMPAT:

  Older versions of Emacs doesn't have the early-init built-in, so
  load that file before anything else, if we haven't already turned on
  visible bell.

  #+BEGIN_SRC emacs-lisp
    (if (not visible-bell)
	(progn
	  (load (expand-file-name "~/.emacs.d/early-init.el") t)
	  (require 'package)
	  (package-initialize)))
  #+END_SRC

** Add Package Archives & priorities

   Before we can install packages, we need to add the URLs of the
   package archives we want to use. I like the ability to use
   Melpa-stable for select packages. I don't use Marmelade as it seems
   to overlap with Melpa.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
   #+END_SRC

** Install & configure =use-package=

   I use [[https://github.com/jwiegley/use-package][use-package]] for installing & configuring packages. Because it
   is /itself/ installed via Melpa, there's a minor bootstrapping
   problem: we have to install it before we can use it to install the
   rest of the packages.

   #+BEGIN_SRC emacs-lisp
     (unless (and (package-installed-p 'use-package)
		  (package-installed-p 'dash))
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))

     ;; No need to put ':ensure t' everywhere, since we don't use anything else to install packages.
     (setq use-package-always-ensure t)
   #+END_SRC

* Configuration
** Add keybinding to join next line to this

   With cursor at any point in a line, hit =M-j= to move to the end, and
   delete the newline. The cursor is left where the newline used to be.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-j")
                     (lambda ()
		       (interactive)
		       (join-line -1)))
   #+END_SRC

** Add =/usr/local/bin= to our path

   The GUI Emacs gets exec path from the system, rather than the login shell.
   This requires us to add ~/usr/local/bin~ to ~exec-path~ lest it can't find
   any programs installed by =brew=.

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :config
       (exec-path-from-shell-copy-env "NIX_PATH")
       (exec-path-from-shell-copy-env "SSL_CERT_FILE"))
   #+END_SRC

** Ag / The Silver Searcher

   I use =ag= for searching quite a lot in Emacs.
   This requires an additional external tool for best performance:

   #+BEGIN_SRC sh
     nix-env -i silver-searcher
   #+END_SRC

   Then make sure the Emacs ag package is installed.

   #+BEGIN_SRC emacs-lisp
     (use-package ag)
   #+END_SRC

   "Writable grep" mode for ag is pretty close to magic. When in a buffer
   showing ag results, try hitting =C-c C-p=--this lets you _edit the results
   of the search, right from the ag results buffer!_ Just hit =C-x C-s= to
   save the results.

   If you hit =C-c C-p= while already in writable grep mode you can delete the
   entire matched line from the file where it was found by hitting =C-c C-d=
   on it. I use this _a lot_ when cleaning up Hieradata.

   Recently ag broke wgrep-ag by starting to group its output. The grouping is
   quite nice, but I prefer working wgrep so I turn the grouping off.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep-ag
       :init
       (setq ag-group-matches t))
   #+END_SRC

** Aggressive Indent

   I like to keep my code indented properly at all times. Aggressive-indent
   helps ensure this. Turn it on for lisp modes.

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent

       :config
       (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
       (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
       (add-hook 'css-mode-hook #'aggressive-indent-mode))
   #+END_SRC

** AppleScript support

   #+BEGIN_SRC emacs-lisp
     (use-package apples-mode)
   #+END_SRC

** Auto revert mode

   When files change on disk, revert the buffer automatically.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
   #+END_SRC

** Box quotes are so cute!

   Install boxquote to make fancy text boxes like this:

   #+BEGIN_EXAMPLE
     ,----
     | This is a box quote!
     `----
   #+END_EXAMPLE

   You can even set a title!

   #+BEGIN_EXAMPLE
     ,----[ with a title! ]
     | This is another box quote
     `----
   #+END_EXAMPLE

   #+BEGIN_SRC emacs-lisp
     (use-package boxquote)
   #+END_SRC

** Buffer-local regex search

   I like the =C-s= and =C-r= keybindings to mean "search forward/backward
   for this regex".

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-s") 'isearch-forward-regexp)
     (global-set-key (kbd "C-r") 'isearch-backward-regexp)
   #+END_SRC

** Clojure

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode)
  (use-package cider)
  (use-package clj-refactor)
  (use-package cljr-helm
  :bind (:map clojure-mode-map ("C-c C-r" . cljr-helm)))
#+END_SRC

** Completion

   In the past I've been using Helm, but I did a recent experiment with
   Ivy because I'm a perpetual tinkerer. It doesn't do everything that
   Helm does, and it was annoying in some respects (notably not
   allowing me to create new files in the minibuffer, not allowing
   /closing buffers/ in the minibuffer, and not allowing editable results
   in ag buffer) but I'm a bit confused by helm in some situations and
   checking to see if Ivy suits those better.

*** Helm

    I use [[https://github.com/emacs-helm/helm][Helm]] for interactive completion and finding things,
    particularly files.

    #+BEGIN_SRC emacs-lisp
      (use-package helm
	:init

	;; Ag buffer names are insanely long...
	(setq helm-buffer-max-length 35)

	:bind (("M-x" . helm-M-x)
	       ("M-y" . helm-show-kill-ring)
	       ("C-x b" . helm-mini)
	       ("C-x C-b" . helm-buffers-list)
	       ("C-x 4 b" . helm-mini)
	       ("C-x C-f" . helm-find-files)

	       ;; Use Helm to narrow to headings in Org buffers.
	       (:map org-mode-map
		     ("C-c h" . helm-org-in-buffer-headings)
		     ("C-c f" . helm-org-agenda-files-headings)))

	:config
	(require 'helm-buffers)
	(require 'helm-org)

	;; Magit creates many buffers, most of which are not interesting.
	(add-to-list 'helm-boring-buffer-regexp-list "\\*magit")

	;; TAGS files are rarely interesting.
	(add-to-list 'helm-boring-buffer-regexp-list "TAGS"))
    #+END_SRC

    This next package adds =C-c p h=, which invokes =helm-find-file= in project
    context. Invaluable.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-projectile
         :after projectile
	 :config
	 (helm-projectile-on))
    #+END_SRC

*** Swiper

    Invoke swiper (find in current buffer).

    #+BEGIN_SRC emacs-lisp
      (use-package swiper
	:bind (("C-x /" . swiper)))
    #+END_SRC
*** Auto-complete of code and prose

    #+BEGIN_SRC emacs-lisp
    (use-package company
      :init
      ;; https://emacs.stackexchange.com/a/10838
      (setq company-dabbrev-downcase nil)
      :config
      (global-company-mode))
    #+END_SRC

** CSS

   #+BEGIN_SRC emacs-lisp
   (use-package flymake-css
     :config
     (add-hook 'css-mode-hook 'flymake-css-load))
   #+END_SRC
** Delete the file for the current buffer function

   "Delete this file." Simple, huh?

   #+BEGIN_SRC emacs-lisp
     (defun delete-current-buffer-file ()
       "Removes file connected to current buffer and kills buffer."
       (interactive)
       (let ((filename (buffer-file-name))
             (buffer (current-buffer))
             (name (buffer-name)))
         (if (not (and filename (file-exists-p filename)))
             (ido-kill-buffer)
           (when (yes-or-no-p "Are you sure you want to remove this file? ")
             (delete-file filename)
             (kill-buffer buffer)
             (message "File '%s' successfully removed" filename)))))

     (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
   #+END_SRC

** Disable kill-emacs

   Disable =s-q= (=kill-emacs=) as it is too close to =M-q= which I use for
   reflowing text.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-q") nil)
   #+END_SRC

** Don't hide Emacs when  ⌘-h is pressed

   In Emacs Mac Port, ⌘-h bypasses any Emacs keybindings and instead sends a
   "pass command to system" message to Mac OSX, which then hides the entire
   application. [[https://github.com/railwaycat/homebrew-emacsmacport/issues/55][I don't want that]].

   #+BEGIN_SRC emacs-lisp
     (setq mac-pass-command-to-system nil)
   #+END_SRC

** Don't store backup files next to originals

   I don't like backup files (those dreaded =foo~= ones) all over my disk.
   This places them in =~/.emacs.d/backups=.

   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
     (setq backup-by-copying t)
   #+END_SRC

** Dotenv Mode

   Automatically source variables in =.env= files into Emacs.


   #+BEGIN_SRC emacs-lisp
   (use-package dotenv-mode)

   #+END_SRC
** Editorconfig

   Some projects I touch, particularly at work, use [[http://editorconfig.org][editorconfig]] to set up
   their indentation and file format preferences.

   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :init
       (setq editorconfig-exclude-modes '(org-mode))
       (setq editorconfig-mode-lighter " EC")
       :config
       (editorconfig-mode))
   #+END_SRC

   Emacs requires an external tool for this to work.

   #+BEGIN_SRC sh
     nix-env -i editorconfig-core-c
   #+END_SRC

** Elfeed

   I use custom.el for the actual feeds.

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :bind ("C-x w" . elfeed)
       :config
       (defalias 'elfeed-toggle-star
	 (elfeed-expose #'elfeed-search-toggle-all 'star))

       (eval-after-load 'elfeed-search
	 '(define-key elfeed-search-mode-map (kbd "m") 'elfeed-toggle-star)))
   #+END_SRC

** Email

   Because I like to use Emacs for writing, I like to use it for email
   too. I tried Gnus, but don't really read news so it felt a bit
   overkill. I've been using [[http://www.djcbsoftware.nl/code/mu/][mu4e]] for a while, but I'm slightly
   annoyed by some of its quirks (particularly interacting with Gmail,
   which I have to use for work) so thought I'd try [[https://notmuchmail.org][notmuch]].

   I use [[http://msmtp.sourceforge.net/][msmtp]] for sending email, and [[http://isync.sourceforge.net][mbsync]] for syncing IMAP messages
   between my local machine and upstream servers.

*** Reading mail with NotMuch

    After installing NotMuch it I ran =notmuch setup= to configure
    it. Then I ran =notmuch new= to index my existing mail.  (This was
    already in =~/Maildir/= since I've been using mu4e before.) I then
    installed the Emacs package from Melpa, and launched it with =M-x
    notmuch=.  Its threading and MIME appears a lot better than mu4e,
    from a cursory glance.

    Installation is with =nix=:

    #+BEGIN_SRC sh
      nix-env -i notmuch
    #+END_SRC

    Notmuch has to be configured by running =notmuch setup= on the
    commandline. I haven't yet figured out how to tangle that from
    this config, but the key parts of my config are:

    #+BEGIN_SRC sh :results output replace :exports results :tangle no
    notmuch config list
    #+END_SRC

    #+RESULTS:
    #+begin_example
    database.path=/Users/stig/Mail
    user.name=Stig Brautaset
    user.primary_email=stig@brautaset.org
    user.other_email=sbrautaset@laterpay.net;stig.brautaset@icloud.com;stigbrau@start.no;stigbrau@online.no;stig.brautaset@me.com;S.Brautaset@westminster.ac.uk;Stig.Brautaset@MorganStanley.com;stig.brautaset@ktsplc.com
    new.tags=unread;inbox;
    new.ignore=.mbsyncstate;.uidvalidity;.isyncuidmap.db
    search.exclude_tags=deleted;spam;muted
    maildir.synchronize_flags=true
    built_with.compact=true
    built_with.field_processor=true
    built_with.retry_lock=true
    #+end_example

    With that out of the way, and installing the package from Melpa,
    Notmuch works pretty well for me. Mainly I set up a keybinding to
    quickly bring it up.

    #+BEGIN_SRC emacs-lisp
      (use-package notmuch
	:bind (("C-c m" . notmuch)))

      ;; Allow linking to NotMuch messages from Org mode
      (require 'org-notmuch)
    #+END_SRC

**** Add post-new hook to tag messages

     #+BEGIN_SRC sh :tangle ~/Mail/.notmuch/hooks/post-new :mkdirp yes :tangle-mode (identity #o755) :prologue "" :epilogue ""
       #!/bin/bash
       set -o errexit
       set -o nounset
       set -o pipefail

       notmuch tag +sent -inbox -- path:/sent/ and not tag:sent
       notmuch tag +deleted -inbox -- path:/trash/ and not tag:deleted
       notmuch tag +spam -inbox -- path:/spam/ and not tag:spam

       # Mailing lists..
       notmuch tag +lists +org-mode -inbox -- path:/ml-org-mode/

       # Mute all messages in threads that have at least one muted message
       notmuch tag +muted -- $(notmuch search --exclude=false --output=threads tag:muted)

       # Immediately archive Microsoft family spam
       notmuch tag -inbox -unread from:microsoftfamily@microsoft.com AND NOT to:stig@brautaset.org
     #+END_SRC

*** Composing multiple Email sending profiles

    NotMuch doesn't have built-in support for multiple profiles, but
    we can use =gnus-alias= for that:

    #+BEGIN_SRC emacs-lisp
      (use-package gnus-alias)

      (setq gnus-alias-identity-alist
	    '(("home"
	       nil ;; Does not refer to any other identity
	       "Stig Brautaset <stig@brautaset.org>"
	       nil ;; No organization header
	       nil
	       nil ;; No extra body text
	       "~/.signature")
	      ("work"
	       nil
	       "Stig Brautaset <sbrautaset@laterpay.net>"
	       "LaterPay GmbH"
	       nil
	       nil
	       "~/.signature.work")
	      ("atlassian"
	       nil
	       "Stig Brautaset <sbrautaset@laterpay.net>"
	       nil
	       nil
	       nil
	       nil)))

      (setq gnus-alias-identity-rules
	    '(("atlassian" ("to" ".+@laterpay.atlassian.net" current) "atlassian")
	      ("work" ("any" ".+@laterpay.net" both) "work")))

      (setq gnus-alias-default-identity "home")

      (add-hook 'message-setup-hook 'gnus-alias-determine-identity)

      ;; I rely on Gmail saving my outgoing messages in the "sent" folder,
      ;; hence I only manually save mail to sent for my personal mail.
      (setq notmuch-fcc-dirs
	    '(("stig@brautaset.org" . "Gandi/sent +sent -unread -inbox")))

    #+END_SRC

*** Downloading email over IMAP

    I used to use OfflineIMAP for this, but mbsync (from the isync suite) seems
    faster and doesn't have this annoying db outside of the Maildir to keep in
    sync. First install mbsync:

    #+BEGIN_SRC sh
      nix-env -i isync
    #+END_SRC

**** mbsync configuration

     #+BEGIN_SRC conf :tangle ~/.mbsyncrc
       IMAPAccount gandi
       Host mail.gandi.net
       User stig@brautaset.org
       SSLType IMAPS
       AuthMechs LOGIN
       PassCmd "security find-generic-password -s mbsync-gandi-password -w"
       # To rotate:
       # > security delete-generic-password -s mbsync-gandi-password
       # > security add-generic-password -a stig@brautaset.org -s mbsync-gandi-password -w APP-SPECIFIC-PASSWORD

       IMAPStore gandi-remote
       Account gandi

       MaildirStore gandi-local
       AltMap yes
       Path ~/Mail/Gandi/
       Inbox ~/Mail/Gandi/INBOX

       Channel gandi-inbox
       Master :gandi-remote:
       Slave :gandi-local:
       Create Slave
       SyncState *

       Channel gandi-sent
       Master :gandi-remote:Sent
       Slave :gandi-local:sent
       Create Slave
       SyncState *

       Channel gandi-spam
       Master :gandi-remote:Junk
       Slave :gandi-local:spam
       Create Slave
       SyncState *

       Channel gandi-trash
       Master :gandi-remote:Trash
       Slave :gandi-local:trash
       Create Slave
       SyncState *

       Channel gandi-ml
       Master :gandi-remote:
       Slave :gandi-local:
       Patterns ml-%
       Create Slave
       SyncState *

       # ACCOUNT INFORMATION
       IMAPAccount gmail
       Host imap.gmail.com
       User sbrautaset@laterpay.net
       Timeout 60
       PassCmd "security find-generic-password -s mbsync-gmail-password -w"
       AuthMechs PLAIN
       SSLType IMAPS
       CertificateFile /etc/ssl/cert.pem

       # REMOTE STORAGE (USE THE IMAP ACCOUNT SPECIFIED ABOVE)
       IMAPStore gmail-remote
       Account gmail

       # LOCAL STORAGE (CREATE DIRECTORIES with mkdir -p Mail/gmail)
       MaildirStore gmail-local
       AltMap yes
       Path ~/Mail/Work/
       Inbox ~/Mail/Work/INBOX

       Channel gmail-archive
       Master :gmail-remote:"[Gmail]/All Mail"
       Slave :gmail-local:archive
       Create Slave
       SyncState *

       Channel gmail-sent
       Master :gmail-remote:"[Gmail]/Sent Mail"
       Slave :gmail-local:sent
       Create Slave
       SyncState *

       Channel gmail-spam
       Master :gmail-remote:"[Gmail]/Spam"
       Slave :gmail-local:spam
       Create Slave
       SyncState *

       Channel gmail-trash
       Master :gmail-remote:"[Gmail]/Bin"
       Slave :gmail-local:trash
       Create Slave
       SyncState *
     #+END_SRC


**** Wrap mbsync to detect missing network

     #+begin_src sh :mkdirp t :tangle ~/.local/bin/getmail.sh :tangle-mode (identity #o755) :prologue "" :epilogue ""
       #!/bin/bash
       set -o errexit
       set -o nounset
       set -o pipefail

       ping -t1 -q -n -c1 8.8.8.8 >/dev/null || exit 0 # no network

       pgrep -q -f mbsync || mbsync -qaV

       echo
       echo "It is now:"
       date
     #+end_src

**** Run mbsync periodically while Emacs is open

     Here we set up a timer to periodically run mbsync from within
     Emacs.  It's not abnormal for this to take 30 seconds, but
     usually it's less.

     #+BEGIN_SRC emacs-lisp
       (defun sb/getmail ()
	 (interactive)
	 (start-process "getmail.sh" "*getmail*" "~/.local/bin/getmail.sh"))

       ;; run-with-timer requires arguments, but I can't get the function to
       ;; run interactively with arguments, hence this indirection.
       (defun sb/getmail-wrapper (args) (sb/getmail))

       ;; Capture the timer so we can cancel it later if we need to
       (setq sb/getmail-timer
	     (run-with-timer 60 900 'sb/getmail-wrapper ""))
     #+END_SRC

*** Compose Emails with Org mode

    I want to be able to create links to messages from Org mode
    capture templates, as email Inbox is a terrible TODO list.  I
    define =C-c x= as a short-cut to switch to Org mode, and back, to
    message mode, so that I can use full Org mode to edit messages if
    I want.

    #+BEGIN_SRC emacs-lisp
      (use-package org-mime
	:bind (:map message-mode-map
		    ("C-c h" . org-mime-htmlize))
	:init
	(setq org-mime-preserve-breaks nil))
    #+END_SRC

*** Sending mail with MSMTP

    MSMTP's configuration is really simple, and it will detect the account to
    use from the "from" address. Let's go!

    #+BEGIN_SRC sh
      nix-env -i msmtp
    #+END_SRC

    MSMTP obtains passwords from the system Keychain. See the [[http://msmtp.sourceforge.net/doc/msmtp.html#Authentication][Authentication]]
    section in the msmtp documentation for details.

    #+BEGIN_SRC conf :tangle ~/.msmtprc
      defaults

      port 587
      tls on
      tls_trust_file /etc/ssl/cert.pem
      auth on

      ###############
      account private

      from stig@brautaset.org
      host mail.gandi.net
      user stig@brautaset.org

      #############
      account icloud

      from stig.brautaset@icloud.com
      host smtp.mail.me.com
      user stig.brautaset@icloud.com

      ############
      account work

      from sbrautaset@laterpay.net
      host smtp.gmail.com
      user sbrautaset@laterpay.net

      #########################
      account default : private
    #+END_SRC

    Finally we have to tell Emacs to use msmtp to send mail:

    #+BEGIN_SRC emacs-lisp
      (setq message-send-mail-function 'message-send-mail-with-sendmail
            sendmail-program "msmtp"
	    message-sendmail-envelope-from 'header
	    mail-envelope-from 'header
	    mail-specify-envelope-from t)
    #+END_SRC

**** Don't keep buffer for sent messages

     #+BEGIN_SRC emacs-lisp
     (setq message-kill-buffer-on-exit t)
     #+END_SRC

** End all files in a newline

   All files should end in a newline. Insert one if there isn't one already.

   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC

** Eshell

   I have started using /Eshell/. It is close to magic. There's not a lot of
   setup (it has its own [[file:eshell/alias][alias file]]), but I've got a keybinding to bring up
   eshell quickly. This launches eshell if it is not already running, or
   switches to it if it is.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c s") 'eshell)

     ;; This helps with aws cli commands, and nix-env --help, a bit
     (setenv "PAGER" "cat")
   #+END_SRC

   Eshell is great, and its Tramp integration allows me to open remote files
   in local Emacs seamlessly with the =find-file= command. (Which I have
   aliased to =ff=.) Eshell also makes sure that my shell behaves the same,
   and has the same config, whether I am on a local machine or a remote one.

** Graphviz

   I sometimes use Graphviz to create diagrams.

   #+BEGIN_SRC sh
     nix-env -i graphviz
   #+END_SRC

   I also have to tell Emacs how to launch GraphViz.

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :bind ("C-c C-p" . graphviz-dot-preview))
   #+END_SRC

** Highlight & deal with whitespace annoyances

   This highlights certain whitespace annoyances, and adds a key binding to
   clean it up.

   #+BEGIN_SRC emacs-lisp
     (require 'whitespace)
     (setq whitespace-style '(face empty tabs trailing))
     (global-whitespace-mode t)

     (global-set-key (kbd "C-c w") 'whitespace-cleanup)
   #+END_SRC

** I like big fonts and I cannot lie

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :height 150)
#+END_SRC
** International Support

    I'm Norwegian, but use a GB keyboard. I also use Dvorak keyboard
    layout. I also have Polish colleagues whose names I don't want to
    mangle completely. Keep this in mind if you find the below
    confusing.

*** Always use UTF-8 encoding

    Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

    #+BEGIN_SRC emacs-lisp
      (setq locale-coding-system 'utf-8)
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-selection-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
    #+END_SRC

*** Install and configure Aspell

    #+BEGIN_SRC emacs-lisp
      (setq ispell-dictionary "british"
	    ispell-extra-args '("-W" "2" "--sug-mode=ultra"))
    #+END_SRC

    Install aspell and dictionaries:

    #+BEGIN_SRC sh
      nix-env -i aspell-dict-en aspell-dict-en-computers aspell-dict-en-science aspell
    #+END_SRC

    #+begin_src conf :tangle ~/.aspell.conf
    master british
    extra-dicts en-computers.rws
    add-extra-dicts en_GB-science.rws
    data-dir /Users/stig/.nix-profile/lib/aspell
    #+end_src

** IRC

   But /of course/ Emacs has a built-in IRC client. In fact it has two! But I
   digress. Let's use the oldest one, and configure it slightly.

   #+BEGIN_SRC emacs-lisp
   (setq rcirc-default-nick "stigbra")
   (setq rcirc-default-full-name "Stig Brautaset")
   #+END_SRC

** Git-ish
*** Magit

    I use [[http://magit.vc][Magit]] all day. If you use git a lot it's possibly worth switching to
    Emacs just for it. It is excellent. I bind =H-m= to =magit-status=, which is
    the main entry point for the mode.

    Forge is an extension to Magit that interacts with GitHub / GitLab etc.

    #+BEGIN_SRC emacs-lisp
      (use-package magit
	:bind (("M-m" . magit-status)
	       ("s-b" . magit-blame)))

      (use-package forge)
    #+END_SRC

*** Git Link

    Link to file location on GitHub/Bitbucket/GitLab/...

    #+BEGIN_SRC emacs-lisp
      (use-package git-link
	:bind ("C-c g l" . git-link))
    #+END_SRC

*** Gists

    Viewing & editing gists in Emacs? Sure! I want that!

    #+BEGIN_SRC emacs-lisp
      (use-package gist
	:bind (("C-x g l" . gist-list)
               ("C-x g c" . gist-region-or-buffer-private))
	:init

	;; The defaults for these are too small for gists
	(setq max-specpdl-size 3000)
	(setq max-lisp-eval-depth 2000)

	(setq gist-ask-for-description t))
    #+END_SRC

*** Resolving Conflicts

    Sometimes I have to resolve conflicts. I then use Ediff, which I
    launch from Magit. Occasionally I want to pick *both* sides of the
    conflicts. (If both branches add an entry to a list, for example;
    which can often happen in hieradata / puppet.) This adds =d= as a
    shortcut to do that. ([[http://stackoverflow.com/a/29757750/5950][Credits]].) You can use =~= to swap the A and B
    buffers, so in effect you can get A then B, /or/ B then A.

    #+BEGIN_SRC emacs-lisp
      (defun ediff-copy-both-to-C ()
	(interactive)
	(ediff-copy-diff ediff-current-difference nil 'C nil
			 (concat
                          (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                          (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
      (defun add-d-to-ediff-mode-map () (define-key ediff-mode-map "d" 'ediff-copy-both-to-C))
      (add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map)
    #+END_SRC

*** Auto commit

    In some projects (notably, my Org/Agenda setup) I want to
    automatically commit when editing files.

    #+BEGIN_SRC emacs-lisp
      (use-package git-auto-commit-mode)
    #+END_SRC

** Make 'y' and 'n' satisfy prompts

   Answering just 'y' or 'n' will do, rather than having to spell out "yes"
   or "no".

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Make mouse scrolling smoother

   The adaptive mouse scrolling is far, far too quick so let's turn that off.

   #+BEGIN_SRC emacs-lisp
   (setq mouse-wheel-progressive-speed nil)
   (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))))
   #+END_SRC

** Markdown

   I'm a sucker for lists, and I want to be able to reorder list items
   easily and have them renumbered automatically.

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :bind (("M-<up>" . markdown-move-list-item-up)
	      ("M-<down>" . markdown-move-list-item-down)))
   #+END_SRC
** Multiple Cursors

   This package is another one of those near-magical ones. It allows me to do
   multiple edits in the same buffer, using several cursors. You can think of
   it as an interactive macro, where you can constantly see what's being done.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors

       :bind (("C-c M-e" . mc/edit-lines)
              ("C-c M-a" . mc/mark-all-dwim)
              ("s-n" . mc/mark-next-like-this)
              ("s-p" . mc/mark-previous-like-this)))
   #+END_SRC

** Nix

   Some modules useful for Nix.

   #+BEGIN_SRC emacs-lisp
     (use-package nix-mode)
     (use-package nix-buffer)
     (use-package nix-update)
     (use-package nix-sandbox)
   #+END_SRC

** Org mode

   I now use Org mode for all writing I initiate. The Emacs org mode's support
   for tables, TOC, footnotes, TODO and agenda items makes it an easy choice.
   Gists and GitHub READMEs support Org mode too, and I can export to other
   formats including if I want.

   To avoid having one gigantic section, this file uses NOWEB syntax to weave
   together config snippets.

   The particular version of package I use is annoying to install because the
   installed package has a different name from what you would use in your
   config. However, =use-package= supports this by passing the name of the
   package to install as the value to =:ensure=.

   The Org manual expects the =C-c {l,a,c,b}= keybindings to be
   available in any mode, so define them globally. I prefer to follow
   conventions. It makes reading the manual and tutorials a lot
   easier!

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure org-plus-contrib
       ;;      :load-path (lambda () (expand-file-name "~/play/org-mode/lisp"))

       :bind (("C-c l" . org-store-link)
	      ("C-c a" . org-agenda)
	      ("C-c c" . org-capture)
	      ("C-c b" . org-iswitchb)
	      ("C-s-<return>" . org-insert-subheading)
	      ("C-s-S-<return>" . org-insert-todo-subheading)
	      :map org-mode-map
	      ("C-c x" . mu4e-compose-mode)
	      ("C-n" . org-next-link)
	      ("C-p" . org-previous-link))

       :mode (("\\.org\\'" . org-mode)
	      ("\\.org_archive\\'" . org-mode))

       :init

       ;; When hitting C-c C-z to take a note, always put it in the LOGBOOK drawer
       (setq org-log-into-drawer t)

       ;; Sometimes I accidentally edit non-visible parts of org document. This
       ;; helps, apparently.
       (setq org-catch-invisible-edits 'show-and-error)

       ;; If running interactively, I want export to copy to the kill-ring
       (setq org-export-copy-to-kill-ring 'if-interactive)

       (setq org-hide-emphasis-markers t)

       (setq org-element-use-cache nil)

       (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
   #+END_SRC

   Ditaa requires a package installed by brew.

   #+BEGIN_SRC sh
     nix-env -i ditaa
   #+END_SRC

*** Agenda

    #+BEGIN_SRC emacs-lisp
      ;; I don't rely on many properties, so this should speed up my Agenda
      ;; view, according to http://orgmode.org/worg/agenda-optimization.html
      (setq org-agenda-ignore-properties '(effort appt stats))

      ;; I don't want to show these in the TODO list,
      ;; because they'll show in the Agenda anyway.
      (setq org-agenda-todo-ignore-scheduled 'future
	    org-agenda-todo-ignore-deadlines 'far
	    org-agenda-todo-ignore-timestamp 'future)

      (setq org-agenda-skip-deadline-prewarning-if-scheduled t
	    org-agenda-skip-scheduled-if-deadline-is-shown 'not-today)

      ;; Make tags-todo search ignore scheduled items too
      (setq org-agenda-tags-todo-honor-ignore-options t)

      (setq org-log-done 'time)

      (setq org-stuck-projects '("/PROJ" ("TODO" "NEXT" "WAITING") nil ""))

      (setq org-agenda-custom-commands
	    '(("d" "Agenda & NEXTs"
	       ((agenda "" ((org-agenda-span 'day)))
		(todo "NEXT")))
	      ("p" "Projects" todo "PROJ")
	      ("S" "Someday" tags-todo "-VOID"
	       ((org-agenda-files '("~/org/Someday.org"))))
	      ("n" todo "NEXT")
	      ("w" todo "WAITING")))
    #+END_SRC

*** Refiling

    I got all of this from [[https://www.youtube.com/watch?v=ECWtf6mAi9k][this YouTube video]].

    #+BEGIN_SRC emacs-lisp
      (setq org-refile-targets '((org-agenda-files :maxlevel . 2)
				 (org-agenda-files :tag . "PROJ")

				 ;; Add special rule for refiling to
				 ;; Someday.org, so we can omit it from
				 ;; org-agenda-files but still refile there
				 ("~/org/Someday.org" :maxlevel . 2)))

      ;; Allow refiling to sub-paths
      (setq org-refile-use-outline-path 'file)

      (setq org-refile-allow-creating-parent-nodes 'confirm)
    #+END_SRC

*** Capturing

    Set up capture templates. This is mainly from [[http://koenig-haunstetten.de/2014/08/29/the-power-of-orgmode-capture-templates/][Rainer's blog post]]. No doubt
    this will grow...

    #+BEGIN_SRC emacs-lisp
      (defun capture-blog-post-file ()
	(let* ((title (read-string "Slug: "))
	       (slug (replace-regexp-in-string "[^a-z0-9]+" "-" (downcase title))))
	  (expand-file-name
	   (format "~/blog/articles/%s/%s.org"
		   (format-time-string "%Y" (current-time))
		   slug))))

      (setq org-default-notes-file "~/org/inbox.org")

      (setq org-capture-templates
	    '(("t" "TODOs")
	      ("tn" "Todo Right Now (clock in!)" entry (file "")
	       "* NEXT %?\n\n  %i" :clock-in t :clock-keep t)
	      ("tt" "Plain TODO entry (with initial content if marked)" entry (file "")
	       "* TODO %?\n\n  %i")
	      ("tl" "TODO entry with link" entry (file "")
	       "* TODO %?\n\n  %a\n\n  %i")
	      ("tr" "Process email" entry (file "")
	       "* TODO %:subject\n  SCHEDULED: %^t\n  %a\n\n  %?")
	      ("te" "To Expense" entry (file "")
	       "* TODO %:subject  :EXPENSE:\n  SCHEDULED: %^t\n\n  %a\n")
	      ("tp" "New Project" entry (file "")
	       "* PROJ %^{Project Name}\n  :LOGBOOK:\n  - Added: %U\n  :END:")
	      ("tT" "Trip" entry (file "")
	       (file "templates/trip.org") :empty-lines 1)

	      ("l" "Log Learning" entry (file+datetree "learning.org")
	       "* %^{Title} %^g\n  %?")

	      ("n" "Note" entry (file+datetree "notes.org")
	       "* %^{Subject} %^g\n\n  %?"
	       :empty-lines 1
	       :clock-in t)

	      ("m" "Meter Readings")
	      ("mg" "Gas Meter" table-line (file "notes/gas-consumption.org")
	       "|%^{Reading Time}u|%^{Reading Value}|%^{Price Per Litre|0.7}"
	       :table-line-pos "II-1")
	      ("me" "Electricity Meter" table-line (file "notes/electricity-consumption.org")
	       "|%^{Reading Time}u|%^{Reading Value}|%^{Price Per Unit|0.1412}"
	       :table-line-pos "II-1")

	      ("P" "password" entry (file "~/org/passwords.org.gpg")
	       "* %^{Title}\n %^{URL}p %^{USERNAME}p %^{PASSWORD}p" :empty-lines 1)

	      ("b" "Blog Post" plain
	       (file capture-blog-post-file)
	       (file "templates/blog-post.org"))

	      ("r" "GTD Review" entry (file+datetree "GTDReview.org")
	       (file "templates/gtd-review.org")
	       :empty-lines 1
	       :jump-to-captured t)

	      ("i" "New Invoice" plain (file "invoices/Invoices.org")
	       (file "templates/invoice.org")
	       :empty-lines 1 :immediate-finish t :jump-to-captured t)))
    #+END_SRC

*** Babel

    I wrote a module for executing AppleScript from Babel. Let's install it, so
    we can make sure it works.

    #+BEGIN_SRC emacs-lisp
      (use-package ob-applescript)
    #+END_SRC

    Some initialisation settings for Org Babel is in order.

    I don't want export to execute babel stuff: I like to execute them manually
    before exporting. This is a security feature, as sometimes I have documents
    that log in to servers and does things.

    Ditaa requires a path to the installed Jar; this recently stopped working
    because I had upgraded Ditaa, and the Jar has a version number in its name.
    Now we look at the file system and grab the highest-versioned Jar available.

    When executing shell commands, I want to see the stderr output. We can
    achieve that by redirecting stderr to stdout. I got this from a post on the
    orgmode mailing list, I believe.

    #+BEGIN_SRC emacs-lisp
      ;; Tell Org where to find ditaa jar
      (setq org-ditaa-jar-path
	    (expand-file-name "~/.nix-profile/lib/ditaa.jar"))

      (setq org-plantuml-jar-path
	    (expand-file-name "~/.nix-profile/lib/plantuml.jar"))

      ;; Always include stderr output for shell
      (setq org-babel-default-header-args:sh
            '((:prologue . "exec 2>&1")
              (:epilogue . ":")))
    #+END_SRC

    We have to specify the list of languages we want to support so Orgmode knows
    to look out for them:

    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
	 (clojure . t)
	 (python . t)
	 (gnuplot . t)
	 (lilypond . t)
	 (ditaa . t)
	 (plantuml . t)
	 (applescript . t)
	 (dot . t)
	 (sql . t)
	 (shell . t)))
    #+END_SRC

*** Org Export

    I hate writing JIRA markup, so I wrote a JIRA export backend for Org mode.

    #+BEGIN_SRC emacs-lisp
      (use-package ox-jira)
      (require 'ox-latex)
      (setq org-export-backends '(html md freemind jira latex))
    #+END_SRC

*** Presenting

    Let's try presenting with Emacs.

    #+BEGIN_SRC emacs-lisp
      (use-package org-tree-slide
	:bind (("<f8>" . org-tree-slide-mode)
               ("S-<f8>" . org-tree-slide-skip-done-toggle)

               :map org-tree-slide-mode-map
               ("<f7>" . org-tree-slide-move-previous-tree)
               ("<f8>" . org-tree-slide-mode)
               ("<f9>" . org-tree-slide-move-next-tree)
               ("<f12>" . org-tree-slide-content)))
    #+END_SRC

*** Passwords

    #+BEGIN_SRC emacs-lisp
      (use-package org-passwords
	:after org
	:ensure nil
	:init

	(setq org-passwords-time-opened "30 min")

	;; Where's my passwords file?
	(setq org-passwords-file "~/org/passwords.org.gpg")

	:bind (("C-c P P" . org-passwords)
	       ("C-c P g" . org-passwords-generate-password)
	       :map org-passwords-mode-map
	       ("C-c C-c u" . org-passwords-copy-username)
	       ("C-c C-c p" . org-passwords-copy-password)
	       ("C-c C-c o" . org-passwords-open-url)))
    #+END_SRC

*** Invoicing

    I have a capture template that generate invoices. In it I use the following
    functions to generate the next invoice id.

    #+BEGIN_SRC emacs-lisp
      (defun all-invoice-ids ()
	(-non-nil
	 (org-map-entries (lambda ()
                            (org-entry-get nil "InvoiceId"))
                          nil
                          '("~/org/invoices/Invoices.org"))))

      (defun max-invoice-id ()
	(apply #'max
               (mapcar #'string-to-number
                       (all-invoice-ids))))

      (defun next-invoice-id ()
	(number-to-string
	 (+ 1
            (max-invoice-id))))
    #+END_SRC

    All my invoices go into the same file. In the template, it's used like this:

    #+BEGIN_SRC org
    * DRAFT Invoice #%(next-invoice-id)
    :PROPERTIES:
    :InvoiceId: %(next-invoice-id)
    :EXPORT_DATE: %(format-time-string "%-d %B, %Y" (org-read-date nil t "1"))
    :EXPORT_FILE_NAME: Invoice-%(next-invoice-id)
    :END:
    #+END_SRC

    I generally export each section separately, which is why I've got that
    =EXPORT_FILE_NAME= property in there.

*** Calendar

    I use calendar with org, so configure it here.

    #+BEGIN_SRC emacs-lisp
    ;; Prefer YMD to the crazy american MDY
    (setq calendar-date-style 'iso)

    ;; Include Calendar/Diary information in Agenda
    (setq org-agenda-include-diary t)
    #+END_SRC

    I prepare my invoice on the last weekday of the month. Here's a
    function to determine if that is today.

    #+BEGIN_SRC emacs-lisp
      (defun last-weekday-of-month-p (date)
	(let* ((day-of-week (calendar-day-of-week date))
               (month (calendar-extract-month date))
               (year (calendar-extract-year date))
               (last-month-day (calendar-last-day-of-month month year))
               (month-day (cadr date)))

          (or
           ;; it's the last day of the month & it is a weekday
           (and (eq month-day last-month-day)
		(memq day-of-week '(1 2 3 4 5)))

           ;; it's a friday, and it's the last-but-one or last-but-two days
           ;; of the month
           (and (eq day-of-week 5)
		(or (eq month-day (1- last-month-day))
                    (eq month-day (1- (1- last-month-day))))))))
    #+END_SRC

*** Publishing

    Publishing projects.

  #+BEGIN_SRC emacs-lisp
    (defun sb/org-html-format-drawer (name content)
      (concat "<div class=\"drawer " (downcase name) "\">\n"
	      "<h6>" (capitalize name) "</h6>\n"
	      content
	      "\n</div>"))

    (setq org-publish-project-alist
	  '(("www"
	     :components ("www-pages" "www-static" "www-rss"))

	    ("www-static"
	     :base-directory "~/blog"
	     :publishing-directory "~/public_html"
	     :base-extension "css\\|jpg\\|png\\|pdf\\|html"
	     :recursive t
	     :publishing-function org-publish-attachment)

	    ("www-pages"
	     :exclude ",.*"
	     :base-directory "~/blog"
	     :publishing-directory "~/public_html"
	     :publishing-function org-html-publish-to-html
	     :recursive t
	     :section-numbers nil
	     :time-stamp-file nil
	     :with-toc nil
	     :with-drawers t
	     :html-format-drawer-function sb/org-html-format-drawer

	     :html-html5-fancy t
	     :html-doctype "html5"
	     :html-footnotes-section "<div id=\"footnotes\"><!--%s-->%s</div>"
	     :html-link-up "/"
	     :html-link-home "/"
	     :html-home/up-format "
      <div id=\"org-div-home-and-up\">
	<nav>
	  <ul>
	    <li><a accesskey=\"H\" href=\"%s\"> Home </a> (<a href=\"/index.xml\">RSS</a>)</li>
	    <li><a accesskey=\"p\" href=\"/publications.html\"> Publications </a></li>
	    <li><a accesskey=\"A\" href=\"/about.html\"> About </a></li>
	    <li>Licence: <a accesskey=\"l\" href=\"https://creativecommons.org/licenses/by-sa/4.0/\">CC BY-SA 4.0</a></li>
	  </ul>
	</nav>
      </div>"
	     :html-head "
      <link rel=\"stylesheet\" type=\"text/css\" href=\"/etc/main.css\" />
      <link rel=\"icon\" type=\"image/png\" href=\"/etc/icon.png\" />
      <link rel=\"alternative\" type=\"application/rss+xml\"
	    href=\"https://www.brautaset.org/index.xml\"
	    title=\"Stig's Soapbox RSS Feed\" />
      <meta name=\"referrer\" content=\"same-origin\">
    "

	     :html-head-include-default-style nil
	     :html-head-include-scripts nil

	     :html-preamble nil
	     :html-postamble-format auto
	     :html-metadata-timestamp-format "%e %B %Y")

	    ("www-rss"
	     :base-directory "~/blog"
	     :base-extension "org"
	     :html-link-home "https://www.brautaset.org"
	     :html-link-use-abs-url t
	     :rss-extension "xml"
	     :publishing-directory "~/public_html"
	     :publishing-function (org-rss-publish-to-rss)
	     :section-numbers nil
	     :exclude ".*"              ;; To exclude all files...
	     :include ("index.org")     ;; ... except index.org.
	     :table-of-contents nil)))
  #+END_SRC

*** Blogging Support

    I create blog entries in a directory under =~/blog= and link to them
    from the main index page. It has so far been a manual job, but I
    have finally managed to create a function to automate it a bit.

    #+BEGIN_SRC emacs-lisp
      (defun sb/org-kw-get (key)
	"Return a lambda that takes an Org keyword element and returns
      its :value property if its :key property matches `key'."
	`(lambda (kw)
	   (if (equal ,key (org-element-property :key kw))
	       (org-element-property :value kw))))

      (defun sb/parse-metadata ()
	"Call in a blog post to get an entry suitable for linking to this
      post from the index page."
	(interactive)
	(let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
	       (tree (org-element-parse-buffer))

	       (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
	       (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY")))
	       (abstract
		(org-element-interpret-data
		 (org-element-map tree 'special-block
		   (lambda (sb)
		     (if (equal "abstract" (org-element-property :type sb))
			 (org-element-contents sb)))))))

	  (with-temp-buffer
	    (org-mode)
	    (org-insert-heading)

	    ;; Would have loved to use `org-insert-link' here but
	    ;; I can't stop it from presenting a prompt :-(
	    (insert "[[file:" path "][" title "]]")

	    (insert "\n\n")
	    (insert abstract)

	    (org-set-property "RSS_PERMALINK"
			      (format "%s.html"
				      (file-name-sans-extension path)))

	    ;; Need to go back to the first line to set tags
	    (goto-char (point-min))
	    (org-set-tags categories)

	    ;; Return the contents temporary buffer as a string *without properties*
	    (copy-region-as-kill
	     (point-min) (point-max)))))


      (defun sb/find-drafts ()
	"Find org files in `~/blog/articles' not already linked from
		    `~/blog/index.org'."
	(interactive)
	(let* ((prefix (expand-file-name "~/blog/"))
	       (posts
		(directory-files-recursively
		 (concat prefix "articles") ".org"))
	       (index-contents (get-string-from-file (concat prefix "index.org")))
	       (drafts (cl-remove-if (lambda (needle)
				       (string-match
					(string-remove-prefix prefix needle)
					index-contents))
				     posts))
	       (buffer-name "*blog drafts*"))
	  (if drafts
	      (progn
		(with-current-buffer (get-buffer-create buffer-name)
		  (erase-buffer)
		  (org-mode)
		  (insert
		   (mapconcat
		    (lambda (entry)
		      (format "- file:%s" entry))
		    drafts
		    "\n"))
		  (buffer-string))
		(unless (get-buffer-window buffer-name t)
		  (pop-to-buffer buffer-name nil t))
		(shrink-window-if-larger-than-buffer
		 (get-buffer-window buffer-name)))
	    (message "No drafts could be found!"))))
    #+END_SRC

*** Attachments

    One annoying thing is not being able to find attachments once
    you've attached files. Luckily, it turns out you can ask Org to
    create links to attachments.

    #+BEGIN_SRC emacs-lisp
    (setq org-attach-store-link-p t)
    #+END_SRC
*** Diffing Org files

    Sometimes I diff Org files. (Particularly for runbooks.) This
    snippet makes sure that Org buffers don't start folded, as ediff
    is rather useless in that case. (Credit: Oleh Krehel on
    emacs-orgmode mailing list.)

    #+BEGIN_SRC emacs-lisp
      (defun sb/ediff-prepare-buffer ()
	(when (memq major-mode '(org-mode emacs-lisp-mode))
	  (outline-show-all)))

      (add-hook 'ediff-prepare-buffer-hook #'sb/ediff-prepare-buffer)
    #+END_SRC
*** Org Download

    This allows me to drag-and-drop images into Org mode buffers.

    #+BEGIN_SRC emacs-lisp
    (use-package org-download)
    #+END_SRC
*** Edit "Org-like" lists in non-Org buffers

    #+begin_src emacs-lisp
    (use-package orgalist)
    (add-to-list 'message-mode-hook 'orgalist-mode)
    #+end_src
** Plant UML Mode

   I use this for [[http://plantuml.com/sequence.html][sequence diagrams]] etc.

   #+BEGIN_SRC emacs-lisp
     (use-package plantuml-mode
       :mode "\\.puml\\'"
       :init
       (setq plantuml-jar-path
	     (expand-file-name "~/.nix-profile/lib/plantuml.jar")))
   #+END_SRC

   This requires installing plantuml separately:

   #+BEGIN_SRC sh
     nix-env -i plantuml
   #+END_SRC

** Projectile

   I use Projectile to navigate my projects. Some of the things I like about
   it are that it provides the following key bindings:

   - =C-c p t= :: This switches from an implementation file to its test file,
                  or vice versa. I use this extensively in Clojure mode. It
                  might not make sense for all languages; YMMV.
   - =C-c p 4 t= :: The same, as above, but open the file in "other" buffer.
   - =C-c p s s= :: Ag search for something in this project. If point is at a
                    token, default to searching for that. (Mnemonic:
                    "Projectile Silver Searcher".)

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :bind ("C-c p" . projectile-command-map)
       :config
       (projectile-mode +1))
   #+END_SRC

** Put Custom settings in a separate file

   I prefer to code my configuration, but sometimes Custom settings are good
   enough. I prefer that such settings live in a separate file though. Load
   that file if it exists.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (if (file-exists-p custom-file)
         (load custom-file))
   #+END_SRC

** Python

   Work projects are all in Python. This is me exploring Emacs' Python
   support.

*** Elpy

    I'll try Elpy first because of its touted refactoring support.

   #+BEGIN_SRC emacs-lisp :noweb yes
     (use-package elpy
       :config
       (elpy-enable))
   #+END_SRC

*** Create a UTF-8 alias

    Our Python code tends to have the following lines:

    : # -*- coding: UTF-8 -*-

    These cause Emacs to have a sad and say:

    : Warning (mule): Invalid coding system 'UTF-8' is specified

    I don't want to change all of them, so let's just define an alias. (Thanks
    to Lucas Sampaio for this tip!)

    #+BEGIN_SRC emacs-lisp
      (define-coding-system-alias 'UTF-8 'utf-8)
    #+END_SRC
*** Convert between string types

    #+BEGIN_SRC emacs-lisp
      (use-package python-switch-quotes
	:bind ("C-c '" . python-switch-quotes))
    #+END_SRC

*** Pipenv

  #+BEGIN_SRC emacs-lisp
    (use-package pipenv
      :hook (python-mode . pipenv-mode)
      :init
      (setq pipenv-projectile-after-switch-function
	    #'pipenv-projectile-after-switch-extended))
  #+END_SRC

** Running tests

   Add a convenient keybinding for running tests interactively.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x t") 'ert)
   #+END_SRC

** Save minibuffer history

   This allows us to "tap up" in the minibuffer to recall previous items,
   even from a previous session.

   #+BEGIN_SRC emacs-lisp
     (savehist-mode 1)
   #+END_SRC

** Save my place in each file

   It's nice if Emacs knows where I was last time I opened a file.

   #+BEGIN_SRC emacs-lisp
     (setq-default save-place t)
     (setq save-place-file (concat user-emacs-directory "places"))
   #+END_SRC

** Set up Clipboard

   These settings improve pasting behaviour with programs outside Emacs.

   Save clipboard strings into the kill ring before replacing them. This is
   useful if you select something in Emacs, then select something from
   _another_ program. If you don't set this to non-nil the previous selection
   done from within Emacs is gone. This preserves it in the kill ring,
   enabling you to retrieve it.

   #+BEGIN_SRC emacs-lisp
     (setq save-interprogram-paste-before-kill t)
   #+END_SRC

   Copying ("yanking") with the mouse copies at point, rather than where you
   click.

   #+BEGIN_SRC emacs-lisp
     (setq mouse-yank-at-point t)
   #+END_SRC

** Set up modifier keys on OS X

   Set up the modifier keys the way that best fits my keyboard.

   #+BEGIN_SRC emacs-lisp
     ;; Both Command keys are 'Meta'
     (setq mac-right-command-modifier 'meta
	   mac-command-modifier 'meta)

     ;; Option or Alt is 'Super'
     (setq mac-option-modifier 'super)

     ;; Right Alt (option) can be used to enter symbols like em dashes '—' and euros '€' and stuff.
     (setq mac-right-option-modifier 'nil)

     (setq ns-function-modifier 'hyper)
   #+END_SRC

** Show Matching parens

   This is extremely useful. Put the mark on a paren (any of =()[]{}=,
   actually) and Emacs shows the matching closing/opening one.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode 1)
   #+END_SRC

** Show more "recent files" in =M-x b= window

   Keep up to 100 recent files, rather than the default of 20.

   #+BEGIN_SRC emacs-lisp
    (setq recentf-max-saved-items 100)
   #+END_SRC

** SmartParens

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens-config
       :ensure smartparens
       :diminish

       ;; I prefer to be explicit about the keybindings I use
       :bind (:map smartparens-mode-map
		   ("C-M-f" . sp-forward-sexp)
		   ("C-M-b" . sp-backward-sexp)
		   ("C-M-<SPC>" . sp-splice-sexp)
		   ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
		   ("C-<right>" . sp-forward-slurp-sexp)
		   ("C-<left>" . sp-forward-barf-sexp)
		   ("C-M-<left>" . sp-backward-slurp-sexp)
		   ("C-M-<right>" . sp-backward-barf-sexp))
       :config
       (show-smartparens-global-mode t))

     (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
     (add-hook 'text-mode-hook 'turn-on-smartparens-strict-mode)
   #+END_SRC

** Sphinx & reStructuredText

   I like to build Sphinx docs locally to check I've got the right syntax, and
   that links are accounted for. I use sphinx-fronted for that:

   #+BEGIN_SRC emacs-lisp
   (use-package sphinx-frontend)
   #+END_SRC

   That does require installing python, as OS X's default install doesn't come
   with pip:

   #+BEGIN_SRC sh
     nix-env -i python3
   #+END_SRC

   Then, we need to install sphinx itself:

   #+BEGIN_SRC sh
     pip install sphinx
   #+END_SRC

   While we're at it, turn on auto-complete for reStructuredText.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-complete-rst
       :mode "\\.rst\'"
       :config
       (auto-complete-rst-init)
       (setq auto-complete-rst-other-sources
             '(ac-source-filename
	       ac-source-abbrev
	       ac-source-dictionary
	       ac-source-yasnippet)))
   #+END_SRC

** Start the Emacs Daemon

   We want Emacs to be running its server so we can interact with it using =emacsclient=.

  #+BEGIN_SRC emacs-lisp
    (require 'server)
    (unless (server-running-p)
      (server-start))
  #+END_SRC

** Support for fullscreen

   I like to run apps in fullscreen mode. Unfortunately ediff merge, when running
   an Emacs version without Yamamoto's Mac patch set, doesn't really work in
   fullscreen---it ends up putting the small emerge control frame on a
   different screen. Because I like Emacs 25 (for up-to-date Gnus) I work
   around this problem by exiting fullscreen and just maximising the frame
   instead.

   Toggling frame maximation is already available as =M-<f10>=, so all we need
   to do is add a key binding to toggle fullscreen. I found this function at
   the [[https://www.emacswiki.org/emacs/FullScreen#toc26][EmacsWiki Fullscreen page]], and it does just that.

   #+BEGIN_SRC emacs-lisp
     (defun my-toggle-fullscreen ()
       "Toggle full screen"
       (interactive)
       (set-frame-parameter
        nil 'fullscreen
        (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

     (global-set-key (kbd "M-<f11>") 'my-toggle-fullscreen)
   #+END_SRC

   Sometimes (when using ediff) I don't use fullscreen. By resizing the window
   by pixels rather than characters we can still fill the entire screen.

   #+BEGIN_SRC emacs-lisp
     (setq frame-resize-pixelwise t)
   #+END_SRC

** Themes
*** Load one theme at a time

    For years I thought that theme switching in Emacs was broken---until
    I read Greg Hendershott's [[http://www.greghendershott.com/2017/02/emacs-themes.html][emacs themes]] blog post. It turns out Emacs
    supports /multiple themes being active at the same time/, which I'm
    sure is convenient sometimes but becomes a right nuisance when
    attempting to switch themes IMO. Add a utility function to disable
    all currently enabled themes first.

    #+BEGIN_SRC emacs-lisp
      (defun sb/disable-all-themes ()
	(interactive)
	(mapc #'disable-theme custom-enabled-themes))

      (defun sb/load-theme (theme)
	"Enhance `load-theme' by first disabling enabled themes."
	(sb/disable-all-themes)
	(load-theme theme))
    #+END_SRC

*** Hydra Theme Switching

    Switch themes with Hydra! This loads all available themes and
    presents a menu to let you switch between them. The theme switcher
    is bound to =C-c w t=.

    The switcher is, regretfully, not automatically updated when
    installing new themes from the package selector menu, so you need to
    evaluate this block again manually.

    #+BEGIN_SRC emacs-lisp
      (setq sb/hydra-selectors
	    "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

      (defun sb/sort-themes (themes)
	(sort themes (lambda (a b) (string< (symbol-name a) (symbol-name b)))))

      (defun sb/hydra-load-theme-heads (themes)
	(mapcar* (lambda (a b)
		   (list (char-to-string a) `(sb/load-theme ',b) (symbol-name b)))
		 sb/hydra-selectors themes))

      (defun sb/hydra-theme-switcher ()
	(interactive)
	(call-interactively
	 (eval `(defhydra sb/hydra-select-themes (:hint nil :color pink)
		  "Select Theme"
		  ,@(sb/hydra-load-theme-heads (sb/sort-themes (custom-available-themes)))
		  ("DEL" (sb/disable-all-themes))
		  ("RET" nil "done" :color blue)))))
    #+END_SRC

** Toggle Window Split function

   Sometimes a window is split horizontally, and you would prefer
   vertically. Or vice versa. This function can help! Just don't ask me how
   it works: I found it on StackOverflow. (I think. Again.)

   #+BEGIN_SRC emacs-lisp
     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
		       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
	       (funcall splitter)
	       (if this-win-2nd (other-window 1))
	       (set-window-buffer (selected-window) this-win-buffer)
	       (set-window-buffer (next-window) next-win-buffer)
	       (select-window first-win)
	       (if this-win-2nd (other-window 1))))))

     (define-key ctl-x-4-map "t" 'toggle-window-split)
   #+END_SRC

** Tramp

   Allow using sudo over ssh, so we can sudo to root remotely on a machine
   that does not allow root login.

   #+BEGIN_SRC emacs-lisp
     (set-default 'tramp-default-proxies-alist
                  (quote ((".*" "\\`root\\'" "/ssh:%h:"))))
   #+END_SRC

   For opening files using sudo locally, don't connect via SSH. (My local
   machine doesn't accept SSH connections.)

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'tramp-default-proxies-alist
                  '((regexp-quote (system-name)) nil nil))
   #+END_SRC

   If I don't set this then tramp will attempt to use OS X's tempfile
   directory on a remote machine, which does not work. I don't understand
   why it won't use the remote machine's temp directory automatically, but
   there you go.

   #+BEGIN_SRC emacs-lisp
     (setq temporary-file-directory "/tmp/")
   #+END_SRC

   Apparently using =ssh= is faster than the default =scp= mode, so let's use
   that.

   #+BEGIN_SRC emacs-lisp
   (setq tramp-default-method "ssh")
   #+END_SRC

   This function lets me re-open the currently open file using sudo[fn:1].
   I've bound it to =C-c C-s=. It works for both local and remote buffers.

   #+BEGIN_SRC emacs-lisp
     (defun sudo-edit-current-file ()
       (interactive)
       (let ((position (point)))
         (find-alternate-file
          (if (file-remote-p (buffer-file-name))
              (let ((vec (tramp-dissect-file-name (buffer-file-name))))
                (tramp-make-tramp-file-name
                 "sudo"
                 (tramp-file-name-user vec)
                 (tramp-file-name-host vec)
                 (tramp-file-name-localname vec)))
            (concat "/sudo:root@localhost:" (buffer-file-name))))
         (goto-char position)))
   #+END_SRC

   The man pages on my OS X local machine are very oqften different from the
   remote machines I'm logged in to. Thus, when in eshell, in a /remote/ path,
   I would like to display /remote/ man pages from that system. I'm not sure
   the regular man command can do that, but /woman/ can, with a bit of help.

   I've not /completely/ nailed this, so the useability is a bit rough. But
   with the below command in eshell you can do:

   #+BEGIN_EXAMPLE
   alias man 'tramp-aware-woman ${*man -c --path $1}'
   #+END_EXAMPLE

   Now you have an alias which will open a woman buffer with the /remote/ man
   page of the man page you want.

   #+BEGIN_SRC emacs-lisp
     (defun tramp-aware-woman (man-page-path)
       (interactive)
       (let ((dir (eshell/pwd)))
         (woman-find-file
          (if (file-remote-p dir)
              (let ((vec (tramp-dissect-file-name dir)))
                (tramp-make-tramp-file-name
                 (tramp-file-name-method vec)
                 (tramp-file-name-user vec)
                 (tramp-file-name-host vec)
                 man-page-path))
            man-page-path))))
   #+END_SRC

** Transparently open compressed files

   I *do* like it when Emacs transparently opens compressed files. It gives
   me the warm fuzzies.

   #+BEGIN_SRC emacs-lisp
     (auto-compression-mode t)
   #+END_SRC

** Trash

   This allows moving files to trash rather than deleting them from =dired=.
   Delete files by moving them to Trash. This way they _can_ be retrieved
   again.

   #+BEGIN_SRC emacs-lisp
     (use-package osx-trash
       :init
       (setq delete-by-moving-to-trash t)
       :config
       (osx-trash-setup))
   #+END_SRC

** Visual line mode / word wrapping

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'visual-line-mode)
   #+END_SRC

** Which Key Mode

   Show incomplete key cheatsheet.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config
       (which-key-mode))
   #+END_SRC

** Who Am I

   #+BEGIN_SRC emacs-lisp
   (setq user-full-name "Stig Brautaset")
   (setq user-mail-address "stig@brautaset.org")
   #+END_SRC
** Writing

   I'm not a great writer. I need all the crutches I can get. Lucklily,
   Emacs has them.

*** Writegood Mode

    This helps highlight passive voice, weasel words, etc in writing.

    #+BEGIN_SRC emacs-lisp
      (use-package writegood-mode
	:init
	(add-hook 'text-mode-hook 'writegood-mode))
    #+END_SRC

*** String Inflection

  Sometimes I need to swap between CamelCase and snake_case, or even
  SNAKE_CASE.

  #+begin_src emacs-lisp
    (use-package string-inflection
      :bind (("C-c C-s C-v" . string-inflection-all-cycle)
	     ("C-c C-s C-c" . string-inflection-camelcase)
	     ("C-c C-s C-k" . string-inflection-kebab-case)
	     ("C-c C-s C-u" . string-inflection-upcase)))
  #+end_src

** YAML

   #+BEGIN_SRC emacs-lisp
   (use-package yaml-mode)

   (use-package flymake-yaml
     :config
     (add-hook 'yaml-mode-hook 'flymake-yaml-load))
   #+END_SRC
** YAS

   YAS is a templating package. You can define mode-specific or global
   templates, and insert templates with keycombinations or triggered based on
   trigger words in the text.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :config
       (yas-global-mode))
   #+END_SRC

* Footnotes

[fn:1] Found at http://www.emacswiki.org/emacs/TrampMode#toc31
