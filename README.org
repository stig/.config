#+TITLE: My Emacs Setup
#+AUTHOR: Stig Brautaset
#+OPTIONS: f:t
#+PROPERTY: header-args:              :mkdirp yes
#+PROPERTY: header-args:emacs-lisp    :tangle ~/.emacs.d/init.el :results silent
#+STARTUP: content
* Introduction

  This is my Emacs configuration.  Because I'm forgetful, it is a
  [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming]] document: prose interspaced with code.  I edit
  this file, and /tangle/ it into [[file:init.el][init.el]] (and other config files) by
  hitting =C-c C-v C-t=.

* Installing

  I install Emacs from [[https://emacsformacosx.com/][emacsformacosx.com]].

  I install system dependencies (e.g. =notmuch=, =the-silver-searcher=
  et. al.) using [[https://nixos.org/nix/][Nix]]. (Via =use-package='s [[https://github.com/jwiegley/use-package#use-package-ensure-system-package][:ensure-system-package]]
  extension.)  How I install Nix:

  #+begin_src sh
    curl https://nixos.org/nix/install | sh
  #+end_src

* Early Init (turn off mouse interface)

  Emacs 27 automatically loads =~/.emacs.d/early-init.el= before
  initialising GUI components.  I turn off the mouse interface here to
  avoid momentary display during launch.  I also don't need to see a
  splash screen on every launch.  Finally I do /not like/ Emacs beeping
  at me: I prefer a visual bell.

  #+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/early-init.el
    (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (setq inhibit-startup-message t)
    (setq visible-bell t)
  #+END_SRC

** Emacs <27 Compatibility

   In older versions of Emacs we load ~early-init.el~ manually.  While
   Emacs 27 initialises packages before loading the user config, older
   ones does not: thus we also call =package-initialize= here.

   #+BEGIN_SRC emacs-lisp
    (if (not visible-bell)
	(progn
	  (load (expand-file-name "~/.emacs.d/early-init.el") t)
	  (require 'package)
	  (package-initialize)))
   #+END_SRC

* Configure package system & paths

  I do these early because I want them to apply even if I mess up
  later parts of my =init.el=.

** Package System

   A lot of my config installs packages from GNU elpa, MELPA, and Org
   elpa.  So we need to configure the package system now.

*** Make GNU ~package-archive~ work

    #+begin_src emacs-lisp
      ;; Required for the "gnu" elpa archive to work;
      ;; See https://github.com/bbatsov/prelude/issues/1225#issuecomment-511266025
      (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
    #+end_src

*** Add Melpa and Org ELPA to ~package-archives~

    We need to add the URLs of the package archives we want to use.  I
    install most packages via Melpa Stable Nix, but some from
    unstable.  I need the =org= archive because I use some =org-contrib=
    stuff that doesn't make it into Emacs proper.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
      (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
      (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
    #+END_SRC

*** Install & configure ~use-package~

    Install ~use-package~ and configure it to install packages from
    stable MELPA archive by default.  For packages that need it I
    override this by putting =:pin $repo= in the =use-config= stanza.

    #+begin_src emacs-lisp
      ;; Automatically :ensure packages.
      (setq use-package-always-ensure t)

      ;; Default value for :pin in each use-package.
      (setq use-package-always-pin "melpa-stable")

      ;; Bootstrap use-package & dependencies
      (seq-doseq (package '(use-package bind-key diminish))
	(unless (package-installed-p package)
	  (package-refresh-contents)
	  (package-install package)))

      (eval-when-compile
	(require 'use-package))
      (require 'diminish)
      (require 'bind-key)
    #+end_src

*** Install =:ensure-system-package= extension

    This allows =use-package= to install system packages.

    #+begin_src emacs-lisp
      (use-package use-package-ensure-system-package
	:ensure t
	:custom
	(system-packages-package-manager 'nix))
    #+end_src

** Add Nix's =site-lisp= directory to ~load-path~

   #+begin_src emacs-lisp
     (add-to-list 'load-path (expand-file-name "~/.nix-profile/share/emacs/site-lisp/"))
   #+end_src

** Path

    The GUI Emacs gets exec path from the system, rather than the
    login shell.  We have to load PATH et. al. from the shell to get
    access to programs installed by Nix.

*** Configure the login shell

    I use Zsh as my login shell.  It feels a bit weird to set it up
    here, but it's the best way I have found so far.

    Zsh reads =~/.zshenv= first, for both interactive and
    non-interactive shells.  It's where we should set up PATH, etc.
    Currently I only use it to source my /Nix/ profile.

    #+begin_src sh :tangle ~/.zshenv
      . ~/.nix-profile/etc/profile.d/nix.sh
    #+end_src

    =~/.zshrc= is for interactive shells.  This doesn't affect Emacs,
    but it's useful as a fallback if I have to open a regular terminal
    window.  (E.g. if I screw up my Emacs config.)

    #+begin_src sh :tangle ~/.zshrc
      setopt INC_APPEND_HISTORY
      setopt HIST_IGNORE_ALL_DUPS

      export HISTFILE=~/.zsh_history
      export SAVEHIST=800
      export HISTSIZE=1000

      export EDITOR=emacsclient
    #+end_src

*** Set =PATH= etc from the login shell

    Copy PATH and certain other variables from my login shell so these
    variables are available in Eshell.  (And elsewhere in Emacs.)

    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
	:custom
	(exec-path-from-shell-variables '("PATH" "MANPATH"
					  "NIX_PATH" "NIX_SSL_CERT_FILE"
					  "LDFLAGS" "CPPFLAGS"))
	:config
	(exec-path-from-shell-initialize))
    #+END_SRC

* Configure the basics (affecting all modes etc)
** Clipboard

   These settings improve pasting behaviour with programs outside
   Emacs.  Save clipboard text into kill ring before replacing them.
   Copying with the mouse copies at point, rather than where you
   click.

   #+BEGIN_SRC emacs-lisp
     (setq save-interprogram-paste-before-kill t)
     (setq mouse-yank-at-point t)
   #+END_SRC

** Disable kill-emacs

   Disable =s-q= (=kill-emacs=) as it is too close to =M-q= which I use for
   reflowing text.

   #+BEGIN_SRC emacs-lisp
     (bind-key "s-q" nil)
   #+END_SRC

** End all files in a newline

   All files should end in a newline. Insert one if there isn't one already.

   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC

** Introduce Myself

   In case something needs my name/email address.

   #+BEGIN_SRC emacs-lisp
   (setq user-full-name "Stig Brautaset")
   (setq user-mail-address "stig@brautaset.org")
   #+END_SRC

** Make 'y' and 'n' satisfy prompts

   Answering just 'y' or 'n' will do, rather than having to spell out "yes"
   or "no".

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Make mouse scrolling smoother

   The adaptive mouse scrolling is far, far too quick so let's turn that off.

   #+BEGIN_SRC emacs-lisp
   (setq mouse-wheel-progressive-speed nil)
   (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))))
   #+END_SRC

** Make the fonts bigger

   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'default nil :height 150)
   #+END_SRC

** Modifier keys on OS X

   Set up the modifier keys the way that best fits my keyboard.

   #+BEGIN_SRC emacs-lisp
     ;; Both Command keys are 'Meta'
     (setq mac-right-command-modifier 'meta
	   mac-command-modifier 'meta)

     ;; Option or Alt is 'Super'
     (setq mac-option-modifier 'super)

     ;; Right Alt (option) can be used to enter symbols like em dashes '—' and euros '€' and stuff.
     (setq mac-right-option-modifier 'nil)

     (setq ns-function-modifier 'hyper)
   #+END_SRC

** Put =Customize= settings in a separate file

   I prefer to code my configuration, but sometimes Custom settings are good
   enough. I prefer that such settings live in a separate file though. Load
   that file if it exists.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (if (file-exists-p custom-file)
         (load custom-file))
   #+END_SRC

** Save my place in each file

   It's nice if Emacs knows where I was last time I opened a file.

   #+BEGIN_SRC emacs-lisp
     (setq-default save-place t)
     (setq save-place-file (concat user-emacs-directory "places"))
   #+END_SRC

** Store backup files in =~/.emacs.d/backups=

   I don't like backup files (those dreaded =foo~= ones) all over my disk.
   This places them in =~/.emacs.d/backups=.

   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
   #+END_SRC

** UTF-8: everywhere, always

   Let's always use UTF-8 encoding. Pretty, pretty please with sugar on top.

   #+BEGIN_SRC emacs-lisp
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+END_SRC

* Configure misc things
** Ace Window

   #+begin_src emacs-lisp
   (use-package ace-window
     :bind ("M-`" . ace-window))
   #+end_src

** Add keybinding to join next line to this

   With cursor at any point in a line, hit =M-j= to move to the end, and
   delete the newline. Leave the cursor where the newline used to be.

   #+BEGIN_SRC emacs-lisp
     (bind-key "M-j" (lambda ()
		       (interactive)
		       (join-line -1)))
   #+END_SRC

** Diary (Calendar) Functions

   Prefer YMD to the /crazy/ american MDY order.

   I schedule some things every weekday,
   so add a convenience function for that.

   #+BEGIN_SRC emacs-lisp
     (setq calendar-date-style 'iso)

     (defun sb/weekday-p (date)
       "Is `date' a weekday?"
       (memq (calendar-day-of-week date) '(1 2 3 4 5)))
   #+END_SRC

** Git Link

   Lets me link to a file location on GitHub/Bitbucket/GitLab
   from a local git repository.

   #+BEGIN_SRC emacs-lisp
     (use-package git-link
       :bind ("C-c g l" . git-link))
   #+END_SRC

** GnuPG

   Emacs will open =.gpg= files transparently, but I need to install
   gnupg for that to work.

   #+begin_src emacs-lisp
     (use-package gnupg
       :ensure nil
       :ensure-system-package ((gpg2 . gnupg) pinentry)
       :no-require t)
   #+end_src

** Ivy

   I've long been a happy Helm user, but it confuses me (and is slow!)
   in some situations so I thought I'd try again to see if Ivy fares
   any better.

   #+begin_src emacs-lisp
     (use-package ivy
       :pin melpa
       :demand
       :config
       (setq ivy-use-virtual-buffers t
	     ivy-count-format "%d/%d "))
     (ivy-mode 1)

     ;; This should apparently allow opening multiple files from
     ;; ivy-find-file.
     (use-package ivy-hydra
       :pin melpa)
   #+end_src

** Multiple Cursors

   This package is another one of those near-magical ones. It allows me to do
   multiple edits in the same buffer, using several cursors. You can think of
   it as an interactive macro, where you can constantly see what's being done.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors

       :bind (("C-c M-e" . mc/edit-lines)
              ("C-c M-a" . mc/mark-all-dwim)
              ("s-n" . mc/mark-next-like-this)
              ("s-p" . mc/mark-previous-like-this)))
   #+END_SRC

** Running tests

   Add a convenient keybinding for running tests interactively.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x t" 'ert)
   #+END_SRC

** String Inflection

   Sometimes I need to swap between CamelCase and snake_case, or even
   SNAKE_CASE.

   #+begin_src emacs-lisp
     (use-package string-inflection
       :bind (("C-c C-x C-s" . string-inflection-all-cycle)
	      ("C-c C-x C-c" . string-inflection-camelcase)
	      ("C-c C-x C-k" . string-inflection-kebab-case)
	      ("C-c C-x C-u" . string-inflection-upcase)))
   #+end_src

** Support for fullscreen

   I like to run apps in fullscreen mode. Sometimes it's useful to be
   able to toggle it on or off, which this function does. I found it
   at the [[https://www.emacswiki.org/emacs/FullScreen#toc26][EmacsWiki Fullscreen page]].

   #+BEGIN_SRC emacs-lisp
     (defun my-toggle-fullscreen ()
       "Toggle full screen"
       (interactive)
       (set-frame-parameter
        nil 'fullscreen
        (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

     (bind-key "M-<f11>" 'my-toggle-fullscreen)
   #+END_SRC

** Toggle Window Split function

   Sometimes a window is split horizontally, and you would prefer
   vertically. Or vice versa. This function can help! Just don't ask me how
   it works: I found it on StackOverflow. (I think. Again.)

   #+BEGIN_SRC emacs-lisp
     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
		       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
	       (funcall splitter)
	       (if this-win-2nd (other-window 1))
	       (set-window-buffer (selected-window) this-win-buffer)
	       (set-window-buffer (next-window) next-win-buffer)
	       (select-window first-win)
	       (if this-win-2nd (other-window 1))))))

     (define-key ctl-x-4-map "t" 'toggle-window-split)
   #+END_SRC

** Unfill paragraphs and regions

   The default binding for =M-q= fills a paragraph. Very good. But
   sometimes I want to /unfill/[fn:: Particularly when editing markdown
   that is going to end up on GitHub, as otherwise the result has lots
   of hard linebreaks. This happens every time I edit a PR description
   in Magit, for example.]. [[https://stackoverflow.com/a/2478549/5950][Credit]].

   #+begin_src emacs-lisp
     (defun sb/unfill-paragraph ()
       (interactive)
       (let ((fill-column (point-max)))
	 (fill-paragraph nil)))

     (defun sb/fill-or-unfill-paragraph (arg)
       "Fill a paragraph. If called with a `C-u' prefix, /unfill/ a paragraph."
       (interactive "P")
       (if arg
	   (sb/unfill-paragraph)
	 (fill-paragraph)))

     (bind-key "M-q" 'sb/fill-or-unfill-paragraph)

     (defun sb/unfill-region ()
       (interactive)
       (let ((fill-column (point-max)))
	 (fill-region (region-beginning) (region-end) nil)))
   #+end_src

* Configure minor modes
** Aggressive Indent

   I like to keep my code indented properly at all times. Aggressive-indent
   helps ensure this. Turn it on for lisp modes.

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :hook
       (emacs-lisp-mode-hook . aggressive-indent-mode)
       (clojure-mode-hook . aggressive-indent-mode)
       (css-mode-hook . aggressive-indent-mode))
   #+END_SRC

** Auto commit

   In some projects (notably, my Org/Agenda setup) I want to
   automatically commit when editing files.

   #+BEGIN_SRC emacs-lisp
     (use-package git-auto-commit-mode)
   #+END_SRC

** Auto revert mode

   When files change on disk, revert the buffer automatically.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
   #+END_SRC

** Beacon

   Highlight my cursor when scrolling

   #+begin_src emacs-lisp
     (use-package beacon
       :pin gnu
       :config
       (beacon-mode 1))
   #+end_src

** Company

   Auto-complete of code and prose.

   #+BEGIN_SRC emacs-lisp
   (use-package company
     :init
     ;; https://emacs.stackexchange.com/a/10838
     (setq company-dabbrev-downcase nil)
     :config
     (global-company-mode))
   #+END_SRC

** Counsel

   This provides =counsel-find-file=, among others.

   #+begin_src emacs-lisp
   (use-package amx) ;; make counsel-M-x work the way I like
   (use-package counsel)
   (counsel-mode 1)
   #+end_src

** Direnv

   #+begin_src emacs-lisp
     (use-package direnv
       :ensure-system-package direnv
       :config
       (direnv-mode))
   #+end_src

** Edit "Org-like" lists in non-Org buffers

   #+begin_src emacs-lisp
   (use-package orgalist
     :pin gnu
     :hook
     (message-mode-hook . orgalist-mode))
   #+end_src

** Editorconfig

   Some projects I touch, particularly at work, use [[http://editorconfig.org][editorconfig]] to set up
   their indentation and file format preferences.

   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :ensure-system-package (editorconfig . editorconfig-core-c)
       :custom
       (editorconfig-exclude-modes (quote (org-mode gist)))
       :config
       (editorconfig-mode))
   #+END_SRC

** Highlight & deal with whitespace annoyances

   This highlights certain whitespace annoyances, and adds a key binding to
   clean it up.

   #+BEGIN_SRC emacs-lisp
     (use-package whitespace
       :ensure nil
       :bind ("C-c w" . whitespace-cleanup)
       :init
       (setq whitespace-style '(face empty tabs trailing))
       :config
       (global-whitespace-mode t))
   #+END_SRC

** Iedit

   Edit multiple symbols in one go. Similar in some respects to
   Multiple Cursors, but seems a little more light-weight.

   #+begin_src emacs-lisp
   (use-package iedit :pin melpa)
   #+end_src

** Projectile

   I use Projectile to navigate my projects. Some of the things I like about
   it are that it provides the following key bindings:

   - =C-c p t= :: This switches from an implementation file to its test file,
                  or vice versa. I use this extensively in Clojure mode. It
                  might not make sense for all languages; YMMV.
   - =C-c p 4 t= :: The same, as above, but open the file in "other" buffer.
   - =C-c p s s= :: Ag search for something in this project. If point is at a
                    token, default to searching for that. (Mnemonic:
                    "Projectile Silver Searcher".)

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :bind ("C-c p" . projectile-command-map)
       :demand
       :init
       (setq projectile-completion-system 'ivy)
       :config
       (projectile-mode +1))


     ;; Register project subtype used by "gilded rose" kata.
     (projectile-register-project-type 'lein-spec '("project.clj" "spec")
				       :compile "lein compile"
				       :test "lein test"
				       :test-suffix "_spec")

     (use-package counsel-projectile)
   #+END_SRC

** Save minibuffer history

   This allows us to "tap up" in the minibuffer to recall previous items,
   even from a previous session.

   #+BEGIN_SRC emacs-lisp
     (savehist-mode 1)
   #+END_SRC

** Show Matching parens

   This is extremely useful. Put the mark on a paren (any of =()[]{}=,
   actually) and Emacs shows the matching closing/opening one.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode 1)
   #+END_SRC

** SmartParens

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens-config
       :ensure smartparens

       ;; I prefer to be explicit about the keybindings I use
       :bind (:map smartparens-mode-map
		   ("C-M-f" . sp-forward-sexp)
		   ("C-M-b" . sp-backward-sexp)
		   ("C-M-<SPC>" . sp-splice-sexp)
		   ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
		   ("C-<right>" . sp-forward-slurp-sexp)
		   ("C-<left>" . sp-forward-barf-sexp)
		   ("C-M-<left>" . sp-backward-slurp-sexp)
		   ("C-M-<right>" . sp-backward-barf-sexp))
       :hook
       (prog-mode-hook . turn-on-smartparens-strict-mode)
       (text-mode-hook . turn-on-smartparens-mode)

       :config
       (show-smartparens-global-mode t))
   #+END_SRC

** Swiper

   Invoke swiper (find in current buffer).

   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :bind (("C-x /" . swiper)))
   #+END_SRC

** Transparently open compressed files

   I *do* like it when Emacs transparently opens compressed files. It gives
   me the warm fuzzies.

   #+BEGIN_SRC emacs-lisp
     (auto-compression-mode t)
   #+END_SRC

** Visual line mode / word wrapping

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'visual-line-mode)
   #+END_SRC

** Which Key Mode

   Show incomplete key cheatsheet.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config
       (which-key-mode))
   #+END_SRC

** Writegood Mode

   I'm not a great writer. I need all the crutches I can get. Lucklily,
   Emacs has them.

   This helps highlight passive voice, weasel words, etc in writing.

   #+BEGIN_SRC emacs-lisp
     (use-package writegood-mode
       :hook text-mode-hook)
   #+END_SRC

* Configure major modes
** Ag (The Silver Searcher)

   I use =ag= for searching a lot in Emacs. Its "writable grep"
   companion mode is pretty close to magic. When in a buffer showing
   ag results, try hitting =C-c C-p=--this lets you /edit the results of
   the search right from the ag results buffer!/ Just hit =C-x C-s= to
   save the results.

   If you hit =C-c C-p= while already in writable grep mode you can
   delete the entire matched line by hitting =C-c C-d=.

   #+BEGIN_SRC emacs-lisp
     (use-package ag
       :pin melpa
       :ensure-system-package (ag . silver-searcher)
       :custom
       (ag-arguments (quote ("--smart-case" "--stats" "--hidden")))
       (ag-ignore-list (quote (".git"))))

     (use-package wgrep :pin melpa)
     (use-package wgrep-ag
       :pin melpa
       :hook
       (ag-mode-hook . wgrep-ag-setup))

     ;; This fixes the last group not being editable until it's fixed
     ;; upstream, cf https://github.com/mhayashi1120/Emacs-wgrep/pull/61
     (eval-after-load "wgrep-ag"
       '(defun wgrep-ag-prepare-header/footer ()
	  (save-excursion
	    (goto-char (point-min))
	    ;; Look for the first useful result line.
	    (if (re-search-forward (concat wgrep-ag-grouped-result-file-regexp
					   "\\|"
					   wgrep-ag-ungrouped-result-regexp))
		(add-text-properties (point-min) (line-beginning-position)
				     '(read-only t wgrep-header t))
	      ;; No results in this buffer, let's mark the whole thing as
	      ;; header.
	      (add-text-properties (point-min) (point-max)
				   '(read-only t wgrep-header t)))

	    ;; OK, header dealt with. Now let's try find the footer.
	    (goto-char (point-max))
	    (re-search-backward "^\\(?:-[^:]+?:[[:digit:]]+:[[:digit:]]+:\\)" nil t)
	    ;; Point is now at the beginning of the result nearest the end
	    ;; of the buffer, AKA the last result.  Move to the start of
	    ;; the line after the last result, and mark everything from
	    ;; that line forward as wgrep-footer.  If we can't move to the
	    ;; line after the last line then there apparently is no
	    ;; footer.
	    (when (zerop (forward-line 1))
	      (add-text-properties (point) (point-max)
				   '(read-only t wgrep-footer t))))))
   #+END_SRC

** Clojure

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :ensure-system-package clojure)
     (use-package clojure-mode-extra-font-locking)
     (use-package cider
       :custom
       (cider-eldoc-display-context-dependent-info t))
     (use-package clj-refactor)
   #+END_SRC

** Ediff

   Sometimes I have to resolve conflicts. I use Ediff, which I
   (usually) launch from Magit.

*** Automatically Unfold Org files

    This snippet makes sure that Org buffers don't start folded, as
    ediff is rather useless in that case. (Credit: Oleh Krehel on
    emacs-orgmode mailing list.)

    #+BEGIN_SRC emacs-lisp
      (defun sb/ediff-prepare-buffer ()
	(when (memq major-mode '(org-mode emacs-lisp-mode))
	  (outline-show-all)))

      (add-hook 'ediff-prepare-buffer-hook #'sb/ediff-prepare-buffer)
    #+END_SRC

*** Picking /both/ sides in a conflict

    If both branches add an entry to a list I may want to pick *both*
    sides. This adds =d= as a shortcut to do that. ([[http://stackoverflow.com/a/29757750/5950][Credits]].) I can use
    =~= to swap the A and B buffers, which lets me choose A then B, /or/ B
    then A.

    #+BEGIN_SRC emacs-lisp
      (defun sb/ediff-copy-both-to-C ()
	(interactive)
	(ediff-copy-diff ediff-current-difference nil 'C nil
			 (concat
			  (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
			  (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

      (defun sb/add-d-to-ediff-mode-map ()
	(define-key ediff-mode-map "d" 'sb/ediff-copy-both-to-C))

      (add-hook 'ediff-keymap-setup-hook 'sb/add-d-to-ediff-mode-map)
    #+END_SRC

** Elfeed

   I use custom.el for the actual feeds.

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :bind ("C-x w" . elfeed)
       :ensure-system-package curl
       :config
       (defalias 'elfeed-toggle-star
	 (elfeed-expose #'elfeed-search-toggle-all 'star))

       (eval-after-load 'elfeed-search
	 '(define-key elfeed-search-mode-map (kbd "m") 'elfeed-toggle-star)))
   #+END_SRC

** Eshell

   I have started using /Eshell/. It is close to magic. There's not a lot of
   setup (it has its own [[file:eshell/alias][alias file]]), but I've got a keybinding to bring up
   eshell quickly. This launches eshell if it is not already running, or
   switches to it if it is.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c s" 'eshell)

     ;; This helps with aws cli commands, and nix-env --help, a bit
     (setenv "PAGER" "cat")
   #+END_SRC

   Eshell is great, and its Tramp integration allows me to open remote files
   in local Emacs seamlessly with the =find-file= command. (Which I have
   aliased to =ff=.) Eshell also makes sure that my shell behaves the same,
   and has the same config, whether I am on a local machine or a remote one.

** Graphviz

   I sometimes use Graphviz to create diagrams.

   I also have to tell Emacs how to launch GraphViz.

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :ensure-system-package graphviz
       :bind ("C-c C-p" . graphviz-dot-preview))
   #+END_SRC

** IRC

   But /of course/ Emacs has a built-in IRC client. In fact it has two! But I
   digress. Let's use the oldest one, and configure it slightly.

   #+BEGIN_SRC emacs-lisp
   (setq rcirc-default-nick "stigbra")
   (setq rcirc-default-full-name "Stig Brautaset")
   #+END_SRC

** LilyPond

   With Nix I am not able to install LilyPond, but I can install it
   via a download from https://lilypond.org.

   #+begin_src emacs-lisp
     (use-package lilypond-mode
       :load-path "/Applications/LilyPond.app/Contents/Resources/share/emacs/site-lisp"
       :mode (("\\.ily\\'" . LilyPond-mode)
	      ("\\.ly\\'" . LilyPond-mode))
       :hook (LilyPond-mode-hook . (lambda () (turn-on-font-lock)))
       :custom
       (LilyPond-midi-command "playmidi" t)
       (LilyPond-pdf-command "open"))
   #+end_src

*** Creating the =playmidi= shell script

    We can play midi files with fluidsynth, but the invocation isn't
    the nicest.  I wrap it in a shell script.  First I have to install
    it, however.

    #+begin_src emacs-lisp
      (use-package fluidsynth
	:ensure nil
	:no-require t
	:ensure-system-package fluidsynth)
    #+end_src

    Then we need a soundfont. Fluidsynth appears to recommend the one
    from http://www.schristiancollins.com/generaluser.php.

    #+begin_src sh :tangle ~/.local/bin/download_soundfont :tangle-mode (identity #o755) :mkdirp t
      #!/bin/bash
      set -o errexit
      set -o nounset
      set -o pipefail

      tempfoo=`basename $0`
      TMPDIR=`mktemp -d -t ${tempfoo}`

      VERSION="1.471"

      mkdir -p ~/.local/share
      TARGET=~/.local/share/GeneralUserGS
      if test -d $TARGET ; then
          mv $TARGET $TARGET.$(date +%Y-%m-%d).$RANDOM
      fi

      DL=GeneralUser_GS_$VERSION
      curl -L https://www.dropbox.com/s/4x27l49kxcwamp5/GeneralUser_GS_$VERSION.zip?dl=1 -o ~/Downloads/$DL.zip
      cd $TMPDIR
      unzip ~/Downloads/$DL.zip

      mv "$(find $TMPDIR -mindepth 1 -maxdepth 1 -type d)" "$TARGET"

      rmdir $TMPDIR
    #+end_src


    Finally let's install a wrapper to more easily play stuff.

    #+begin_src sh :tangle  ~/.local/bin/playmidi :tangle-mode (identity #o755)
      #!/bin/bash
      set -o errexit
      set -o nounset
      set -o pipefail

      if ! test -d ~/.local/share/GeneralUserGS ; then
	echo "No soundfonts found, attempting to download..."
	download_soundfont
      fi

      fluidsynth -a coreaudio -m coremidi -ni ~/.local/share/GeneralUserGS/GeneralUser\ GS\ v1.471.sf2 "$@"
    #+end_src

** Magit

   I use [[http://magit.vc][Magit]] all day. If you use git a lot it's possibly worth switching to
   Emacs just for it. It is excellent. I bind =M-m= to =magit-status=, which is
   the main entry point for the mode.

   Forge is an extension to Magit that interacts with GitHub / GitLab etc.

   #+BEGIN_SRC emacs-lisp
     (use-package transient :pin melpa)
     (use-package magit
       :pin melpa
       :bind ("M-m" . magit-status))

     (use-package forge :pin melpa)
     (use-package magit-org-todos :pin melpa)
     (use-package magit-todos :pin melpa)
   #+END_SRC

** Markdown

   I'm a sucker for lists, and I want to be able to reorder list items
   easily and have them renumbered automatically.

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :pin melpa
       :bind (("M-<up>" . markdown-move-list-item-up)
	      ("M-<down>" . markdown-move-list-item-down))
       :custom
       (markdown-asymmetric-header t))
   #+END_SRC
** Nix

   Some modules useful for Nix.

   #+BEGIN_SRC emacs-lisp
     (use-package nix-mode :pin melpa)
     (use-package nix-sandbox :pin melpa)
   #+END_SRC

** Notmuch

   I like to use Emacs for /all/ writing, including email.  I don't want
   a separate program to read and write emails, so it follows I must
   /read/ email in Emacs too.  I currently use [[https://notmuchmail.org][Notmuch]] for this.  I find
   it easier to configure than [[http://www.djcbsoftware.nl/code/mu/][mu4e]].

   Notmuch works pretty well for me out of the box. Mainly I set up a
   keybinding to quickly bring it up.  Its threading and MIME handling
   appears a lot better than mu4e, from a cursory glance.

   Notmuch's Emacs bindings are closely tied to the binary programs, so
   they (strongly) recommend that you don't install Notmuch from ELPA.
   I use [[http://msmtp.sourceforge.net/][msmtp]] for sending email, and [[http://isync.sourceforge.net][mbsync]] for syncing IMAP messages
   between my local machine and upstream servers.

   I configure Notmuch to save a copy of outgoing mail into my sent
   mail folder.

   #+BEGIN_SRC emacs-lisp
     (use-package notmuch
       :ensure nil
       :ensure-system-package (notmuch msmtp (mbsync . isync))
       :hook
       (notmuch-message-mode-hook . turn-off-auto-fill)
       :bind (("C-x m" . sb/notmuch)
	      ("M-]" . notmuch-cycle-notmuch-buffers))
       :custom
       (notmuch-hello-thousands-separator ",")
       (notmuch-mua-cite-function (quote message-cite-original-without-signature))
       (notmuch-fcc-dirs "sent +sent -unread -inbox")

       :config
       (defun sb/notmuch (arg)
	 "Launch notmuch. If ran with prefix arg, launch mbsync in the
     background, and automatically refresh the current buffer when
     done. With two prefix args, launch mbsync with `--all` rather
     than just for inboxes."
	 (interactive "p")
	 (notmuch)
	 (if (> arg 1)
	     (set-process-sentinel
	      (sb/mbsync (if (eq 4 arg) "inbox" "--all"))
	      (lambda (proc state)
		(message nil) ;; clear minibuffer
		(notmuch-poll-and-refresh-this-buffer))))))
   #+END_SRC

*** Configuring NotMuch before first use

    After installing NotMuch I ran =notmuch setup= to configure it.  Then
    I ran =notmuch new= to index my existing mail.  (This was already in
    =~/Maildir/= since I've been using mu4e before.)  You can also set
    config values independently.  That is my preference now, as I can
    do everything from this file.

    #+begin_src sh :results silent
      notmuch config set database.path ~/Mail
      notmuch config set user.name "Stig Brautaset"
      notmuch config set user.primary_email "stig@brautaset.org"
      notmuch config set user.other_email "stig.brautaset@icloud.com"
      notmuch config set new.tags 'new;unread;inbox'
      notmuch config set new.ignore '.mbsyncstate;.mbsyncstate.journal;.mbsyncstate.lock;.mbsyncstate.new;.uidvalidity;.isyncuidmap.db'
      notmuch config set search.exclude_tags 'deleted;spam;muted'
    #+end_src

    We can now read the config back in, to verify our change.

    #+BEGIN_SRC sh :results output replace :exports results :tangle no
    notmuch config list
    #+END_SRC

    #+RESULTS:
    #+begin_example
    database.path=/Users/stig/Mail
    user.name=Stig Brautaset
    user.primary_email=stig@brautaset.org
    user.other_email=stig.brautaset@icloud.com;
    new.tags=new;unread;inbox;
    new.ignore=
    search.exclude_tags=deleted;spam;muted;
    maildir.synchronize_flags=true
    built_with.compact=true
    built_with.field_processor=true
    built_with.retry_lock=true
    #+end_example

*** Write =pre-new= and =post-new= hook scripts

    Remove the =new= tag from any messages just before refreshing.  Do
    this in a =pre-hook= so we can use the new =new= tag to optimise
    further tagging in the =post-hook= below.

    #+BEGIN_SRC sh :tangle ~/Mail/.notmuch/hooks/pre-new :shebang #!/bin/zsh :tangle-mode (identity #o755) :mkdirp t
      notmuch tag -new -- tag:new
      notmuch search --output files tag:draft and tag:deleted | xargs rm
    #+END_SRC

    Notmuch assigns the =new= tag when it first sees a message, so we
    can use it to limit the search space for further tagging.

    #+BEGIN_SRC sh :tangle ~/Mail/.notmuch/hooks/post-new :shebang #!/bin/zsh :tangle-mode (identity #o755) :mkdirp t
      notmuch tag --batch <<EOF
      # Mute new messages to muted threads
      +muted -- thread:{tag:muted} and tag:new

      # Tag previously unseen messages
      +sent -- path:/sent/ and tag:new
      -inbox -- path:/archive/ and tag:new

      # Add specific tags for mailing lists, and remove from inbox
      +lists +org-mode -inbox -- path:/org-mode/ and tag:new
      +lists +lilypond -inbox -- path:/lilypond/ and tag:new
      +lists +clojure -inbox -- path:/clojure/ and tag:new

      # V. low volume lists gets to stay in inbox
      +lists +tuls -- path:/tuls/ and tag:new

      +lobsters -- tag:new and from:lobste.rs
      EOF
    #+END_SRC

*** Configure mbsync to download email

    I use =mbsync= (from the isync suite) to sync mail from my IMAP
    server to my local machine.

    #+BEGIN_SRC conf :tangle ~/.mbsyncrc
      IMAPAccount gandi
      Host mail.gandi.net
      User stig@brautaset.org
      SSLType IMAPS
      AuthMechs LOGIN
      PassCmd "security find-generic-password -s mbsync-gandi-password -w"
      # To rotate:
      # > security delete-generic-password -s mbsync-gandi-password
      # > security add-generic-password -a stig@brautaset.org -s mbsync-gandi-password -w APP-SPECIFIC-PASSWORD

      IMAPStore remote
      Account gandi

      MaildirStore local
      Path ~/Mail/
      Inbox ~/Mail/INBOX
      Trash trash

      Channel inbox
      Master :remote:
      Slave :local:
      Create Slave
      SyncState *

      Channel sent
      Master :remote:Sent
      Slave :local:sent
      Create Slave
      SyncState *

      Channel org-mode
      Master :remote:org-mode
      Slave :local:org-mode
      Create Slave
      SyncState *
      MaxMessages 500
      ExpireUnread yes
      Expunge Both

      Channel lilypond
      Master :remote:lilypond
      Slave :local:lilypond
      Create Slave
      SyncState *
      MaxMessages 500
      ExpireUnread yes
      Expunge Both

      Channel clojure
      Master :remote:clojure
      Slave :local:clojure
      Create Slave
      SyncState *
      MaxMessages 500
      ExpireUnread yes
      Expunge Both

      Channel tuls
      Master :remote:tuls
      Slave :local:tuls
      Create Slave
      SyncState *
      MaxMessages 500
      Expunge Both

      Channel archive
      Master :remote:archive
      Slave :local:archive
      Create Slave
      SyncState *
    #+END_SRC

    I don't like to leave Emacs.  Thus I create a function to call
    mbsync as an async shell process.  I run /this/ from the function I
    use to launch Notmuch.

    #+BEGIN_SRC emacs-lisp
      (defun sb/mbsync (&rest group)
	(interactive)
	(let ((group (or (and (car group) group) '("--all")))
	      (command `("mbsync" "--verbose" "--quiet" ,@group)))
	  (message "Starting %s.." (mapconcat 'identity command " "))
	  (apply 'start-process "mbsync" "*mbsync*" command)))
    #+END_SRC

*** Sending mail with MSMTP

    MSMTP's configuration is really simple, and it will detect the
    account to use from the "from" address.  Passwords are stored in
    the system Keychain.  See the [[http://msmtp.sourceforge.net/doc/msmtp.html#Authentication][Authentication]] section in the msmtp
    documentation for details.

    : security add-internet-password -s mail.gandi.net -r smtp -a stig@brautaset.org -w

    #+BEGIN_SRC conf :tangle ~/.msmtprc
      defaults
      port 587
      tls on
      tls_trust_file /etc/ssl/cert.pem
      auth on

      account private
      from stig@brautaset.org
      host mail.gandi.net
      user stig@brautaset.org
    #+END_SRC

    Finally we have to tell Emacs to use msmtp to send mail.  (And to
    kill the message buffer on exit.)

    #+BEGIN_SRC emacs-lisp
      (setq message-send-mail-function 'message-send-mail-with-sendmail
	    sendmail-program "msmtp"
	    message-sendmail-envelope-from 'header
	    mail-envelope-from 'header
	    mail-specify-envelope-from t)

      (setq message-kill-buffer-on-exit t)
    #+END_SRC

*** Compose Emails with Org mode

    Very occasionally I want to create HTML mail. (For tables, for
    example.) I then write my message using Org mode syntax and use
    org-mime-htmlize.

    #+BEGIN_SRC emacs-lisp
      (use-package org-mime
	:bind (:map message-mode-map
		    ("C-c h" . org-mime-htmlize))
	:custom
	(org-mime-preserve-breaks nil))
    #+END_SRC

*** Linking to Notmuch from Org

    I don't like using my email inbox as a todo list.  When I receive
    an email I need to act on but /can't yet/ for some reason, I link to
    it from my Org mode agenda and archive it.  When Org agenda prompts
    me I can click on the link and immediately get to the mail in my
    archive, and can reply to it from there.

    #+begin_src emacs-lisp
    (use-package org-notmuch
      :ensure org-plus-contrib
      :after (org notmuch))
    #+end_src

** Org drill (for learning new things)

   I use org-drill for drilling music theory.

   #+begin_src emacs-lisp
     (use-package org-drill
       :pin melpa
       :init
       (setq org-drill-add-random-noise-to-intervals-p t)
       (setq org-drill-adjust-intervals-for-early-and-late-repetitions-p t))
   #+end_src

** Plant UML Mode

   I use this for [[http://plantuml.com/sequence.html][sequence diagrams]] etc.

   #+BEGIN_SRC emacs-lisp
     (use-package plantuml-mode
       :ensure-system-package plantuml
       :mode "\\.puml\\'"
       :init
       (setq org-plantuml-jar-path
	     (expand-file-name "~/.nix-profile/lib/plantuml.jar")))
   #+END_SRC

** Simple HTML Renderer (HTML Email)

   I mostly use shr for reading HTML mail.  I normally use a
   fullscreen window, but I don't like reading HTML mails with lines
   running all the way across.  Thus I prefer linebreaks roughly every
   80 characters.

   #+begin_src emacs-lisp
   (setq shr-width 80)
   #+end_src

** Spell Checking

   I use aspell, with British English dictionary.

   #+BEGIN_SRC emacs-lisp
     (use-package ispell
       :ensure nil
       :ensure-system-package ((aspell . aspell)
			       ("~/.nix-profile/lib/aspell/british.alias" . aspell-dict-en)
			       ("~/.nix-profile/lib/aspell/en-computers.rws" . aspell-dict-en-computers)
			       ("~/.nix-profile/lib/aspell/en_GB-science.rws" . aspell-dict-en-science))
       :init
       (setq ispell-dictionary "british"
	     ispell-extra-args '("-W" "2" "--sug-mode=ultra")))
   #+END_SRC

   Configure aspell and let it find dictionaries:

   #+begin_src conf :tangle ~/.aspell.conf
   master british
   extra-dicts en-computers.rws
   add-extra-dicts en_GB-science.rws
   data-dir /Users/stig/.nix-profile/lib/aspell
   #+end_src

** YAML

   CircleCI and CloudFormation loves YAML.

   #+BEGIN_SRC emacs-lisp
   (use-package yaml-mode)
   #+END_SRC

* Org mode

  I use Org mode for all writing I initiate.  Org mode's support for
  tables, TOC, footnotes, TODO and Agenda items makes it an easy
  choice.  Gists and GitHub READMEs support Org mode too, and I can
  export to other formats including if I want.

  The particular version of package I use is annoying to install
  because the installed package has a different name from what you
  would use in your config.  However, =use-package= supports this by
  passing the name of the package to install as the value to =:ensure=.

  The Org manual expects the =C-c {l,a,c}= keybindings to be available
  in any mode, so define them globally.  I prefer to follow
  conventions.  It makes reading the manual and tutorials a lot
  easier!

  I love Org's markup so much I wrote a JIRA export backend for it.  I
  also write in Org and export to GitHub.  GitHub unfortunately
  doesn't properly ignore linebreaks in Markdown, so I use the =gfm=
  exporter, as this deletes linebreaks.  This means the rendered
  paragraphs re-flow properly on GitHub.

  I use Org's refiling when "refactoring" documents such as this one.
  I learnt about it from this from [[https://www.youtube.com/watch?v=ECWtf6mAi9k][this YouTube video]].

  #+BEGIN_SRC emacs-lisp
    (use-package org
      :ensure org-plus-contrib
      :bind (("C-c l" . org-store-link)
	     ("C-x C-<return>" . org-insert-subheading)
	     ("C-S-<return>" . org-insert-todo-subheading)
	     :map org-mode-map
	     ("C-n" . org-next-link)
	     ("C-p" . org-previous-link))

      :mode (("\\.org\\'" . org-mode)
	     ("\\.org_archive\\'" . org-mode))

      :custom
      (org-link-file-path-type 'relative)
      (org-log-into-drawer t "When hitting C-c C-z to take a note, always put it in the LOGBOOK drawer")
      (org-catch-invisible-edits 'smart)
      (org-export-copy-to-kill-ring 'if-interactive "If running interactively, I want export to copy to the kill-ring")
      (org-export-backends '(html gfm jira latex))
      (org-hide-emphasis-markers t)
      (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

      (org-refile-use-outline-path 'file "Allow refiling to sub-paths")
      (org-refile-allow-creating-parent-nodes 'confirm)
      (org-refile-targets '((nil . (:level . 1))
			    (org-agenda-files . (:maxlevel . 2))
			    (org-agenda-files . (:tag . "PROJ"))

			    ;; Add special rule for refiling to
			    ;; Someday.org & Leisure so we can omit
			    ;; them from org-agenda-files but still
			    ;; refile there
			    ("~/org/Someday.org" . (:maxlevel . 2))
			    ("~/org/Leisure.org" . (:maxlevel . 2))))
      (org-goto-interface 'outline-path-completion "Make 'org-refile' work better with Ivy")
      (org-outline-path-complete-in-steps nil "Make 'org-refile' work better with Ivy"))

    ;; Install, but do not load.  They're loaded at export time.
    (use-package ox-jira :pin melpa :no-require t)
    (use-package ox-gfm :no-require t)
  #+END_SRC

** Agenda

   I use Org Agenda for keeping track of my TODOs.

   I don't normally use properties, so I ignore most to help speed
   up my agenda view. ([[http://orgmode.org/worg/agenda-optimization.html][ref]])

   I configure TODO list and tag search to ignore future scheduled,
   deadlined, and timestamped issues.  These will show in the Agenda
   eventually anyway.

   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :ensure org-plus-contrib
       :bind ("C-c a" . org-agenda)
       :custom
       (org-agenda-include-diary t)
       (org-agenda-ignore-properties '(effort appt stats))

       (org-agenda-todo-ignore-scheduled 'future)
       (org-agenda-todo-ignore-deadlines 'far)
       (org-agenda-todo-ignore-timestamp 'future)

       (org-agenda-tags-todo-honor-ignore-options t)

       (org-agenda-skip-deadline-prewarning-if-scheduled t)
       (org-agenda-skip-scheduled-if-deadline-is-shown 'not-today)

       (org-log-done 'time)

       (org-stuck-projects '("/PROJ" ("TODO" "NEXT" "WAITING") nil ""))
       (org-agenda-custom-commands
	   '(("d" "Day Agenda"
	      ((agenda "" ((org-agenda-span 'day)))))
	     ("S" "Someday"
	      ((todo "PROJ"
		     ((org-agenda-files '("~/org/Someday.org"))))
	       (todo "TODO"
		     ((org-agenda-todo-list-sublevels nil)
		      (org-agenda-files '("~/org/Someday.org")))))))))
   #+END_SRC

** Capturing

   Set up capture templates.  I learnt about these from [[http://koenig-haunstetten.de/2014/08/29/the-power-of-orgmode-capture-templates/][Rainer's blog
   post]] (and YouTube series).  It has grown a bit since then.

   #+BEGIN_SRC emacs-lisp
     (use-package org-capture
       :ensure org-plus-contrib
       :bind ("C-c c" . org-capture)
       :custom
       (org-default-notes-file "~/org/inbox.org")
       (org-capture-templates
	'(("t" "TODOs")
	  ("tn" "Todo Right Now (clock in!)" entry (file "")
	   "* NEXT %?\n\n  %i" :clock-in t :clock-keep t)
	  ("tt" "Plain TODO entry (with initial content if marked)" entry (file "")
	   "* TODO %?\n\n  %i")
	  ("tl" "TODO entry with link" entry (file "")
	   "* TODO %?\n\n  %a\n\n  %i")
	  ("tr" "Process email" entry (file "")
	   "* TODO %:subject\n  SCHEDULED: %^t\n  %a\n\n  %?")
	  ("te" "To Expense" entry (file "")
	   "* TODO %:subject  :EXPENSE:\n  SCHEDULED: %^t\n\n  %a\n")
	  ("tp" "New Project" entry (file "")
	   "* PROJ %^{Project Name}\n  :LOGBOOK:\n  - Added: %U\n  :END:")
	  ("tT" "Trip" entry (file "")
	   (file "templates/trip.org") :empty-lines 1)

	  ("l" "Log Learning" entry (file+datetree "learning.org")
	   "* %^{Title} %^g\n  %?")

	  ("n" "Note" entry (file+datetree "notes.org")
	   "* %^{Subject} %^g\n\n  %?"
	   :empty-lines 1
	   :clock-in t)

	  ("m" "Meter Readings")
	  ("mg" "Gas Meter" table-line (file "notes/gas-consumption.org")
	   "|%^{Reading Time}u|%^{Reading Value}|%^{Price Per Litre|0.7}"
	   :table-line-pos "II-1")
	  ("me" "Electricity Meter" table-line (file "notes/electricity-consumption.org")
	   "|%^{Reading Time}u|%^{Reading Value}|%^{Price Per Unit|0.1412}"
	   :table-line-pos "II-1")

	  ("b" "Blog Post" plain
	   (file capture-blog-post-file)
	   (file "templates/blog-post.org"))

	  ("r" "GTD Review" entry (file+datetree "GTDReview.org")
	   (file "templates/gtd-review.org")
	   :empty-lines 1
	   :jump-to-captured t)))

       :config
       (defun capture-blog-post-file ()
	 (let* ((title (read-string "Slug: "))
		(slug (replace-regexp-in-string "[^a-z0-9]+" "-" (downcase title))))
	   (expand-file-name
	    (format "~/blog/articles/%s/%s.org"
		    (format-time-string "%Y" (current-time))
		    slug)))))
   #+END_SRC

** Babel

   Org Babel is magical: execute code from many different languages in
   the same file, and capture the output!  I list the languages I want
   to support.

   Some Babel backends (like ditaa) require specific configuration.  I
   set that here too.

   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
	(ditaa . t)
	(plantuml . t)
	(dot . t)
	(sql . t)
	(shell . t)))

     (use-package ob-ditaa
       :ensure org-plus-contrib
       :ensure-system-package ("~/.nix-profile/lib/ditaa.jar" . ditaa)
       :custom
       (org-ditaa-jar-path (expand-file-name "~/.nix-profile/lib/ditaa.jar")))
   #+END_SRC

** Attachments

   One annoying thing is not being able to find attachments once
   you've attached files. Luckily, it turns out you can ask Org to
   create links to attachments.

   #+BEGIN_SRC emacs-lisp
   (setq org-attach-store-link-p t)
   #+END_SRC

* Themes
** Load one theme at a time

   For years I thought that theme switching in Emacs was broken---until
   I read Greg Hendershott's [[http://www.greghendershott.com/2017/02/emacs-themes.html][emacs themes]] blog post. It turns out Emacs
   supports /multiple themes being active at the same time/, which I'm
   sure is convenient sometimes but becomes a right nuisance when
   attempting to switch themes IMO. Add a utility function to disable
   all currently enabled themes first.

   #+BEGIN_SRC emacs-lisp
     (defun sb/disable-all-themes ()
       (interactive)
       (mapc #'disable-theme custom-enabled-themes))

     (defun sb/load-theme (theme)
       "Enhance `load-theme' by first disabling enabled themes."
       (sb/disable-all-themes)
       (load-theme theme))
   #+END_SRC

** Hydra Theme Switching

   Switch themes with Hydra! This loads all available themes and
   presents a menu to let you switch between them. The theme switcher
   is bound to =C-c w t=.

   The switcher is, regretfully, not automatically updated when
   installing new themes from the package selector menu, so you need to
   evaluate this block again manually.

   #+BEGIN_SRC emacs-lisp
     (setq sb/hydra-selectors
	   "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

     (defun sb/sort-themes (themes)
       (sort themes (lambda (a b) (string< (symbol-name a) (symbol-name b)))))

     (defun sb/load-theme-heads (themes)
       (mapcar* (lambda (a b)
		  (list (char-to-string a) `(sb/load-theme ',b) (symbol-name b)))
		sb/hydra-selectors themes))

     (defun sb/switch-theme ()
       (interactive)
       (call-interactively
	(eval `(defhydra sb/select-themes (:hint nil :color pink)
		 "Select Theme"
		 ,@(sb/load-theme-heads (sb/sort-themes (custom-available-themes)))
		 ("DEL" (sb/disable-all-themes))
		 ("RET" nil "done" :color blue)))))
   #+END_SRC

* Blogging

  I create blog entries in a directory under =~/blog= and link to them
  from the main index page.  It has so far been a manual job, but I
  have finally managed to create a function to automate it a bit.

  #+BEGIN_SRC emacs-lisp
    (defun sb/org-kw-get (key)
      "Return a lambda that takes an Org keyword element and returns
    its :value property if its :key property matches `key'."
      `(lambda (kw)
	 (if (equal ,key (org-element-property :key kw))
	     (org-element-property :value kw))))

    (defun sb/blog-post-index-entry ()
      "Call in a blog post to get an entry suitable for linking to this
    post from the index page."
      (interactive)
      (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
	     (tree (org-element-parse-buffer))

	     (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
	     (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY")))
	     (abstract
	      (org-element-interpret-data
	       (org-element-map tree 'special-block
		 (lambda (sb)
		   (if (equal "abstract" (org-element-property :type sb))
		       (org-element-contents sb)))))))

	(with-temp-buffer
	  (org-mode)
	  (org-insert-heading)

	  ;; Would have loved to use `org-insert-link' here but
	  ;; I can't stop it from presenting a prompt.
	  (insert "[[file:" path "][" title "]]\n\n"
		  abstract
		  "\n\n")

	  ;; Need to go back to the first line to set tags, as
	  ;; org-set-tags assumes point is on a headline.
	  (goto-char (point-min))
	  (org-set-tags categories)

	  ;; Return the contents temporary buffer as a string *without properties*
	  (copy-region-as-kill
	   (point-min) (point-max)))))

    (defun sb/blog-post-rss-entry ()
      "Call in a blog post to get an entry suitable for linking to this
    post from the index page."
      (interactive)
      (let* ((path (s-chop-prefix (expand-file-name "~/blog/") (buffer-file-name)))
	     (tree (org-element-parse-buffer))

	     (title (org-element-map tree 'keyword (sb/org-kw-get "TITLE") nil t))
	     (categories (org-element-map tree 'keyword (sb/org-kw-get "CATEGORY")))
	     (abstract
	      (org-element-interpret-data
	       (org-element-map tree 'special-block
		 (lambda (sb)
		   (if (equal "abstract" (org-element-property :type sb))
		       (org-element-contents sb)))))))

	(with-temp-buffer
	  (org-mode)
	  (org-insert-heading)
	  (insert title "\n\n" abstract)
	  (org-set-property "RSS_PERMALINK"
			    (format "%s.html"
				    (file-name-sans-extension path)))
	  (copy-region-as-kill
	   (point-min) (point-max)))))


    (defun sb/find-drafts ()
      "Find org files in `~/blog/articles' not already linked from
		  `~/blog/index.org'."
      (interactive)
      (let* ((prefix (expand-file-name "~/blog/"))
	     (posts
	      (directory-files-recursively
	       (concat prefix "articles") ".org"))
	     (index-contents (get-string-from-file (concat prefix "index.org")))
	     (drafts (cl-remove-if (lambda (needle)
				     (string-match
				      (string-remove-prefix prefix needle)
				      index-contents))
				   posts))
	     (buffer-name "*blog drafts*"))
	(if drafts
	    (progn
	      (with-current-buffer (get-buffer-create buffer-name)
		(erase-buffer)
		(org-mode)
		(insert
		 (mapconcat
		  (lambda (entry)
		    (format "- file:%s" entry))
		  drafts
		  "\n"))
		(buffer-string))
	      (unless (get-buffer-window buffer-name t)
		(pop-to-buffer buffer-name nil t))
	      (shrink-window-if-larger-than-buffer
	       (get-buffer-window buffer-name)))
	  (message "No drafts could be found!"))))
  #+END_SRC

** Blog server

   While noodling around with my blog locally I publish to
   =~/public_html= and use a simple Python server to host it.
   Previously I launched it in an Eshell buffer, but it's nicer to
   run it as an asynchronous command tied to a buffer.

   #+begin_src emacs-lisp
     (use-package python3
       :no-require t
       :ensure nil
       :ensure-system-package (python3 . python3-3.7.4))

     (defun sb/blog-server ()
       (interactive)
       (start-process "Blog Server" "*blog server*"
		      "python3"
		      "-m" "http.server"
		      "--directory" (expand-file-name "~/public_html/"))
       (message "Blog Server started"))
   #+end_src
